This page intentionally left blank

Logical Foundations of Proof Complexity
This book treats bounded arithmetic and propositional proof complexity from
the point of view of computational complexity. The ﬁrst seven chapters include
the necessary logical background for the material and are suitable for a graduate
course.
Associated with each of many complexity classes are both a two-sorted predicate calculus theory, with induction restricted to concepts in the class, and a
propositional proof system. The complexity classes range from AC0 for the weakest theory up to the polynomial hierarchy. Each bounded theorem in a theory
translates into a family of (quantiﬁed) propositional tautologies with polynomial
size proofs in the corresponding proof system. The theory proves the soundness
of the associated proof system.
The result is a uniform treatment of many systems in the literature, including
Buss’s theories for the polynomial hierarchy and many disparate systems for
complexity classes such as AC0 , AC0 (m), TC0 , NC1 , L, NL, NC, and P.

Stephen Cook is a professor at the University of Toronto. He is author of many
research papers, including his famous 1971 paper “The Complexity of Theorem
Proving Procedures,” and the 1982 recipient of the Turing Award. He was awarded
a Steacie Fellowship in 1977 and a Killam Research Fellowship in 1982 and
received the CRM/Fields Institute Prize in 1999. He is a Fellow of the Royal
Society of London and the Royal Society of Canada and was elected to membership
in the National Academy of Sciences (United States) and the American Academy
of Arts and Sciences.
Phuong Nguyen is a postdoctoral researcher at McGill University. He received his
MSc and PhD degrees from University of Toronto in 2004 and 2008, respectively.
He has been awarded postdoctoral fellowships by the Eduard Čech Center for
Algebra and Geometry (the Czech Republic) and by the Natural Sciences and
Engineering Research Council of Canada (NSERC).

PERSPECTIVES IN LOGIC

The Perspectives in Logic series publishes substantial, high-quality books whose
central theme lies in any area or aspect of logic. Books that present new material
not now available in book form are particularly welcome. The series ranges from
introductory texts suitable for beginning graduate courses to specialized monographs at the frontiers of research. Each book offers an illuminating perspective
for its intended audience.
The series has its origins in the old Perspectives in Mathematical Logic series
edited by the -Group for “Mathematische Logik” of the Heidelberger Akademie
der Wissenchaften, whose beginnings date back to the 1960s. The Association for
Symbolic Logic has assumed editorial responsibility for the series and changed its
name to reﬂect its interest in books that span the full range of disciplines in which
logic plays an important role.
Pavel Pudlak, Managing Editor
Mathematical Institute of the Academy of Sciences of the Czech Republic
Editorial Board
Michael Benedikt
Department of Computing Science, University of Oxford
Michael Glanzberg
Department of Philosophy, University of California, Davis
Carl G. Jockusch, Jr.
Department of Mathematics, University of Illinois at Urbana-Champaign
Michael Rathjen
School of Mathematics, University of Leeds
Thomas Scanlon
Department of Mathematics, University of California, Berkeley
Simon Thomas
Department of Mathematics, Rutgers University
ASL Publisher
Richard A. Shore
Department of Mathematics, Cornell University
For more information, see http://www.aslonline.org/books perspectives.html

PERSPECTIVES IN LOGIC

Logical Foundations of Proof Complexity

STEPHEN COOK
University of Toronto

PHUONG NGUYEN
McGill University

association for symbolic logic

CAMBRIDGE UNIVERSITY PRESS

Cambridge, New York, Melbourne, Madrid, Cape Town, Singapore,
São Paulo, Delhi, Dubai, Tokyo
Cambridge University Press
The Edinburgh Building, Cambridge CB2 8RU, UK
Published in the United States of America by Cambridge University Press, New York
www.cambridge.org
Information on this title: www.cambridge.org/9780521517294
© Association for Symbolic Logic 2010
This publication is in copyright. Subject to statutory exception and to the
provision of relevant collective licensing agreements, no reproduction of any part
may take place without the written permission of Cambridge University Press.
First published in print format 2010
ISBN-13

978-0-511-67716-8

eBook (NetLibrary)

ISBN-13

978-0-521-51729-4

Hardback

Cambridge University Press has no responsibility for the persistence or accuracy
of urls for external or third-party internet websites referred to in this publication,
and does not guarantee that any content on such websites is, or will remain,
accurate or appropriate.

CONTENTS

Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
Chapter I.

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1

Chapter II. The Predicate Calculus and the System LK . . . . . . . 9
II.1.
Propositional Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
II.1.1. Gentzen’s Propositional Proof System PK . . . . . . . . . . . . . 10
II.1.2. Soundness and Completeness of PK . . . . . . . . . . . . . . . . . . 12
II.1.3. PK Proofs from Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . 13
II.1.4. Propositional Compactness . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
II.2.
Predicate Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
II.2.1. Syntax of the Predicate Calculus . . . . . . . . . . . . . . . . . . . . . . 17
II.2.2. Semantics of Predicate Calculus. . . . . . . . . . . . . . . . . . . . . . . 19
II.2.3. The First-Order Proof System LK . . . . . . . . . . . . . . . . . . . . 21
II.2.4. Free Variable Normal Form . . . . . . . . . . . . . . . . . . . . . . . . . . 23
II.2.5. Completeness of LK without Equality . . . . . . . . . . . . . . . . 24
II.3.
Equality Axioms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
II.3.1. Equality Axioms for LK . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
II.3.2. Revised Soundness and Completeness of LK . . . . . . . . . . 33
II.4.
Major Corollaries of Completeness . . . . . . . . . . . . . . . . . . . 34
II.5.
The Herbrand Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
II.6.
Notes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
Chapter III. Peano Arithmetic and Its Subsystems. . . . . . . . . . . . . 39
III.1.
Peano Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
III.1.1. Minimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
III.1.2. Bounded Induction Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . 44
III.1.3. Strong Induction Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
III.2.
Parikh’s Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
III.3.
Conservative Extensions of IΔ0 . . . . . . . . . . . . . . . . . . . . . . . 49
III.3.1. Introducing New Function and Predicate Symbols . . . . . 50
III.3.2. IΔ0 : A Universal Conservative Extension of IΔ0 . . . . . . . 54
III.3.3. Deﬁning y = 2x and BIT(i, x) in IΔ0 . . . . . . . . . . . . . . . . . 59
III.4.
IΔ0 and the Linear Time Hierarchy . . . . . . . . . . . . . . . . . . . 65
vii

viii

Contents
III.4.1.
III.4.2.
III.4.3.
III.5.
III.6.

The Polynomial and Linear Time Hierarchies . . . . . . . . . . 65
Representability of LTH Relations . . . . . . . . . . . . . . . . . . . . 66
Characterizing the LTH by IΔ0 . . . . . . . . . . . . . . . . . . . . . . . 69
Buss’s S2i Hierarchy: The Road Not Taken. . . . . . . . . . . . . 70
Notes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

Chapter IV. Two-Sorted Logic and Complexity Classes . . . . . . . 73
IV.1.
Basic Descriptive Complexity Theory . . . . . . . . . . . . . . . . . 74
IV.2.
Two-Sorted First-Order Logic . . . . . . . . . . . . . . . . . . . . . . . . 76
IV.2.1. Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
IV.2.2. Semantics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
IV.3.
Two-Sorted Complexity Classes . . . . . . . . . . . . . . . . . . . . . . . 80
IV.3.1. Notation for Numbers and Finite Sets. . . . . . . . . . . . . . . . . 80
IV.3.2. Representation Theorems. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
IV.3.3. The LTH Revisited . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
IV.4.
The Proof System LK 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
IV.4.1. Two-Sorted Free Variable Normal Form . . . . . . . . . . . . . . 90
IV.5.
Single-Sorted Logic Interpretation . . . . . . . . . . . . . . . . . . . . 91
IV.6.
Notes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
Chapter V. The Theory V 0 and AC 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
V.1.
Deﬁnition and Basic Properties of V i . . . . . . . . . . . . . . . . . 95
V.2.
Two-Sorted Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
V.3.
Parikh’s Theorem for Two-Sorted Logic . . . . . . . . . . . . . . . 104
V.4.
Deﬁnability in V 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
V.4.1.
Δ11 -Deﬁnable Predicates. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
V.5.
The Witnessing Theorem for V 0 . . . . . . . . . . . . . . . . . . . . . . 117
V.5.1.
Independence Follows from the Witnessing Theorem
for V 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
V.5.2.
Proof of the Witnessing Theorem for V 0 . . . . . . . . . . . . . . . 119
0
V : Universal Conservative Extension of V 0 . . . . . . . . . . . 124
V.6.
V.6.1.
Alternative Proof of the Witnessing Theorem for V 0 . . . 127
V.7.
Finite Axiomatizability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
V.8.
Notes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
Chapter VI. The Theory V 1 and Polynomial Time . . . . . . . . . . . . . . 133
VI.1.
Induction Schemes in V i . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
VI.2.
Characterizing P by V 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
VI.2.1. The “If ” Direction of Theorem VI.2.2 . . . . . . . . . . . . . . . . . 137
VI.2.2. Application of Cobham’s Theorem . . . . . . . . . . . . . . . . . . . . 140
VI.3.
The Replacement Axiom Scheme . . . . . . . . . . . . . . . . . . . . . 142
VI.3.1. Extending V 1 by Polytime Functions . . . . . . . . . . . . . . . . . . 145
VI.4.
The Witnessing Theorem for V 1 . . . . . . . . . . . . . . . . . . . . . . 147
 1 . . . . . . . . . . . . . . . . . . . . . . . . . 150
VI.4.1. The Sequent System LK 2 -V

Contents
VI.4.2.
VI.5.

ix

Proof of the Witnessing Theorem for V 1 . . . . . . . . . . . . . . . 154
Notes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156

Chapter VII. Propositional Translations. . . . . . . . . . . . . . . . . . . . . . 159
VII.1. Propositional Proof Systems . . . . . . . . . . . . . . . . . . . . . . . . . . 160
VII.1.1. Treelike vs Daglike Proof Systems . . . . . . . . . . . . . . . . . . . . . 162
VII.1.2. The Pigeonhole Principle and Bounded Depth PK . . . . . 163
VII.2. Translating V 0 to bPK . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
VII.2.1. Translating ΣB0 Formulas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
 0 and LK 2 -V
 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
VII.2.2. V
VII.2.3. Proof of the Translation Theorem for V 0 . . . . . . . . . . . . . . 170
VII.3. Quantiﬁed Propositional Calculus . . . . . . . . . . . . . . . . . . . . 173
VII.3.1. QPC Proof Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
VII.3.2. The System G . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
VII.4. The Systems Gi and Gi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
VII.4.1. Extended Frege Systems and Witnessing in G1 . . . . . . . . . 186
VII.5. Propositional Translations for V i . . . . . . . . . . . . . . . . . . . . . 191
VII.5.1. Translating V 0 to Bounded Depth G0 . . . . . . . . . . . . . . . . . 195
VII.6. Notes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
Chapter VIII. Theories for Polynomial Time and Beyond . . . . . . 201
VIII.1. The Theory VP and Aggregate Functions . . . . . . . . . . . . . 201
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
VIII.1.1. The Theory VP
VIII.2. The Theory VPV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
VIII.2.1. Comparing VPV and V 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
VIII.2.2. VPV Is Conservative over VP . . . . . . . . . . . . . . . . . . . . . . . . 214
VIII.3. TV 0 and the TV i Hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . 217
VIII.3.1. TV 0 ⊆ VPV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
VIII.3.2. Bit Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
VIII.4. The Theory V 1 -HORN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
VIII.5. TV 1 and Polynomial Local Search . . . . . . . . . . . . . . . . . . . . 228
VIII.6. KPT Witnessing and Replacement . . . . . . . . . . . . . . . . . . . . 237
VIII.6.1. Applying KPT Witnessing . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
VIII.7. More on V i and TV i . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
VIII.7.1. Finite Axiomatizability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
VIII.7.2. Deﬁnability in the V ∞ Hierarchy . . . . . . . . . . . . . . . . . . . . . 245
VIII.7.3. Collapse of V ∞ vs Collapse of PH . . . . . . . . . . . . . . . . . . . . 253
VIII.8. RSUV Isomorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
VIII.8.1. The Theories S2i and T2i . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
VIII.8.2. RSUV Isomorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
VIII.8.3. The  Translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
VIII.8.4. The  Translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
VIII.8.5. The RSUV Isomorphism between S2i and V i . . . . . . . . . . 263
VIII.9. Notes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266

x

Contents

Chapter IX. Theories for Small Classes . . . . . . . . . . . . . . . . . . . . . . . 267
IX.1.
AC 0 Reductions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
IX.2.
Theories for Subclasses of P . . . . . . . . . . . . . . . . . . . . . . . . . . 272
IX.2.1. The Theories VC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
IX.2.2. The Theory VC
IX.2.3. The Theory VC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
IX.2.4. Obtaining Theories for the Classes of Interest . . . . . . . . . . 280
IX.3.
Theories for TC 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
IX.3.1. The Class TC 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
 0 , and VTC 0 . . . . . . . . . . . . . . . . 283
IX.3.2. The Theories VTC 0 , VTC
IX.3.3. Number Recursion and Number Summation . . . . . . . . . . 287
IX.3.4. The Theory VTC 0 V . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
IX.3.5. Proving the Pigeonhole Principle in VTC 0 . . . . . . . . . . . . . 291
IX.3.6. Deﬁning String Multiplication in VTC 0 . . . . . . . . . . . . . . . 293
IX.3.7. Proving Finite Szpilrajn’s Theorem in VTC 0 . . . . . . . . . . . 298
IX.3.8. Proving Bondy’s Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
IX.4.
Theories for AC 0 (m) and ACC . . . . . . . . . . . . . . . . . . . . . . . 303
IX.4.1. The Classes AC 0 (m) and ACC . . . . . . . . . . . . . . . . . . . . . . . . 303
0 (2), and V 0 (2). . . . . . . . . . . . . . . . . 304
IX.4.2. The Theories V 0 (2), V
IX.4.3. The “onto” PHP and Parity Principle . . . . . . . . . . . . . . . . . 306
IX.4.4. The Theory VAC 0 (2)V . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
IX.4.5. The Jordan Curve Theorem and Related Principles . . . . 309
IX.4.6. The Theories for AC 0 (m) and ACC . . . . . . . . . . . . . . . . . . . 313
IX.4.7. The Modulo m Counting Principles . . . . . . . . . . . . . . . . . . . 316
IX.4.8. The Theory VAC 0 (6)V . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
IX.5.
Theories for NC 1 and the NC Hierarchy . . . . . . . . . . . . . . 319
IX.5.1. Deﬁnitions of the Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320
IX.5.2. BSVP and NC 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
 1 , and VNC 1 . . . . . . . . . . . . . . . 323
IX.5.3. The Theories VNC 1 , VNC
IX.5.4. VTC 0 ⊆ VNC 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
IX.5.5. The Theory VNC 1 V . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
IX.5.6. Theories for the NC Hierarchy . . . . . . . . . . . . . . . . . . . . . . . . 335
IX.6.
Theories for NL and L . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
 and VNL . . . . . . . . . . . . . . . . . . . 339
IX.6.1. The Theories VNL, VNL,
1
IX.6.2. The Theory V -KROM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
 and VL . . . . . . . . . . . . . . . . . . . . . . . . 351
IX.6.3. The Theories VL, VL,
IX.6.4. The Theory VLV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 356
IX.7.
Open Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 358
IX.7.1. Proving Cayley–Hamilton in VNC 2 . . . . . . . . . . . . . . . . . . . 358
?
IX.7.2. VSL and VSL = VL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 358
IX.7.3. Deﬁning X/Y  in VTC 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360
IX.7.4. Proving PHP and Countm in V 0 (m) . . . . . . . . . . . . . . . . . . 360
IX.8.
Notes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360

Contents

xi

Chapter X. Proof Systems and the Reﬂection Principle . . . . . . 363
X.1.
Formalizing Propositional Translations . . . . . . . . . . . . . . . 364
X.1.1. Verifying Proofs in TC 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364
X.1.2. Computing Propositional Translations in TC 0 . . . . . . . . . 373
X.1.3. The Propositional Translation Theorem for TV i . . . . . . . 377
X.2.
The Reﬂection Principle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 382
X.2.1. Truth Deﬁnitions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
X.2.2. Truth Deﬁnitions vs Propositional Translations . . . . . . . . 387
X.2.3. RFN and Consistency for Subsystems of G . . . . . . . . . . . . 396
X.2.4. Axiomatizations Using RFN . . . . . . . . . . . . . . . . . . . . . . . . . 403
X.2.5. Proving p-Simulations Using RFN . . . . . . . . . . . . . . . . . . . . 407
X.2.6. The Witnessing Problems for G . . . . . . . . . . . . . . . . . . . . . . . 408
X.3.
VNC 1 and G0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410
X.3.1. Propositional Translation for VNC 1 . . . . . . . . . . . . . . . . . . . 410
X.3.2. The Boolean Sentence Value Problem . . . . . . . . . . . . . . . . . 414
X.3.3. Reﬂection Principle for PK . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
X.4.
VTC 0 and Threshold Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . 428
X.4.1. The Sequent Calculus PTK . . . . . . . . . . . . . . . . . . . . . . . . . . . 428
X.4.2. Reﬂection Principles for Bounded Depth PTK . . . . . . . . . 433
X.4.3. Propositional Translation for VTC 0 . . . . . . . . . . . . . . . . . . . 434
X.4.4. Bounded Depth GTC 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441
X.5.
Notes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442
Appendix A. Computation Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
A.1.
Deterministic Turing Machines . . . . . . . . . . . . . . . . . . . . . . . 445
A.1.1. L, P, PSPACE, and EXP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
A.2.
Nondeterministic Turing Machines . . . . . . . . . . . . . . . . . . . 449
A.3.
Oracle Turing Machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
A.4.
Alternating Turing Machines . . . . . . . . . . . . . . . . . . . . . . . . . 452
A.5.
Uniform Circuit Families . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 453
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465

PREFACE

“Proof complexity” as used here has two related aspects: (i) the complexity of proofs of propositional formulas, and (ii) the study of weak (i.e.,
“bounded”) theories of arithmetic. Aspect (i) goes back at least to Tseitin
[109], who proved an exponential lower bound on the lengths of proofs in
the weak system known as regular resolution. Later Cook and Reckhow
[46] introduced a general deﬁnition of propositional proof system and
related it to mainstream complexity theory by pointing out that such a
system exists in which all tautologies have polynomial length proofs iﬀ the
two complexity classes NP and co-NP coincide.
Aspect (ii) goes back to Parikh [88], who introduced the theory known
as IΔ0 , which is Peano Arithmetic with induction restricted to bounded
formulas. Paris and Wilkie advanced the study of IΔ0 and extensions in
a series of papers (including [90, 89]) which relate them to complexity
theory. Buss’s seminal book [20] introduced the much-studied interleaved
hierarchies S2i and T2i of theories related to the complexity classes Σpi
making up the polynomial hierarchy. Clote and Takeuti [38] and others
introduced a host of theories related to other complexity classes.
The notion of propositional translation, which relates aspects (i) and
(ii), goes back to [39], which introduced the equational theory PV for
polynomial time functions and showed how theorems of PV can be translated into families of tautologies which have polynomial length proofs in
the extended Frege proof system. Later (and independently) Paris and
Wilkie [90] gave an elegant translation of bounded theorems in the relativized theory IΔ0 (R) to polynomial length families of proofs in the weak
propositional system bounded-depth Frege. Krajı́ček and Pudlák [73] introduced a hierarchy of proof systems Gi  for the quantiﬁed propositional
calculus and showed how bounded theorems in Buss’s theory T2i translate
into polynomial length proofs in Gi .
The aim of the present book is, ﬁrst of all, to provide a suﬃcient
background in logic for students in computer science and mathematics
to understand our treatment of bounded arithmetic, and then to give an
original treatment of the subject which emphasizes the three-way relationship among complexity classes, weak theories, and propositional proof
systems.
xiii

xiv

Preface

Our treatment is unusual in that after Chapters 2 and 3 (which present
Gentzen’s sequent calculus LK and the bounded theory IΔ0 ) we present
our theories using the two-sorted vocabulary of Zambella [112]: one sort
for natural numbers and the other for binary strings (i.e., ﬁnite sets of
natural numbers). Our point of view is that the objects of interest are
the binary strings: they are the natural inputs to the computing devices
(Turing machines and Boolean circuits) studied by complexity theorists.
The numbers are there as auxiliary variables, for example, to index the
bits in the strings and measure their length. One reason for using this
vocabulary is that the weakest complexity classes (such as AC 0 ) that we
study do not contain integer multiplication as a function, and since standard theories of arithmetic include multiplication as a primitive function,
it is awkward to turn them into theories for these weak classes. In fact,
our theories are simpler than many of the usual single-sorted theories in
bounded arithmetic, because there is only one primitive function |X | (the
length of X ) for strings X , while the axioms for the number sort are just
those for IΔ0 .
Another advantage of using the two-sorted systems is that our propositional translations are especially simple: they are based on the Paris-Wilkie
method [90]. The propositional atoms in the translation of a bounded
formula ϕ(X ) with a free string variable X simply represent the bits of X .
Chapter 5 introduces our base theory V 0 , which corresponds to the
smallest complexity class AC 0 which we consider. All two-sorted theories
we consider are extensions of V 0 . Chapter 6 studies V 1 , which is a twosorted version of Buss’s theory S21 and is related to the complexity class
P (polynomial time). Chapter 7 introduces propositional translations for
some theories. These translate bounded predicate formulas to families of
quantiﬁed Boolean formulas. Chapter 8 introduces “minimal” theories
for polynomial time by a method which is used extensively in Chapter
9. Chapter 8 also presents standard results concerning Buss’s theories
S2i and T2i , but in the form of the two-sorted versions V i and TV i of
these theories. Chapter 9 is based on the second author’s PhD thesis,
and uses an original uniform method to introduce minimal theories for
many complexity classes between AC 0 and P. Some of these are related
to single-sorted theories in the literature. Chapter 10 gives more examples
of propositional translations and gives evidence for the thesis that each
theory has a corresponding propositional proof system which serves as a
kind of nonuniform version of the theory.
One purpose of this book is to serve as a basis for a program we
call “Bounded Reverse Mathematics”. This is inspired by the Friedman/Simpson program Reverse Mathematics [101], where now “Bounded” refers to bounded arithmetic. The goal is to ﬁnd the weakest theory
capable of proving a given theorem. The theorems in question are those
of interest in computer science, and in general these can be proved in weak

Preface

xv

theories. From the complexity theory point of view, the idea is to ﬁnd
the smallest complexity class such that the theorem can be proved using
concepts in that class. This activity not only sheds light on the role of
complexity classes in proofs, it can also lead to simpliﬁed proofs. A good
example is Razborov’s [96] greatly simpliﬁed proof of Hastad’s Switching
Lemma, which grew out of his attempt to formalize the lemma using only
polynomial time concepts. His new proof led to important new results in
propositional proof complexity. Throughout the book we give examples
of theorems provable in the theories we describe.
The ﬁrst seven chapters of this book grew out of notes for a graduate
course taught several times beginning in 1998 at the University of Toronto
by the ﬁrst author. The prerequisites for the course and the book are some
knowledge of both mathematical logic and complexity theory. However,
Chapters 2 and 3 give a complete treatment of the necessary logic, and
the Appendix together with material scattered throughout should provide
suﬃcient background in complexity theory. There are exercises sprinkled
throughout the text, which are intended both to supplement the material
presented and to help the reader master the material. The more diﬃcult
exercises are marked with an asterisk.
Two sources have been invaluable to the authors in writing this book.
The ﬁrst is Krajı́ček’s monograph [72], which is an essential possession for
anyone working in this ﬁeld. The second source is Buss’s chapters [27, 28]
in the Handbook of Proof Theory. His chapter I provides an excellent
introduction to the proof theory of LK, and his chapter II provides a
thorough introduction to the ﬁrst-order theories of bounded arithmetic.
And of course Buss’s monograph [20] Bounded Arithmetic was the origin
of much of the material in our book.
We are grateful to Sam Buss and Jan Krajı́ček not only for their books
but also for their considerable encouragement and help during the lengthy
process of writing our book.
This book includes valuable input from several students of the ﬁrst
author as well as material from their PhD theses. The students include
(besides the second author) Antonina Kolokolova, Tsuyoshi Morioka,
Steven Perron, and Michael Soltys.
We are indebted to many others who have provided us with feedback on
earlier versions of the book. These include Noriko Arai, Toshi Arai, Anton Belov, Mark Braverman, Timothy Chow, Lila Fontes, Kaveh Ghasemloo, Remo Goetschi, Daniel Ivan, Emil Jeřábek, Akitoshi Kawamura,
Markus Latte, Dai Tri Man Le, Leonid Libkin, Dieter van Melkebeek,
Toni Pitassi, Francois Pitt, Pavel Pudlák, Alan Skelley, Robert Solovay,
Neil Thapen, Alasdair Urquhart, and Daniel Weller.
Stephen Cook
Phuong Nguyen

Chapter I

INTRODUCTION

This book studies logical systems which use restricted reasoning based
on concepts from computational complexity. The complexity classes of
interest lie mainly between the basic class AC 0 (whose members are computed by polynomial-size families of bounded-depth circuits), and the
polynomial hierarchy PH, and include the sequence
AC 0 ⊂ AC 0 (m) ⊆ TC 0 ⊆ NC 1 ⊆ L ⊆ NL ⊆ P ⊆ PH

(1)

where P is polynomial time. (See the Appendix for deﬁnitions.)
We associate with each of these classes a logical theory and a proof
system for the (quantiﬁed) propositional calculus. The proof system can
be considered a nonuniform version of the universal (or sometimes the
bounded) fragment of the theory. The functions deﬁnable in the logical
theory are those associated with the complexity class, and (in some cases)
the lines in a polynomial size proof in the propositional system express
concepts in the complexity class. Universal (or bounded) theorems of the
logical theory translate into families of valid formulas with polynomial
size proofs in the corresponding proof system. The logical theory proves
the soundness of the proof system.
Conceptually the theory VC associated with a complexity class C can
prove a given mathematical theorem if the induction hypotheses needed
in the proof can be formulated using concepts from C. We are interested
in trying to ﬁnd the weakest class C needed to prove various theorems of
interest in computer science.
Here are some examples of the three-way association among complexity
classes, theories, and proof systems:
class
AC 0
TC 0
NC 1
0
0
VTC
VNC 1
theory V
0
0
system AC -Frege TC -Frege Frege

P
PH
VP
V∞
eFrege Gi .

(2)

Consider for example the class NC 1 . The uniform version is ALogTime,
the class of problems solvable by an alternating Turing machine in time
O(log n). The deﬁnable functions in the associated theory VNC 1 are the
NC 1 functions, i.e., those functions whose bit graphs are NC 1 relations.
1

2

I. Introduction

A problem in nonuniform NC 1 is deﬁned by a polynomial-size family of
log-depth Boolean circuits, or equivalently a polynomial-size family of
propositional formulas. The corresponding propositional proof systems
are called Frege systems, and are described in standard logic textbooks: a
Frege proof of a tautology A consists of a sequence of propositional formulas ending in A, where each formula is either an axiom or follows from
earlier formulas by a rule of inference. Universal theorems of VNC 1 translate into polynomial-size families of Frege proofs. Finally VNC 1 proves
the soundness of Frege systems, and any proof system whose soundness
is provable in VNC 1 can be p-simulated by a Frege system (Theorem
X.3.11).
The famous open question in complexity theory is whether the conjecture that P is a proper subset of NP is in fact true (we know P ⊆ NP ⊆
PH). If P = NP then the polynomial hierarchy PH collapses to P, but it
is possible that PH collapses only to NP and still P = NP. What may be
less well known is that not only is it possible that PH = P, but it is consistent with our present knowledge that PH = AC 0 (6), so that all classes
in (1) might be equal except for AC 0 and AC 0 (p) for p prime. This is
one motivation for studying the theories associated with these complexity
classes, since it ought to be easier to separate the theories corresponding
to the complexity classes than to separate the classes themselves (but so
far the theories in (2) have not been separated, except for V 0 ).
A common example used to illustrate the complexity of the concepts
needed to prove a theorem is the Pigeonhole Principle (PHP). Our version
states that if n + 1 pigeons are placed in n holes, then some hole has two
or more pigeons. We can present an instance of the PHP using a Boolean
array P(i, j) (0 ≤ i ≤ n, 0 ≤ j < n), where P(i, j) asserts that pigeon i
is placed in hole j. Then the PHP can be formulated in the theory V 0 by
the formula
∀i ≤ n ∃j < n P(i, j) ⊃ ∃i1 , i2 ≤ n ∃j < n (i1 = i2 ∧ P(i1 , j) ∧ P(i2 , j)).
(3)
Ajtai [5] proved (in eﬀect) that this formula is not a theorem of V 0 , and
also that the propositional version (which uses atoms pij to represent
P(i, j) and ﬁnite conjunctions and disjunctions to express the bounded
universal and existential number quantiﬁers) does not have polynomial
size AC 0 -Frege proofs. The intuitive reason for this is that a counting
argument seems to be required to prove the PHP, but the complexity
class AC 0 cannot count the number of ones in a string of bits. On
the other hand, the class NC 1 can count, and indeed Buss proved that
the propositional PHP does have polynomial size Frege proofs, and his
method shows that (3) is a theorem of the theory VNC 1 . (In fact it is a
theorem of the apparently weaker theory VTC 0 .)

I. Introduction

3

A second example comes from linear algebra. If A and B are n × n
matrices over some ﬁeld, then
AB = I ⊃ BA = I.

(4)

A standard proof of this uses Gaussian elimination, which is a polynomialtime process. Indeed Soltys showed that (4) is a theorem of the theory VP
corresponding to polynomial-time reasoning, and it follows that its propositional translation (say over the ﬁeld of two elements) has polynomial-size
proofs in the corresponding proof system eFrege. It is an open question
whether (4) over GF(2) (or any ﬁeld) can be proved in VNC 1 , or whether
the propositional version has polynomial-size Frege proofs.
The preceding example (4) is a universal theorem, in the sense that its
statement has no existential quantiﬁer. Another class of examples comes
from existential theorems. From linear algebra, a natural example about
n × n matrices is
∀A∃B = 0(AB = I ∨ AB = 0).

(5)

The complexity of ﬁnding B for a given A, even over GF(2), is thought
not to be in NC 1 (it is hard for log space). Assuming that this is the case,
it follows that (5) is not a theorem of VNC 1 , since only NC 1 functions
are deﬁnable in that theory. This conclusion is the result of a general
witnessing theorem, which states that if the formula ∀x∃yϕ(x, y) (for
suitable formulas ϕ) is provable in the theory associated with complexity
class C, then there is a Skolem function f(x) whose complexity is in C
and which satisﬁes ∀xϕ(x, f(x)).
The theory VNC 1 proves that (4) follows from (5). Both (4) and (5)
are theorems of the theory VP associated with polynomial time.
Another example of an existential theorem is “Fermat’s Little Theorem”, which states that if n is a prime number and 1 ≤ a < n, then
a n−1 ≡ 1 (mod n). Its existential content is captured by its contrapositive form
(1 ≤ a < n) ∧ (a n−1 ≡ 1 (mod n)) ⊃ ∃d (1 < d < n ∧ d |n).
n−1

(6)

It is not hard to see that the function a
mod n can be computed in
time polynomial in the lengths of a and n, using repeated squaring. If
(6) is provable in VP, then by the witnessing theorem mentioned above
it would follow that there is a polynomial time function f(a, n) whose
value d = f(a, n) provides a proper divisor of n whenever a, n satisfy
the hypothesis in (6). With the exception of the so-called Carmichael
numbers, which can be factored in polynomial time, every composite n
satisﬁes the hypothesis of (6) for at least half of the values of a, 1 ≤ a < n.
Hence f(a, n) would provide a probabilistic polynomial time algorithm
for integer factoring. Such an algorithm is not known to exist, and would
provide a method for breaking the RSA public-key encryption scheme.

4

I. Introduction

Thus Fermat’s Little Theorem is not provable in VP, assuming that
there is no probabilistic polynomial time factoring algorithm.
Propositional tautologies can be used to express universal theorems
such as (3) (in which the Predicate P is implicitly universally quantiﬁed
and the bounded number quantiﬁers can be expanded in translation) and
(4), but are not well suited to express existential theorems such as (5) and
(6). However the latter can be expressed using formulas in the quantiﬁed
propositional calculus (QPC), which extends the propositional calculus
by allowing quantiﬁers ∀p and ∃p over propositional variables p. Each
of the complexity classes in (2) has an associated QPC system, and in fact
the systems Gi  mentioned for PH form a hierarchy of QPC systems.
Most of the theories presented in this book, including those in (2),
have the same “second-order” underlying vocabulary L2A , introduced by
Zambella. The vocabulary L2A is actually a vocabulary for the two-sorted
ﬁrst-order predicate calculus, where one sort is for numbers in N and the
second sort is for ﬁnite sets of numbers. Here we regard an object of the
second sort as a ﬁnite string over the alphabet {0, 1} (the i-th bit in the
string is 1 iﬀ i is in the set). The strings are the objects of interest for
the complexity classes, and serve as the main inputs for the machines or
circuits that determine the class. The numbers serve a useful purpose as
indices for the strings when describing properties of the strings. When
they are used as machine or circuit inputs, they are presented in unary
notation.
In the more common single-sorted theories such as Buss’s hierarchies S2i
and T2i the underlying objects are numbers which are presented in binary
notation as inputs to Turing machines. Our two-sorted treatment has the
advantage that the underlying vocabulary has no primitive operations on
strings except the length function |X | and the bit predicate X (i) (meaning
i ∈ X ). This is especially important for studying weak complexity classes
such as AC 0 . The standard vocabulary for single-sorted theories includes
number multiplication, which is not an AC 0 function on binary strings.
Chapter II provides a suﬃcient background in ﬁrst-order logic for the
rest of the book, including Gentzen’s proof system LK. An unusual
feature is our treatment of anchored (or “free-cut-free”) LK-proofs. The
completeness of these restricted systems is proved directly by a simple
term-model construction as opposed to the usual syntactic cut-elimination
method. The second form of the Herbrand Theorem proved here has many
applications in later chapters for witnessing theorems.
Chapter III presents the necessary background on Peano Arithmetic
(the ﬁrst-order theory of N under + and ×) and its subsystems, including
the bounded theory IΔ0 . The functions deﬁnable in IΔ0 are precisely those
in the complexity class known as LTH (the Linear Time Hierarchy). An
important theorem needed for this result is that the predicate y = 2x
is deﬁnable in the vocabulary of arithmetic using a bounded formula

I. Introduction

5

(Section III.3.3). The universal theory IΔ0 has function symbols for each
function in the Linear Time Hierarchy, and forms a conservative extension
of IΔ0 . This theory serves as a prototype for universal theories deﬁned in
later chapters for other complexity classes.
Chapter IV introduces the syntax and intended semantics for the twosorted theories, which will be used throughout the remaining chapters.
Here ΣB0 is deﬁned to be the class of formulas with no string quantiﬁers,
and with all number quantiﬁers bounded. The ΣB1 -formulas begin with
zero or more bounded existential string quantiﬁers followed by a ΣB0 formula, and more generally ΣBi -formulas begin with at most i alternating
blocks of bounded string quantiﬁers ∃∀∃ . . . . Representation theorems
are proved which state that formulas in the syntactic class ΣB0 represent
precisely the (two-sorted) AC 0 relations, and for i ≥ 1, formulas in ΣBi
represent the relations in the i-th level of the polynomial hierarchy.
Chapter V introduces the hierarchy of two-sorted theories V 0 ⊂ V 1 ⊆
V 2 ⊆ · · · . For i ≥ 1, V i is the two-sorted version of Buss’s singlesorted theory S2i , which is associated with the ith level of the polynomial
hierarchy. In this chapter we concentrate on V 0 , which is associated with
the complexity class AC 0 . All two-sorted theories considered in later
chapters are extensions of V 0 . A Buss-style witnessing theorem is proved
for V 0 , showing that the existential string quantiﬁers in a ΣB1 -theorem of
V 0 can be witnessed by AC 0 -functions. Since ΣB1 -formulas have all string
quantiﬁers in front, both the statement and the proof of the theorem are
simpler than for the usual Buss-style witnessing theorems. (The same
applies to the witnessing theorems proved in later chapters.) The ﬁnal
section proves that V 0 is ﬁnitely axiomatizable.
Chapter VI concentrates on the theory V 1 , which is associated with the
complexity class P. All (and only) polynomial time functions are ΣB1 deﬁnable in V 1 . The positive direction is shown in two ways: by analyzing
Turing machine computations and by using Cobham’s characterization of
these functions. The witnessing theorem for V 1 is shown using (two-sorted
versions of) the anchored proofs described in Chapter II, and implies that
only polynomial time functions are ΣB1 -deﬁnable in V 1 .
Chapter VII gives a general deﬁnition of propositional proof system.
The goal is to associate a proof system with each theory so that each ΣB0 theorem of the theory translates into a polynomial size family of proofs
in the proof system. Further, the theory should prove the soundness
of the proof system, but this is not shown until Chapter X. In Chapter VII, translations are deﬁned from V 0 to bounded-depth PK-proofs
(i.e. bounded-depth Frege proofs), and also from V 1 to extended Frege
proofs. Systems Gi and Gi for the quantiﬁed propositional calculus are
deﬁned, and for i ≥ 1 we show how to translate bounded theorems of V i

6

I. Introduction

to polynomial size families of proofs in the system Gi . The two-sorted
treatment makes these translations simple and natural.
Chapter VIII begins by introducing other two-sorted theories associated with polynomial time. The ﬁnitely axiomatized theory VP and its
universal conservative extension VPV both appear to be weaker than V 1 ,
although they have the same ΣB1 theorems as V 1 . VP = TV 0 is the base
of the hierarchy of theories TV 0 ⊆ TV 1 ⊆ · · · , where for i ≥ 1, TV i
is isomorphic to Buss’s single-sorted theory T2i . The deﬁnable problems
in TV 1 have the complexity of Polynomial Local Search. A form of the
Herbrand Theorem known as KPT Witnessing is proved and applied to
show independence of the Replacement axiom scheme from some theories, and to relating the collapse of the V ∞ hierarchy with the provable
collapse of the polynomial hierarchy. The ΣBj -deﬁnable search problems in
V i and TV i are characterized for many i and j. The RSUV isomorphism
theorem between S2i and V i is proved.
See Table 3 on page 250 for a summary of which search problems are
deﬁnable in V i and TV i .
Chapter IX gives a uniform way of introducing minimal canonical theories for many complexity classes between AC 0 and P, including those
mentioned earlier in (1). Each ﬁnitely axiomatized theory is deﬁned as an
extension of V 0 obtained by adding a single axiom stating the existence of
a computation solving a complete problem for the associated complexity
class. Evidence for the “minimality” of each theory is presented by deﬁning a universal theory whose axioms are simply a set of basic axioms for
V 0 together with the deﬁning axioms for all the functions in the associated
complexity class. These functions are deﬁned as the function AC 0 -closure
of the complexity class, or (as is the case for P) using a recursion-theoretic
characterization of the function class. The main theorem in each case is
that the universal theory is a conservative extension of the ﬁnitely axiomatized theory.
Table 1 on page 7 gives a summary of the two-sorted theories presented
in Chapter IX and elsewhere, and Table 2 on page 8 gives a list of some
theorems provable (or possibly not provable) in the various theories.
Chapter X extends Chapter VII by presenting quantiﬁed propositional
proof systems associated with various complexity classes, and deﬁning
translations from the bounded theorems of the theories introduced in
Chapter IX to the appropriate proof system. Witnessing theorems for
subsystems of G (quantiﬁed propositional calculus) are proved. The
notion of reﬂection principle (soundness of a proof system) is deﬁned,
and many results showing which kinds of reﬂection principle for various
systems can (or probably cannot) be proved in various theories. It is
shown how reﬂection principles can be used to axiomatize some of the
theories.

7

I. Introduction
CLASS

THEORY

SEE

0

Section V.1

V

AC 0

V

0

Section V.6


0 (2), V 0 (2)
V 0 (2),V

AC 0 (2)

0

Section IX.4.2

VAC (2)V

Section IX.4.4

AC 0 (m)

0 (m), V 0 (m)
V 0 (m),V

Section IX.4.6

0

AC (6)

0

VAC (6)V

Section IX.4.8

ACC

VACC
0 , VTC 0
VTC 0 ,VTC

Section IX.4.6

TC 0

0

VTC V
1 , VNC 1
VNC , VNC
1

NC 1

1

L
NL

NC

k+1

VLV

VNL,VNL,VNL

Section IX.6.4

VNC

NC

P

CC(PLS)
Table 1.

Section IX.6.1
Section IX.6.2
Section IX.5.6

k+1

Section IX.5.6

VNC

Section IX.5.6

U1

Section IX.5.6

VP

Section VIII.1

VPV

Section VIII.2

0

Section VIII.3

TV
1

C (for C ⊆ P)

Section IX.6.3

k

VAC

(k ≥ 1)

Section IX.5.3
Section IX.5.5

V -KROM

AC (k ≥ 1)

Section IX.3.4

VNC V

VL,VL,VL

1

k

Section IX.3.2

V -HORN

Section VIII.4

1

Chapter VI

V
 VC
VC, VC,

Section VIII.5

2

Section VIII.7.2

TV
V

Section IX.2.1

1

Theories and their ΣB1 -deﬁnable classes.

8

I. Introduction
THEORY

(NON)THEOREM(?)
(seq.) Jordan Curve Theorem
V0
 PHP
 onto PHP,  Countm
onto PHP, Count2
0
V (2)
(set) Jordan Curve Theorem
PHP?, Count3 ?
Countm (if gcd(m, m  ) > 1)
V 0 (m)
Countm ? (if gcd(m, m ) = 1)
PHP?
sorting
Reﬂection Principles for d -PTK
PHP
VTC 0
Finite Szpilrajn’s Theorem
Bondy’s Theorem
deﬁne X/Y ?
Reﬂection Principle for PK
VNC 1
Barrington’s Theorem
NUMONES
Lind’s characterization of L
VL
Reingold’s Theorem?
VNL
Grädel’s Theorem (for NL)
2
VNC
Cayley–Hamilton Theorem?
Reﬂection Principle for ePK
0
VP = TV
Grädel’s Theorem (for P)
 Fermat’s Little Theorem (cond.)
V1
Prime Factorization Theorem
q
q
i
V (i ≥ 1)
Πi -RFN Gi−1 , Πi+2 -RFN Gi
q
q
i
 , Π
TV (i ≥ 0)
Πi+2 -RFN Gi+1
i+1 -RFN Gi

SEE
[84]
Corollary VII.2.4
Section IX.4.3
Section IX.4.3
Section IX.4.5
Section IX.7.4
Section IX.4.7
Section IX.7.4
Section IX.7.4
Exercise IX.3.9
Section X.4.2
Section IX.3.5
Section IX.3.7
Section IX.3.8
Section IX.7.3
Theorem X.3.9
Sec. IX.5.5 & [82]
Section IX.5.4
Section IX.6.4
Section IX.7.2
Theorem IX.6.24
Section IX.7.1
Exercise X.2.22
Theorem VIII.4.8
page 3
Exercise VI.4.4
Theorem X.2.17
Theorem X.2.20

Table 2. Some theories and their (non)theorems/solvable problems (and open questions). (“cond.” stands
for conditional.) Many theorems of VP, such as Kuratowski’s Theorem, Hall’s Theorem, Menger’s Theorem
are not discussed here.

Chapter II

THE PREDICATE CALCULUS AND THE SYSTEM LK

In this chapter we present the logical foundations for theories of bounded
arithmetic. We introduce Gentzen’s proof system LK for the predicate
calculus, and prove that it is sound, and complete even when proofs
have a restricted form called “anchored”. We augment the system LK
by adding equality axioms. We prove the Compactness Theorem for
predicate calculus, and the Herbrand Theorem.
In general we distinguish between syntactic notions and semantic notions. Examples of syntactic notions are variables, connectives, formulas,
and formal proofs. The semantic notions relate to meaning; for example
truth assignments, structures, validity, and logical consequence.
The ﬁrst section treats the simple case of propositional calculus.

II.1. Propositional Calculus
Propositional formulas (called simply formulas in this section) are built
from the logical constants ⊥,  (for False, True), propositional variables
(or atoms) P1 , P2 , . . . , connectives ¬, ∨, ∧, and parentheses (, ). We use
P, Q, R, . . . to stand for propositional variables, A, B, C, . . . to stand for
formulas, and Φ, Ψ, . . . to stand for sets of formulas. When writing
formulas such as (P ∨ (Q ∧ R)), our convention is that P, Q, R, . . . stand
for distinct variables.
Formulas are built according to the following rules:
• ⊥, , P, are formulas (also called atomic formulas) for any variable P.
• If A and B are formulas, then so are (A ∨ B), (A ∧ B), and ¬A.
The implication connective ⊃ is not allowed in our formulas, but we
will take (A ⊃ B) to stand for (¬A ∨ B). Also (A ↔ B) stands for
((A ⊃ B) ∧ (B ⊃ A)).
We sometimes abbreviate formulas by omitting parentheses, but the
intended formula has all parentheses present as deﬁned above.
A truth assignment is an assignment of truth values F, T to atoms.
Given a truth assignment , the truth value A of a formula A is deﬁned
9

10

II. The Predicate Calculus and the System LK

inductively as follows: ⊥ = F ,  = T , P  = (P) for atom P, (A ∧
B) = T iﬀ both A = T and B  = T , (A ∨ B) = T iﬀ either A = T or
B  = T , (¬A) = T iﬀ A = F .
Deﬁnition II.1.1. A truth assignment  satisﬁes A iﬀ A = T ;  satisﬁes a set Φ of formulas iﬀ  satisﬁes A for all A ∈ Φ. Φ is satisﬁable iﬀ
some  satisﬁes Φ; otherwise Φ is unsatisﬁable. Similarly for A. Φ |= A
(i.e., A is a logical consequence of Φ) iﬀ  satisﬁes A for every  such that
 satisﬁes Φ. A formula A is valid iﬀ |= A (i.e., A = T for all ). A
valid propositional formula is called a tautology. We say that A and B are
equivalent (written A ⇐⇒ B) iﬀ A |= B and B |= A.
Note that ⇐⇒ refers to semantic equivalence, as opposed to =syn , which
indicates syntactic equivalence. For example, (P ∨ Q) ⇐⇒ (Q ∨ P), but
(P ∨ Q) =syn (Q ∨ P).
II.1.1. Gentzen’s Propositional Proof System PK. We present the propositional part PK of Gentzen’s sequent-based proof system LK. Each
line in a proof in the system PK is a sequent of the form
A1 , . . . , Ak −→ B1 , . . . , B

(7)

where −→ is a new symbol and A1 , . . . , Ak and B1 , . . . , B are sequences
of formulas (k,  ≥ 0) called cedents. We call the cedent A1 , . . . , Ak the
antecedent and B1 , . . . , B the succedent (or consequent).
The semantics of sequents is given as follows. We say that a truth
assignment  satisﬁes the sequent (7) iﬀ either  falsiﬁes some Ai or 
satisﬁes some Bi . Thus the sequent is equivalent to the formula
¬A1 ∨ ¬A2 ∨ · · · ∨ ¬Ak ∨ B1 ∨ B2 ∨ · · · ∨ B .

(8)

(Here and elsewhere, a disjunction C1 ∨· · ·∨Cn indicates parentheses have
been inserted with association to the right. For example, C1 ∨C2 ∨C3 ∨C4
stands for (C1 ∨(C2 ∨(C3 ∨C4 ))). Similarly for a disjunction C1 ∧· · ·∧Cn .)
In other words, the conjunction of the A’s implies the disjunction of the
B’s. In the cases in which the antecedent or succedent is empty, we see that
the sequent −→ A is equivalent to the formula A, and A −→ is equivalent
to ¬A, and just −→ (with both antecedent and succedent empty) is false
(unsatisﬁable). We say that a sequent is valid if it is true under all truth
assignments (which is the same as saying that its corresponding formula
is a tautology).
Deﬁnition II.1.2. A PK proof of a sequent S is a ﬁnite tree whose
nodes are (labeled with) sequents, whose root (called the endsequent) is S
and is written at the bottom, whose leaves (or initial sequents) are logical
axioms (see below), such that each non-leaf sequent follows from the
sequent(s) immediately above by one of the rules of inference given below.

11

II.1. Propositional Calculus
The logical axioms are of the form
A −→ A,

⊥ −→,

−→ 

where A is any formula. (Note that we diﬀer here from most other
treatments, which require that A be an atomic formula.) The rules of
inference are as follows (here Γ and Δ denote ﬁnite sequences of formulas).
weakening rules
left:

Γ −→ Δ

right:

A, Γ −→ Δ

Γ −→ Δ
Γ −→ Δ, A

exchange rules
left:

Γ1 , A, B, Γ2 −→ Δ

Γ1 , B, A, Γ2 −→ Δ
contraction rules
Γ, A, A −→ Δ
left:
Γ, A −→ Δ
¬ introduction rules
Γ −→ Δ, A
left:
¬A, Γ −→ Δ
∧ introduction rules
A, B, Γ −→ Δ
left:
(A ∧ B), Γ −→ Δ

right:

right:

right:

right:

∨ introduction rules
A, Γ −→ Δ
B, Γ −→ Δ
left:
(A ∨ B), Γ −→ Δ
cut rule
Γ −→ Δ, A

Γ −→ Δ1 , A, B, Δ2
Γ −→ Δ1 , B, A, Δ2
Γ −→ Δ, A, A
Γ −→ Δ, A
A, Γ −→ Δ
Γ −→ Δ, ¬A

Γ −→ Δ, A

Γ −→ Δ, B

Γ −→ Δ, (A ∧ B)

right:

Γ −→ Δ, A, B
Γ −→ Δ, (A ∨ B)

A, Γ −→ Δ

Γ −→ Δ
The formula A in the cut rule is called the cut formula. A proof that
does not use the cut rule is called cut-free. The new formulas in the
bottom sequents of the introduction rules are called principal formulas and
the formula(s) in the top sequent(s) that are used to form the principal
formulas are called auxiliary formulas.
Note that there is one left introduction rule and one right introduction
rule for each of the three logical connectives ∧, ∨, ¬. Further, these rules
seem to be the simplest possible, given the fact that in each case the bottom
sequent is valid iﬀ all top sequents are valid.
Note that repeated use of the exchange rules allows us to execute an
arbitrary reordering of the formulas in the antecedent or succedent of a
sequent. In presenting a proof in the system PK, we will usually omit

12

II. The Predicate Calculus and the System LK

mention of the steps requiring the exchange rules, but of course they are
there implicitly.
Deﬁnition II.1.3. A PK proof of a formula A is a PK proof of the
sequent −→ A.
As an example, we give a PK proof of one of De Morgan’s laws:
¬(P ∧ Q) −→ ¬P ∨ ¬Q.
To ﬁnd this (or any) proof, it is a good idea to start with the conclusion
at the bottom, and work up by removing the connectives one at a time,
outermost ﬁrst, by using the introduction rules in reverse. This can be
continued until some formula A occurs on both the left and right side of
a sequent, or  occurs on the right, or ⊥ occurs on the left. Then this
sequent can be derived from one of the axioms A −→ A or −→  or
⊥ −→ using weakenings and exchanges. The cut and contraction rules
are not necessary, and weakenings are only needed immediately below
axioms. (The cut rule can be used to shorten proofs, and contraction will
be needed later for the predicate calculus.)
P −→ P

(weakening)

P −→ P, ¬Q
−→ P, ¬P, ¬Q

(¬ right)

Q −→ Q
Q −→ Q, ¬P
−→ Q, ¬P, ¬Q

−→ P ∧ Q, ¬P, ¬Q
−→ P ∧ Q, ¬P ∨ ¬Q

(weakening)
(¬ right)
(∧ right)

(∨ right)

¬(P ∧ Q) −→ ¬P ∨ ¬Q

(¬ left)

Exercise II.1.4. Give PK proofs for each of the following valid sequents:
(a) ¬P ∨ ¬Q −→ ¬(P ∧ Q).
(b) ¬(P ∨ Q) −→ ¬P ∧ ¬Q.
(c) ¬P ∧ ¬Q −→ ¬(P ∨ Q).
Exercise II.1.5. Show that the contraction rules can be derived from
the cut rule (with weakenings and exchanges).
Exercise II.1.6. Suppose that we allowed ⊃ as a primitive connective,
rather than one introduced by deﬁnition. Give the appropriate left and
right introduction rules for ⊃.
II.1.2. Soundness and Completeness of PK. Now we prove that PK is
both sound and complete. That is, a propositional sequent is provable in
PK iﬀ it is valid.

II.1. Propositional Calculus

13

Theorem II.1.7 (Soundness). Every sequent provable in PK is valid.
Proof. We show that the endsequent in every PK proof is valid, by
induction on the number of sequents in the proof. For the base case, the
proof is a single line: a logical axiom. Each logical axiom is obviously
valid. For the induction step, one needs only verify for each rule that the
bottom sequent is a logical consequence of the top sequent(s).
2
Theorem II.1.8 (Completeness). Every valid propositional sequent is
provable in PK without using cut or contraction.
Proof. The idea is discussed in the example proof above of De Morgan’s
laws. We need to use the inversion principle.
Lemma II.1.9 (Inversion Principle). For each PK rule except for weakenings, if the bottom sequent is valid, then all top sequents are valid.
This principle is easily veriﬁed by inspecting each of the eleven rules in
question.
Now for the completeness theorem: We show that every valid sequent
Γ −→ Δ has a PK proof, by induction on the total number of logical
connectives ∧, ∨, ¬ occurring in Γ −→ Δ. For the base case, every formula
in Γ and Δ is an atom or one of the constants ⊥, , and since the sequent
is valid, some atom P must occur in both Γ and Δ, or ⊥ occurs in Γ or 
occurs in Δ. Hence Γ −→ Δ can be derived from one of the logical axioms
by weakenings and exchanges.
For the induction step, let A be any formula which is not an atom and
not a constant in Γ or Δ. Then by the deﬁnition of propositional formula
A must have one of the forms (B ∧ C ), (B ∨ C ), or ¬B. Thus Γ −→ Δ can
be derived from ∧ introduction, ∨ introduction, or ¬ introduction, respectively, using either the left case or the right case, depending on whether A
is in Γ or Δ, and also using exchanges, but no weakenings. In each case,
each top sequent of the rule will have at least one fewer connective than
Γ −→ Δ, and the sequent is valid by the inversion principle. Hence each
top sequent has a PK proof, by the induction hypothesis.
2
The soundness and completeness theorems relate the semantic notion
of validity to the syntactic notion of proof.
II.1.3. PK Proofs from Assumptions. We generalize the (semantic) definition of logical consequence from formulas to sequents in the obvious
way: A sequent S is a logical consequence of a set Φ of sequents iﬀ every
truth assignment  that satisﬁes Φ also satisﬁes S. We generalize the (syntactic) deﬁnition of a PK proof of a sequent S to a PK proof of S from
a set Φ of sequents (also called a PK-Φ proof) by allowing sequents in Φ
to be leaves (called nonlogical axioms) in the proof tree, in addition to the
logical axioms. It turns out that soundness and completeness generalize
to this setting.

14

II. The Predicate Calculus and the System LK

Theorem II.1.10 (Derivational Soundness and Completeness). A propositional sequent S is a logical consequence of a set Φ of sequents iﬀ
S has a PK-Φ proof.
Derivational soundness is proved in the same way as simple soundness:
by induction on the number of sequents in the PK-Φ proof, using the fact
that the bottom sequent of each rule is a logical consequence of the top
sequent(s).
A remarkable aspect of derivational completeness is that a ﬁnite proof
exists even in case Φ is an inﬁnite set. This is because of the compactness
theorem (below) which implies that if S is a logical consequence of Φ,
then S is a logical consequence of some ﬁnite subset of Φ.
In general, to prove S from Φ the cut rule is required. For example,
there is no PK proof of −→ P from −→ P ∧ Q without using the cut
rule. This follows from the subformula property, which states that in a
cut-free proof  of a sequent S, every formula in every sequent of  is a
subformula of some formula in S. This is stated more generally in the
Proposition II.1.15.
Exercise II.1.11. Let AS be the formula giving the meaning of a sequent
S, as in (8). Show that there is a cut-free PK derivation of −→ AS from S.
Proof of Theorem II.1.10 (Completeness). From the above easy exercise and from the earlier Completeness Theorem and from Theorem
II.1.16, Form 2 (compactness), we obtain an easy proof of derivational
completeness. Suppose that the sequent Γ −→ Δ is a logical consequence
of sequents S1 , . . . , Sk . Then by the above exercise we can derive each of
the sequents −→ AS1 , . . . ,−→ ASk from the sequents S1 , . . . , Sk . Also the
sequent
AS1 , . . . , ASk , Γ −→ Δ

(9)

is valid, and hence has a PK proof by Theorem II.1.8. Finally from (9)
using successive cuts with cut formulas AS1 , . . . , ASk we obtain the desired
PK derivation of Γ −→ Δ from the the sequents S1 , . . . , Sk .
2
We now wish to show that the cut formulas in the derivation can be
restricted to formulas occurring in the hypothesis sequents.
Deﬁnition II.1.12 (Anchored Proof). An instance of the cut rule in a
PK-Φ proof  is anchored if the cut formula A (also) occurs as a formula
(rather than a subformula) in some nonlogical axiom of . A PK-Φ proof
 is anchored if every instance of cut in  is anchored.
Our anchored proofs are similar to free-cut-free proofs in [72] and elsewhere. Our use of the term anchored is inspired by [27].
The derivational completeness theorem can be strengthened as follows.

II.1. Propositional Calculus

15

Theorem II.1.13 (Anchored Completeness). If a propositional sequent
S is a logical consequence of a set Φ of sequents, then there is an anchored
PK-Φ proof of S.
We illustrate the proof of the anchored completeness theorem by proving the special case in which Φ consists of the single sequent A −→ B.
Assume that the sequent Γ −→ Δ is a logical consequence of A −→ B.
Then both of the sequents Γ −→ Δ, A and B, A, Γ −→ Δ are valid (why?).
Hence by Theorem II.1.8 they have PK proofs 1 and 2 , respectively. We
can use these proofs to get a proof of Γ −→ Δ from A −→ B as shown
below, where the double line indicates the rules weakening and exchange
have been applied.
·
A −→ B
· 2
===========
·
·
B, A, Γ −→ Δ
A, Γ −→ Δ, B
· 1
·
(cut)
Γ −→ Δ, A
A, Γ −→ Δ
(cut)
Γ −→ Δ
Next consider the case in which Φ has the form
{−→ A1 , −→ A2 , . . . , −→ Ak }
for some set {A1 , . . . , Ak } of formulas. Assume that Γ −→ Δ is a logical
consequence of Φ in this case. Then the sequent
A1 , A2 , . . . , Ak , Γ −→ Δ
is valid, and hence has a PK proof . Now we can use the assumptions
Φ and the cut rule to successively remove A1 , A2 , . . . , Ak from the above
sequent to conclude Γ −→ Δ. For example, A1 is removed as follows (the
double line represents applications of the rule weakening and exchange):
·
−→ A1
·
·
==================
A2 , . . . , Ak , Γ −→ Δ, A1 A1 , A2 , . . . , Ak , Γ −→ Δ
(cut)
A2 , . . . , Ak , Γ −→ Δ
Exercise II.1.14. Prove the anchored completeness theorem for the
more general case in which Φ is any ﬁnite set of sequents. Use induction on the number of sequents in Φ.
A nice property of anchored proofs is the following.
Proposition II.1.15 (Subformula Property). If  is an anchored PK-Φ
proof of S, then every formula in every sequent of  is a subformula of a
formula either in S or in some nonlogical axiom of .
Proof. This follows by induction on the number of sequents in , using
the fact that for every rule other than cut, every formula on the top is a
subformula of some formula on the bottom. For the case of cut we use
the fact that every cut formula is a formula in some nonlogical axiom
of .
2

16

II. The Predicate Calculus and the System LK

The Subformula Property can be generalized in a way that applies to cutfree LK proofs in the predicate calculus, and this will play an important
role later in proving witnessing theorems.
II.1.4. Propositional Compactness. We conclude our treatment of the
propositional calculus with a fundamental result which also plays an important role in the predicate calculus.
Theorem II.1.16 (Propositional Compactness). We state three diﬀerent forms of this result. All three are equivalent.
Form 1: If Φ is an unsatisﬁable set of propositional formulas, then some
ﬁnite subset of Φ is unsatisﬁable.
Form 2: If a formula A is a logical consequence of a set Φ of formulas, then
A is a logical consequence of some ﬁnite subset of Φ.
Form 3: If every ﬁnite subset of a set Φ of formulas is satisﬁable, then Φ is
satisﬁable.
Exercise II.1.17. Prove the equivalence of the three forms. (Note that
Form 3 is the contrapositive of Form 1.)
Proof of Form 1. Let Φ be an unsatisﬁable set of formulas. By our
deﬁnition of propositional formula, all propositional variables in Φ come
from a countable list P1 , P2 , . . . . (See Exercise II.1.19 for the uncountable
case.) Organize the set of truth assignments into an inﬁnite rooted binary
tree B. Each node except the root is labeled with a literal Pi or ¬Pi .
The two children of the root are labeled P1 and ¬P1 , indicating that P1 is
assigned T or F , respectively. The two children of each of these nodes are
labeled P2 and ¬P2 , respectively, indicating the truth value of P2 . Thus
each inﬁnite branch in the tree represents a complete truth assignment,
and each path from the root to a node represents a truth assignment to
the atoms P1 , . . . , Pi , for some i.
Now for every node in the tree B, prune the tree at (i.e., remove
the subtree rooted at , keeping itself) if the partial truth assignment
 represented by the path to falsiﬁes some formula A in Φ, where all
atoms in A get values from  . Let B  be the resulting pruned tree. Since
Φ is unsatisﬁable, every path from the root in B  must end after ﬁnitely
many steps in some leaf labeled with a formula A in Φ. It follows from
König’s Lemma below that B  is ﬁnite. Let Φ be the ﬁnite subset of Φ
consisting of all formulas A labeling the leaves of B  . Since every truth
assignment  determines a path in B  which ends in a leaf A falsiﬁed by
2
, it follows that Φ is unsatisﬁable.
Lemma II.1.18 (König’s Lemma). Suppose T is a rooted tree in which
every node has only ﬁnitely many children. If every branch in T is ﬁnite,
then T is ﬁnite.
Proof. We prove the contrapositive: If T is inﬁnite (but every node has
only ﬁnitely many children) then T has an inﬁnite branch. We can deﬁne

II.2. Predicate Calculus

17

an inﬁnite path in T as follows: Start at the root. Since T is inﬁnite but
the root has only ﬁnitely many children, the subtree rooted at one of these
children must be inﬁnite. Choose such a child as the second node in the
branch, and continue.
2
Exercise II.1.19. (For those with some knowledge of set theory or point
set topology) The above proof of the propositional compactness theorem
only works when the set of atoms is countable, but the result still holds
even when Φ is an uncountable set with an uncountable set A of atoms.
Complete each of the two proof outlines below.
(a) Prove Form 3 using Zorn’s Lemma as follows: Call a set Ψ of
formulas ﬁnitely satisﬁable if every ﬁnite subset of Ψ is satisﬁable. Assume
that Φ is ﬁnitely satisﬁable. Let C be the class of all ﬁnitely satisﬁable sets
Ψ ⊇ Φ of propositional formulas using atoms in Φ. Order these sets Ψ
by inclusion. Show that the union of any chain of sets in C is again in the
class C. Hence by Zorn’s Lemma, C has a maximal element Ψ0 . Show
that Ψ0 has a unique satisfying assignment, and hence Φ is satisﬁable.
(b) Show that Form 1 follows from Tychonoﬀ’s Theorem: The product
of compact topological spaces is compact. The set of all truth assignments
to the atom set A can be given the product topology, when viewed as the
product for all atoms P in A of the two-point space {T, F } of assignments
to P, with the discrete topology. By Tychonoﬀ’s Theorem, this space
of assignments is compact. Show that for each formula A, the set of
assignments falsifying A is open. Thus Form 1 follows from the deﬁnition
of compact: every open cover has a ﬁnite subcover.

II.2. Predicate Calculus
In this section we present the syntax and semantics of the predicate calculus (also called ﬁrst-order logic). We show how to generalize Gentzen’s
proof system PK for the propositional calculus to the system LK for the
predicate calculus, by adding quantiﬁer introduction rules. We show that
LK is sound and complete. We prove an anchored completeness theorem
which limits the need for the cut rule in the presence of nonlogical axioms.
II.2.1. Syntax of the Predicate Calculus. A ﬁrst-order vocabulary (or
just vocabulary, or language) L is speciﬁed by the following:
1) For each n ≥ 0 a set of n-ary function symbols (possibly empty). We
use f, g, h, . . . as meta-symbols for function symbols. A zero-ary
function symbol is called a constant symbol.
2) For each n ≥ 0, a set of n-ary predicate symbols (which must be
nonempty for some n). We use P, Q, R, . . . as meta-symbols for
predicate symbols. A zero-ary predicate symbol is the same as a
propositional atom.

18

II. The Predicate Calculus and the System LK

In addition, the following symbols are available to build ﬁrst-order terms
and formulas:
1) An inﬁnite set of variables. We use x, y, z, . . . and sometimes
a, b, c, . . . as meta-symbols for variables.
2) Connectives ¬, ∧, ∨ (not, and, or); logical constants ⊥,  (for False,
True).
3) Quantiﬁers ∀, ∃ (for all, there exists).
4) (, ) (parentheses).
Given a vocabulary L, L-terms are certain strings built from variables
and function symbols of L, and are intended to represent objects in the
universe of discourse. We will drop mention of L when it is not important,
or clear from context.
Deﬁnition II.2.1 (L-Terms). Let L be a ﬁrst-order vocabulary.
1) Every variable is an L-term.
2) If f is an n-ary function symbol of L and t1 , . . . , tn are L-terms,
then ft1 . . . tn is an L-term.
Recall that a 0-ary function symbol is called a constant symbol (or
sometimes just a constant). Note that all constants in L are L-terms.
Deﬁnition II.2.2 (L-Formulas). Let L be a ﬁrst-order vocabulary.
First-order formulas in L (or L-formulas, or just formulas) are deﬁned
inductively as follows:
1) Pt1 · · · tn is an atomic L-formula, where P is an n-ary predicate
symbol in L and t1 , . . . , tn are L-terms. Also each of the logical
constants ⊥,  is an atomic formula.
2) If A and B are L-formulas, so are ¬A, (A ∧ B), and (A ∨ B).
3) If A is an L-formula and x is a variable, then ∀xA and ∃xA are
L-formulas.
Examples of formulas: (¬∀xPx ∨ ∃x¬Px), (∀x¬Pxy ∧ ¬∀zPfyz).
As in the case of propositional formulas, we use the notation (A ⊃ B)
for (¬A ∨ B) and (A ↔ B) for ((A ⊃ B) ∧ (B ⊃ A)).
It can be shown that no proper initial segment of a term is a term, and
hence every term can be parsed uniquely according to Deﬁnition II.2.1.
A similar remark applies to formulas, and Deﬁnition II.2.2.
Notation. r = s stands for = rs, and r = s stands for ¬(r = s).
Deﬁnition II.2.3 (The Vocabulary of Arithmetic).
LA = [0, 1, +, · ; =, ≤].
Here 0, 1 are constants; +, · are binary function symbols; =, ≤ are
binary predicate symbols. In practice we use inﬁx notation for +, ·, =, ≤.
Thus, for example, (t1 · t2 ) =syn ·t1 t2 and (t1 + t2 ) =syn +t1 t2 .

II.2. Predicate Calculus

19

Deﬁnition II.2.4 (Free and Bound Variables). An occurrence of x in
A is bound iﬀ it is in a subformula of A of the form ∀xB or ∃xB. Otherwise
the occurrence is free.
Notice that a variable can have both free and bound occurrences in one
formula. For example, in Px ∧ ∀xQx, the ﬁrst occurrence of x is free, and
the second occurrence is bound.
Deﬁnition II.2.5. A formula is closed if it contains no free occurrence
of a variable. A term is closed if it contains no variable. A closed formula
is called a sentence.
II.2.2. Semantics of Predicate Calculus.
Deﬁnition II.2.6 (L-Structure). If L is a ﬁrst-order vocabulary, then
an L-structure M consists of the following:
1) A nonempty set M called the universe. (Variables in an L-formula
are intended to range over M .)
2) For each n-ary function symbol f in L, an associated function
fM : M n → M .
3) For each n-ary predicate symbol P in L, an associated relation
P M ⊆ M n . If L contains =, then =M must be the true equality
relation on M .
Notice that the predicate symbol = gets special treatment in the above
deﬁnition, in that =M must always be the true equality relation. Any
other predicate symbol may be interpreted by an arbitrary relation of the
appropriate arity.
Every L-sentence becomes either true or false when interpreted by an
L-structure M, as explained below. If a sentence A becomes true under
M, then we say M satisﬁes A, or M is a model for A, and write M |= A.
If A has free variables, then these variables must be interpreted as
speciﬁc elements in the universe M before A gets a truth value under the
structure M. For this we need the following:
Deﬁnition II.2.7 (Object Assignment). An object assignment
structure M is a mapping from variables to the universe M .

for a

Below we give the formal deﬁnition of notion M |= A[ ], which is
intended to mean that the structure M satisﬁes the formula A when the
free variables of A are interpreted according to the object assignment .
First it is necessary to deﬁne the notation t M [ ], which is the element of
universe M assigned to the term t by the structure M when the variables
of t are interpreted according to .
Notation. If x is a variable and m ∈ M , then the object assignment
(m/x) is the same as except it maps x to m.

20

II. The Predicate Calculus and the System LK

Deﬁnition II.2.8 (Basic Semantic Deﬁnition). Let L be a ﬁrst-order
vocabulary, let M be an L-structure, and let be an object assignment
for M. Each L-term t is assigned an element t M [ ] in M , deﬁned by
structural induction on terms t, as follows (refer to the deﬁnition of Lterm):
(a) x M [ ] is (x), for each variable x.
(b) (ft1 · · · tn )M [ ] = f M (t1M [ ], . . . , tnM [ ]).
For A an L-formula, the notion M |= A[ ] (M satisﬁes A under ) is
deﬁned by structural induction on formulas A as follows (refer to the
deﬁnition of formula):
(a) M |=  and M |= ⊥.
(b) M |= (Pt1 · · · tn )[ ] iﬀ t1M [ ], . . . , tnM [ ] ∈ P M .
(c) If L contains =, then M |= (s = t)[ ] iﬀ s M [ ] = t M [ ].
(d) M |= ¬A[ ] iﬀ M |= A[ ].
(e) M |= (A ∨ B)[ ] iﬀ M |= A[ ] or M |= B[ ].
(f) M |= (A ∧ B)[ ] iﬀ M |= A[ ] and M |= B[ ].
(g) M |= (∀xA)[ ] iﬀ M |= A[ (m/x)] for all m ∈ M .
(h) M |= (∃xA)[ ] iﬀ M |= A[ (m/x)] for some m ∈ M .
Note that item (c) in the deﬁnition of M |= A[ ] follows from (b) and
the fact that =M is always the equality relation.
If t is a closed term (i.e., contains no variables), then t M [ ] is independent of , and so we sometimes just write t M . Similarly, if A is a sentence,
then we sometimes write M |= A instead of M |= A[ ], since does not
matter.
Deﬁnition II.2.9 (Standard Model). The standard model N for the vocabulary LA is a structure with universe M = N = {0, 1, 2, . . . }, where
0, 1, +, ·, =, ≤ get their usual meanings on the natural numbers.
As an example, N |= ∀x∀y∃z(x + z = y ∨ y + z = x) (since either
y − x or x − y exists) but N |= ∀x∃y(y + y = x) since not all natural
numbers are even.
In the future we sometimes assume that there is some ﬁrst-order vocabulary L in the background, and do not necessarily mention it explicitly.
Notation. In general, Φ denotes a set of formulas, A, B, C, . . . denote
formulas, M denotes a structure, and denotes an object assignment.
Deﬁnition II.2.10. (a) M |= Φ[ ] iﬀ M |= A[ ] for all A ∈ Φ.
(b) M |= Φ iﬀ M |= Φ[ ] for all .
(c) Φ |= A iﬀ for all M and all , if M |= Φ[ ] then M |= A[ ].
(d) |= A (A is valid) iﬀ M |= A[ ] for all M and .
(e) A ⇐⇒ B (A and B are logically equivalent, or just equivalent) iﬀ for
all M and all , M |= A[ ] iﬀ M |= B[ ].

II.2. Predicate Calculus

21

Φ |= A is read “A is a logical consequence of Φ”. Do not confuse this
with our other use of the symbol |=, as in M |= A (M satisﬁes A). In the
latter, M is a structure, rather than a set of formulas.
If Φ consists of a single formula B, then we write B |= A instead of
{B} |= A.
Deﬁnition II.2.11 (Substitution). Let s, t be terms, and A a formula.
Then t(s/x) is the result of replacing all occurrences of x in t by s, and
A(s/x) is the result of replacing all free occurrences of x in A by s.
Lemma II.2.12. For each structure M and each object assignment ,
(s(t/x))M [ ] = s M [ (m/x)]
where m = t M [ ].
Proof. Structural induction on s.

2

Deﬁnition II.2.13. A term t is freely substitutable for x in A iﬀ no free
occurrence of x in A is in a subformula of A of the form ∀yB or ∃yB,
where y occurs in t.
Theorem II.2.14 (Substitution). If t is freely substitutable for x in A
then for all structures M and all object assignments , M |= A(t/x)[ ] iﬀ
M |= A[ (m/x)], where m = t M [ ].
Proof. Structural induction on A.
2
Remark (Change of Bound Variable). If t is not freely substitutable
for x in A, it is because some variable y in t gets “caught” by a quantiﬁer,
say ∃yB. Then replace ∃yB in A by ∃zB, where z is a new variable. Then
the meaning of A does not change (by the Formula Replacement Theorem
below), but by repeatedly changing bound variables in this way t becomes
freely substitutable for x in A.
Theorem II.2.15 (Formula Replacement). If B and B  are equivalent
and A results from A by replacing some occurrence of B in A by B  , then A
and A are equivalent.
Proof. Structural induction on A relative to B.
2
II.2.3. The First-Order Proof System LK. We now extend the propositional proof system PK to the ﬁrst-order sequent proof system LK.
For this it is convenient to introduce two kinds of variables: free variables denoted by a, b, c, . . . and bound variables denoted by x, y, z, . . . . A
ﬁrst-order sequent has the form
A1 , . . . , Ak −→ B1 , . . . , B
where now the Ai and Bj are ﬁrst-order formulas satisfying the restriction
that they have no free occurrences of the “bound” variables x, y, z, . . . and
no bound occurrences of the “free” variables a, b, c, . . . .

22

II. The Predicate Calculus and the System LK

The sequent system LK is an extension of the propositional system PK,
where now all formulas are ﬁrst-order formulas satisfying the restriction
explained above.
In addition to the rules given for PK, the system LK has four rules for
introducing the quantiﬁers.
Important Remark. In the rules below, t is any term not involving any
bound variables x, y, z, . . . and A(t) is the result of substituting t for all
free occurrences of x in A(x). Similarly A(b) is the result of substituting
b for all free occurrences of x in A(x). Note that t and b can always
be freely substituted for x in A(x) when ∀xA(x) or ∃xA(x) satisfy the
free/bound variable restrictions described above.
∀ introduction rules
A(t), Γ −→ Δ
left:
∀xA(x), Γ −→ Δ
∃ introduction rules
A(b), Γ −→ Δ
left:
∃xA(x), Γ −→ Δ

right:

right:

Γ −→ Δ, A(b)
Γ −→ Δ, ∀xA(x)
Γ −→ Δ, A(t)
Γ −→ Δ, ∃xA(x)

Restriction. The free variable b is called an eigenvariable and must not
occur in the conclusion in ∀-right or ∃-left. Also, as remarked above, the
term t must not involve any bound variables x, y, z, . . . .
The new formulas in the bottom sequents (∃xA(x) or ∀xA(x)) are
called principal formulas, and the corresponding formulas in the top sequents (A(b) or A(t)) are called auxiliary formulas.
Deﬁnition II.2.16 (Semantics of ﬁrst-order sequents). The semantics
of ﬁrst-order sequents is a natural generalization of the semantics of
propositional sequents. Again the sequent A1 , . . . , Ak −→ B1 , . . . , B
has the same meaning as its associated formula
¬A1 ∨ ¬A2 ∨ · · · ∨ ¬Ak ∨ B1 ∨ B2 ∨ · · · ∨ B .
In particular, we say that the sequent is valid iﬀ its associated formula is
valid.
Theorem II.2.17 (Soundness for LK). Every sequent provable in LK is
valid.
Proof. This is proved by induction on the number of sequents in the
LK proof, as in the case of PK. However, unlike the case of PK, not
all of the four new quantiﬁer rules satisfy the condition that the bottom
sequent is a logical consequence of the top sequent. In particular this may
be false for ∀-right and for ∃-left. However it is easy to check that each
rule satisﬁes the weaker condition that if the top sequent is valid, then the
bottom sequent is valid, and this suﬃces for the proof.
2

II.2. Predicate Calculus

23

Exercise II.2.18. Give examples to show that the restriction given on
the quantiﬁer rules, that b must not occur in the conclusion in ∀-right and
∃-left, is necessary to ensure that these rules preserve validity.
Example of an LK proof. An LK proof of a valid ﬁrst-order sequent can
be obtained using the same method as in the propositional case: Write the
goal sequent at the bottom, and move up by using the introduction rules
in reverse. A good heuristic is: if there is a choice about which quantiﬁer
to remove next, choose ∀-right and ∃-left ﬁrst (working backward), since
these rules carry a restriction.
Here is an LK proof of the sequent ∀xPx ∨ ∀xQx −→ ∀x(Px ∨ Qx).
Pb −→ Pb
Qb −→ Qb
(weakening)
(weakening)
Pb −→ Pb, Qb
Qb −→ Pb, Qb
(∀ left)
(∀ left)
∀xPx −→ Pb, Qb
∀xQx −→ Pb, Qb
(∨ left)
∀xPx ∨ ∀xQx −→ Pb, Qb
(∨ right)
∀xPx ∨ ∀xQx −→ Pb ∨ Qb
(∀ right)
∀xPx ∨ ∀xQx −→ ∀x(Px ∨ Qx)
Exercise II.2.19. Give LK proofs for the following valid sequents:
(a) ∀xPx ∧ ∀xQx −→ ∀x(Px ∧ Qx).
(b) ∀x(Px ∧ Qx) −→ ∀xPx ∧ ∀xQx.
(c) ∃x(Px ∨ Qx) −→ ∃xPx ∨ ∃xQx.
(d) ∃xPx ∨ ∃xQx −→ ∃x(Px ∨ Qx).
(e) ∃x(Px ∧ Qx) −→ ∃xPx ∧ ∃xQx.
(f) ∃y∀xPxy −→ ∀x∃yPxy.
(g) ∀xPx −→ ∃xPx.
Check that the rule restrictions seem to prevent generating LK proofs for
the following invalid sequents:
(h) ∃xPx ∧ ∃xQx −→ ∃x(Px ∧ Qx).
(i) ∀x∃yPxy −→ ∃y∀xPxy.
II.2.4. Free Variable Normal Form. In future chapters it will be useful
to assume that LK proofs satisfy certain restrictions on free variables.
Deﬁnition II.2.20 (Free Variable Normal Form). Let  be an LK
proof with endsequent S. A free variable in S is called a parameter
variable of . We say  is in free variable normal form if (1) no free variable is completely eliminated from any sequent in  by any rule except
possibly ∀-right and ∃-left, and in these cases the eigenvariable which is
eliminated is not a parameter variable, and (2) every nonparameter free
variable appearing in  is used exactly once as an eigenvariable.
Thus if a proof is in free variable normal form, then any occurrence of a
parameter variable persists until the endsequent, and any occurrence of a

24

II. The Predicate Calculus and the System LK

nonparameter free variable persists until it is eliminated as an eigenvariable
in ∀-right or ∃-left.
We now describe a simple procedure for transforming an LK proof  to
a similar proof of the same endsequent in free variable normal form,
assuming that the underlying vocabulary L has at least one constant
symbol e. Note that the only rules other than ∀-right and ∃-left which can
eliminate a free variable from a sequent are cut, ∃-right, and ∀-left. It is
important that  have a tree structure in order for the procedure to work.
Transform  by repeatedly performing the following operation until the
resulting proof is in free variable normal form. Select some upper-most
rule in  which eliminates a free variable from a sequent which violates free
variable normal form. If the rule is ∀-right or ∃-left, and the eigenvariable
b which is eliminated occurs somewhere in the proof other than above this
rule, then replace b by a new variable b  (which does not occur elsewhere
in the proof) in every sequent above this rule. If the rule is cut, ∃-right,
or ∀-left, then replace every variable eliminated by the rule by the same
constant symbol e in every sequent above the rule (so now the rule does
not eliminate any free variable).
II.2.5. Completeness of LK without Equality.
Notation. Let Φ be a set of formulas. Then −→ Φ is the set of all
sequents of the form −→ A, where A is in Φ.
Deﬁnition II.2.21. Assume that the underlying vocabulary does not
contain =. If Φ is a set of formulas, then an LK-Φ proof is an LK proof
in which sequents at the leaves may be either logical axioms or nonlogical
axioms of the form −→ A, where A is in Φ.
Notice that a structure M satisﬁes −→ Φ iﬀ M satisﬁes Φ. Also a
sequent Γ −→ Δ is a logical consequence of −→ Φ iﬀ Γ −→ Δ is a logical
consequence of Φ.
We would like to be able to say that a sequent Γ −→ Δ is a logical
consequence of a set Φ of formulas iﬀ there is an LK-Φ proof of Γ −→
Δ. Unfortunately the soundness direction of the assertion is false. For
example, using the ∀-right rule we can derive −→ ∀xPx from −→ Pb, but
−→ ∀xPx is not a logical consequence of Pb.
We could correct the soundness statement by asserting it true for sentences, but we want to generalize this a little by introducing the notion of
the universal closure of a formula or sequent.
Deﬁnition II.2.22. Suppose that A is a formula whose free variables
comprise the list a1 , . . . , an . Then the universal closure of A, written ∀A, is
the sentence ∀x1 . . . ∀xn A(x1 /a1 , . . . , xn /an ), where x1 , . . . , xn is a list of
new (bound) variables. If Φ is a set of formulas, then ∀Φ is the set of all
sentences ∀A, for A in Φ.

II.2. Predicate Calculus

25

Notice that if A is a sentence (i.e., it has no free variables), then ∀A is
the same as A.
Initially we study the case in which the underlying vocabulary does not
contain =. To handle the case in which = occurs we must introduce
equality axioms. This will be done later.
Theorem II.2.23 (Derivational Soundness and Completeness of LK).
Assume that the underlying vocabulary does not contain =. Let Φ be a
set of formulas and let Γ −→ Δ be a sequent. Then there is an LK-Φ proof
of Γ −→ Δ iﬀ Γ −→ Δ is a logical consequence of ∀Φ. The soundness (only
if ) direction holds also when the underlying vocabulary contains =.
Proof of Soundness. Let  be a LK-Φ proof of Γ −→ Δ. We must
show that Γ −→ Δ is a logical consequence of ∀Φ. We want to prove
this by induction on the number of sequents in the proof , but in fact
we need a stronger induction hypothesis, to the eﬀect that the “closure”
of Γ −→ Δ is a logical consequence of ∀Φ. So we ﬁrst have to deﬁne the
closure of a sequent.
Thus we deﬁne the closure ∀S of a sequent S to be the closure of its
associated formula AS (Deﬁnition II.2.16). Note that if S =syn Γ −→ Δ,
then ∀S is not equivalent to ∀Γ −→ ∀Δ in general.
We now prove by induction on the number of sequents in , that if  is
an LK-Φ proof of a sequent S, then ∀S is a logical consequence of ∀Φ.
Since ∀S |= S, it follows that S itself is a logical consequence of ∀Φ, and
so Soundness follows.
For the base case, the sequent S is either a logical axiom, which is valid
and hence a consequence of ∀Φ, or it is a nonlogical axiom −→ A, where
A is a formula in Φ. In the latter case, ∀S is equivalent to ∀A, which of
course is a logical consequence of ∀Φ.
For the induction step, it is suﬃcient to check that for each rule of LK,
the closure of the bottom sequent is a logical consequence of the closure(s)
of the sequent(s) on top. With two exceptions, this statement is true when
the word “closure” is omitted, and adding back the word “closure” does
not change the argument much. The two exceptions are the rules ∀-right
and ∃-left. For these, the bottom is not a logical consequence of the top
in general, but an easy argument shows that the closures of the top and
bottom are equivalent.
2
The proof of completeness is more diﬃcult and more interesting than
the proof of soundness. The following lemma lies at the heart of this proof.
Lemma II.2.24 (Completeness). Assume that the underlying vocabulary
does not contain =. If Γ −→ Δ is a sequent and Φ is a (possibly inﬁnite) set
of formulas such that Γ −→ Δ is a logical consequence of Φ, then there is a
ﬁnite subset {C1 , . . . , Cn } of Φ such that the sequent
C1 , . . . , Cn , Γ −→ Δ
has an LK proof  which does not use the cut rule.

26

II. The Predicate Calculus and the System LK

Note that a form of the Compactness Theorem for predicate calculus
sentences without equality follows from the above lemma. See Theorem II.4.2 for a more general form of compactness.
Proof of Derivational Completeness. Let Φ be a set of formulas
such that Γ −→ Δ is a logical consequence of ∀Φ. By the completeness lemma, there is a ﬁnite subset {C1 , . . . , Cn } of Φ such that
∀C1 , . . . , ∀Cn , Γ −→ Δ
has a cut-free LK proof . Note that for each i, 1 ≤ i ≤ n, the sequent
−→ ∀Ci has an LK-Φ proof from the nonlogical axiom −→ Ci by repeated
use of the rule ∀-right. Now the proof  can be extended, using these proofs
of the sequents
−→ ∀C1 , . . . , −→ ∀Cn
and repeated use of the cut rule, to form an LK-Φ proof Γ −→ Δ.
2
Proof of the Completeness Lemma. We loosely follow the proof of
the Cut-free Completeness Theorem, pp. 33–36 of Buss [27]. (Warning:
our deﬁnition of logical consequence diﬀers from Buss’s when the formulas in the hypotheses have free variables.) We will only prove it for the case
in which the underlying ﬁrst-order vocabulary L has a countable set (including the case of a ﬁnite set) of function and predicate symbols; i.e., the
function symbols form a list f1 , f2 , . . . and the predicate symbols form a
list P1 , P2 , . . . . This may not seem like much of a restriction, but for example in developing the model theory of the real numbers, it is sometimes
useful to introduce a distinct constant symbol ec for every real number c;
and there are uncountably many real numbers. The completeness theorem
and lemma hold for the uncountable case, but we shall not prove them for
this case.
For the countable case, we may assign a distinct binary string to each
function symbol, predicate symbol, variable, etc., and hence assign a
unique binary string to each formula and term. This allows us to enumerate all the L-formulas in a list A1 , A2 , . . . and enumerate all the L-terms
(which contain only free variables a, b, c, . . . ) in a list t1 , t2 , . . . . The free
variables available to build the formulas and terms in these lists must include all the free variables which appear in Φ, together with a countably
inﬁnite set {c0 , c1 , . . . } of new free variables which do not occur in any
of the formulas in Φ. (These new free variables are needed for the cases
∃-left and ∀-right in the argument below.) Further we may assume that
every formula occurs inﬁnitely often in the list of formulas, and every
term occurs inﬁnitely often in the list of terms. Finally we may enumerate
all pairs Ai , tj , using any method of enumerating all pairs of natural
numbers.
We are trying to ﬁnd an LK proof of some sequent of the form
C1 , . . . , Cn , Γ −→ Δ

II.2. Predicate Calculus

27

for some n. Starting with Γ −→ Δ at the bottom, we work upward by
applying the rules in reverse, much as in the proof of the propositional
completeness theorem for PK. However now we will add formulas Ci
to the antecedent from time to time. Also unlike the PK case we have
no inversion principle to work with (speciﬁcally for the rules ∀-left and
∃-right). Thus it may happen that our proof-building procedure may not
terminate. In this case we will show how to deﬁne a structure which shows
that Γ −→ Δ is not a logical consequence of Φ.
We construct our cut-free proof tree  in stages. Initially  consists of
just the sequent Γ −→ Δ. At each stage we modify  by possibly adding
a formula from Φ to the antecedent of every sequent in , and by adding
subtrees to some of the leaves.
Notation. A sequent in  is said to be active provided it is at a leaf
and cannot be immediately derived from a logical axiom (i.e., no formula
occurs in both its antecedent and succedent, the logical constant  does
not occur in its succedent, and ⊥ does not occur in its antecedent).
Each stage uses one pair in our enumeration of all pairs Ai , tj . Here
is the procedure for the next stage, in general.
Let Ai , tj  be the next pair in the enumeration. We call Ai the active
formula for this stage.
Step 1. If Ai is in Φ, then replace every sequent Γ −→ Δ in  with the
sequent Γ , Ai −→ Δ .
Step 2. If Ai is atomic, do nothing and proceed to the next stage.
Otherwise, modify  at the active sequents which contain Ai by applying
the appropriate introduction rule in reverse, much as in the proof of
propositional completeness (Theorem II.1.8). (It suﬃces to pick any one
occurrence of Ai in each active sequent.) For example, if Ai is of the form
B ∨ C , then every active sequent in  of the form Γ , B ∨ C, Γ −→ Δ is
replaced by the derivation
Γ , B, Γ −→ Δ
Γ , C, Γ −→ Δ
======== ========
============
Γ , B ∨ C, Γ −→ Δ
Here the double line represents a derivation involving the rule ∨-left,
together with exchanges to move the formulas B, C to the left end of the
antecedent and move B ∨ C back to the right. The treatment is similar
when B ∨ C occurs in the succedent, only the rule ∨-right is used.
If Ai is of the form ∃xB(x), then every active sequent of  of the form
Γ , ∃xB(x), Γ −→ Δ is replaced by the derivation
Γ , B(c), Γ −→ Δ
==
===============
Γ , ∃xB(x), Γ −→ Δ
where c is a new free variable, not used in  yet. (Also c may not occur in
any formula in Φ, because otherwise at a later stage, Step 1 of the procedure

28

II. The Predicate Calculus and the System LK

might cause the variable restriction in the ∃-left rule to be violated.) In
addition, any active sequent of the form Γ −→ Δ , ∃xB(x), Δ is replaced
by the derivation
Γ −→ Δ , ∃xB(x), B(tj ), Δ
========== ============
Γ −→ Δ , ∃xB(x), Δ
Here the term tj is the second component in the current pair Ai , tj . The
derivation uses the rule ∃-right to introduce a new copy of ∃xB(x), and
then the rule contraction-right to combine the two copies of ∃xB(x). This
and the dual ∀-left case are the only two cases that use the term tj , and
the only cases that use the contraction rule.
The case where Ai begins with a universal quantiﬁer is dual to the above
existential case.
Step 3. If there are no active sequents remaining in , then exit from
the algorithm. Otherwise continue to the next stage.
Exercise II.2.25. Carry out the case above in which Ai begins with a
universal quantiﬁer.
If the algorithm constructing  ever halts, then  gives a cut-free proof
of Γ, C1 , . . . , Cn −→ Δ for some formulas C1 , . . . , Cn in Φ. This is because
the nonactive leaf sequents all can be derived from the logical axioms using
weakenings and exchanges. Thus  can be extended, using exchanges, to
a cut-free proof of C1 , . . . , Cn , Γ −→ Δ, as desired.
It remains to show that if the above algorithm constructing  never
halts, then the sequent Γ −→ Δ is not a logical consequence of Φ. So
suppose the algorithm never halts, and let  be the result of running the
algorithm forever. In general,  will be an inﬁnite tree, although in special
cases  is a ﬁnite tree. In general the objects at the nodes of the tree will
not be ﬁnite sequents, but because of Step 1 of the algorithm above, they
will be of the form Γ , C1 , C2 , . . . −→ Δ , where C1 , C2 , . . . is an inﬁnite
sequence of formulas containing all formulas in Φ, each repeated inﬁnitely
often (unless Φ is empty). We shall refer to these inﬁnite pseudo-sequents
as just “sequents”.
If  has only ﬁnitely many nodes, then at least one leaf node must be
active (and contain only atomic formulas), since otherwise the algorithm
would terminate. In this case, let be a path in  from the root extending
up to this active node. If on the other hand  has inﬁnitely many nodes,
then by Lemma II.1.18 (König), there must be an inﬁnite branch in 
starting at the root and extending up through the tree. Thus in either case,
is a branch in  starting at the root, extending up through the tree, and
such that all sequents on were once active, and hence have no formula
occurring on both the left and right, no  on the right and no ⊥ on the
left.

II.2. Predicate Calculus

29

We use this branch to construct a structure M and an object assignment which satisfy every formula in Φ, but falsify the sequent Γ −→ Δ
(so Γ −→ Δ is not a logical consequence of Φ).
Deﬁnition II.2.26 (Construction of the “Term Model” M). The universe M of M is the set of all L-terms t (which contain only “free”
variables a, b, c, . . . ). The object assignment just maps every variable a
to itself.
The interpretation f M of each k-ary function symbol f is deﬁned so
that f M (r1 , . . . , rk ) is the term fr1 . . . rk , where r1 , . . . , rk are any terms
(i.e., any members of the universe). The interpretation P M of each k-ary
predicate symbol P is deﬁned by letting P M (r1 , . . . , rk ) hold iﬀ the atomic
formula Pr1 . . . rk occurs in the antecedent (left side) of some sequent in
the branch .
Exercise II.2.27. Prove by structural induction that for every term t,
t M [ ] = t.
Claim. For every formula A, if A occurs in some antecedent in the
branch , then M and satisfy A, and if A occurs in some succedent in
, then M and falsify A.
Since the root of  is the sequent Γ, C1 , C2 , . . . −→ Δ, where C1 , C2 , . . .
contains all formulas in Φ, it follows that M and satisfy Φ and falsify
Γ −→ Δ.
We prove the Claim by structural induction on formulas A. For the
base case, if A is an atomic formula, then by the deﬁnition of P M above,
A is satisﬁed iﬀ A occurs in some antecedent of or A = . But no
atomic formula can occur both in an antecedent of some node in and in
a succedent (of possibly some other node) in , since then these formulas
would persist upward in so that some particular sequent in would
have A occurring both on the left and on the right. Thus if A occurs in
some succedent of , it is not satisﬁed by M and (recall that  does not
occur in any succedent of ).
For the induction step, there is a diﬀerent case for each of the ways
of constructing a formula from simpler formulas (see Deﬁnition II.2.2).
In general, if A occurs in some sequent in , then A persists upward in
every higher sequent of until it becomes the active formula (A =syn Ai ).
Each case is handled by the corresponding introduction rule used in the
algorithm. For example, if A is of the form B ∨ C and A occurs on the left
of a sequent in , then the rule ∨-left is applied in reverse, so that when
is extended upward either it will have some antecedent containing B or
one containing C . In the case of B, we know that M and satisfy B by
the induction hypothesis, and hence they satisfy B ∨ C . (Similarly for C .)
Now consider the interesting case in which A is ∃xB(x) and A occurs
in some succedent of . (See Step 2 above to ﬁnd out what happens

30

II. The Predicate Calculus and the System LK

when A becomes active in this case.) The path will hit a succedent with
B(tj ) in the succedent, and by the induction hypothesis, M and falsify
B(tj ). But this succedent still has a copy of ∃xB(x), and in fact this
copy will be in every succedent of above this point. Hence every L-term
t will eventually be of the form tj and so the formula B(t) will occur
as a succedent on . (This is why we assumed that every term appears
inﬁnitely often in the sequence t1 , t2 , . . . .) Therefore M and falsify B(t)
for every term t (i.e., for every element in the universe of M). Therefore
they falsify ∃xB(x), as required.
This and the dual case in which A is ∀xB(x) and occurs in some antecedent of are the only subtle cases. All other cases are straightforward.
2
We now wish to strengthen the derivational completeness of LK and
show that cuts can be restricted so that cut formulas are in Φ. The
deﬁnition of anchored PK proof (Deﬁnition II.1.12) can be generalized
to anchored LK proof. We will continue to restrict our attention to the
case in which all nonlogical axioms have the simple form −→ A, although
an analog of the following theorem does hold for an arbitrary set of
nonlogical axioms, provided they are closed under substitution of terms
for variables.
Theorem II.2.28 (Anchored LK Completeness). Assume that the underlying vocabulary does not contain =. Suppose that Φ is a set of formulas
closed under substitution of terms for variables. (I.e., if A(b) is in Φ, and t
is any term not containing “bound” variables x, y, z, . . . , then A(t) is also in
Φ.) Suppose that Γ −→ Δ is a sequent that is a logical consequence of ∀Φ.
Then there is an LK-Φ proof of Γ −→ Δ in which the cut rule is restricted
so that the only cut formulas are formulas in Φ.
Note that if all formulas in Φ are sentences, then the above theorem
follows easily from the Completeness Lemma, since in this case ∀Φ is the
same as Φ. However if formulas in Φ have free variables, then apparently
the cut rule must be applied to the closures ∀C of formulas C in Φ (as
opposed to C itself) in order to get an LK-Φ proof of Γ −→ Δ. It will
be important later, in our proof of witnessing theorems, that cuts can be
restricted to the formulas C .
Exercise II.2.29. Show how to modify the proof of the Completeness
Lemma to obtain a proof of the Anchored LK Completeness Theorem.
Explain the following modiﬁcations to that proof.
(a) The deﬁnition of active sequent on page 27 must be modiﬁed, since
now we are allowing nonlogical axioms in . Give the precise new
deﬁnition.
(b) Step 1 of the procedure on page 27 must be modiﬁed, because now
we are looking for a derivation of Γ −→ Δ from nonlogical axioms,

II.3. Equality Axioms

31

rather than a proof of C1 , . . . , Cn , Γ −→ Δ. Describe the modiﬁcation. (We still need to bring formulas Ai of Φ somehow into the
proof, and your modiﬁcation will involve adding a short derivation
to .)
(c) The restriction given in Step 2 for the case in which ∃xB(x) is in the
antecedent, that the variable c must not occur in any formula in Φ,
must be dropped. Explain why.
(d) Explain why the term model M and object assignment , described
on page 29 (Deﬁnition II.2.26), satisfy ∀Φ. This should follow
from the Claim on page 29, and your modiﬁcation of Step 1, which
should ensure that each formula in Φ occurs in the antecedent of
some sequent in every branch in . Conclude that Γ −→ Δ is not a
logical consequence of ∀Φ (when the procedure does not terminate).

II.3. Equality Axioms
Deﬁnition II.3.1. A weak L-structure M is an L-structure in which
we drop the requirement that =M is the equality relation (i.e., =M can be
any binary relation on M .)
Are there sentences E (axioms for equality) such that a weak structure
M satisﬁes E iﬀ M is a (proper) structure? It is easy to see that no such
set E of axioms exists, because we can always inﬂate a point in a weak
model to a set of equivalent points.
Nevertheless every vocabulary L has a standard set EL of equality axioms which satisﬁes the Equality Theorem below.
Deﬁnition II.3.2 (Equality Axioms of L (EL )).
EA1. ∀x(x = x) (reﬂexivity);
EA2. ∀x∀y(x = y ⊃ y = x) (symmetry);
EA3. ∀x∀y∀z((x = y ∧ y = z) ⊃ x = z) (transitivity);
EA4. ∀x1 . . . ∀xn ∀y1 . . . ∀yn (x1 = y1 ∧ · · · ∧ xn = yn ) ⊃ fx1 . . . xn =
fy1 . . . yn for each n ≥ 1 and each n-ary function symbol f in L.
EA5. ∀x1 . . . ∀xn ∀y1 . . . ∀yn (x1 = y1 ∧ · · · ∧ xn = yn ) ⊃ (Px1 . . . xn ⊃
Py1 . . . yn ) for each n ≥ 1 and each n-ary predicate symbol P in L
other than =.
Axioms EA1, EA2, EA3 assert that = is an equivalence relation. Axiom
EA4 asserts that functions respect the equivalence classes, and Axiom EA5
asserts that predicates respect equivalence classes. Together the axioms
assert that = is a congruence relation with respect to the function and
predicate symbols.
Note that the equality axioms are all valid, because of our requirement
that = be interpreted as equality in any (proper) structure.

32

II. The Predicate Calculus and the System LK

Theorem II.3.3 (Equality). Let Φ be any set of L-formulas. Then Φ is
satisﬁable iﬀ Φ ∪ EL is satisﬁed by some weak L-structure.
Corollary II.3.4. Φ |= A iﬀ for every weak L-structure M and every
object assignment , if M satisﬁes Φ ∪ EL under then M satisﬁes A under
.
Corollary II.3.5. ∀Φ |= A iﬀ A has an LK-Ψ proof, where Ψ = Φ∪EL .
Corollary II.3.4 follows immediately from the Equality Theorem and
the fact that Φ |= A iﬀ Φ ∪ {¬A} is unsatisﬁable. Corollary II.3.5 follows
from Corollary II.3.4 and the derivational soundness and completeness of
LK (page 25), where in applying that theorem we treat = as just another
binary relation (so we can assume L does not have the oﬃcial equality
symbol).
Proof of Equality. The ONLY IF (=⇒) direction is obvious, because
every structure M must interpret = as true equality, and hence M satisﬁes
the equality axioms EL .
For the IF (⇐=) direction, suppose that M is a weak L-structure with
universe M , such that M satisﬁes Φ ∪ EL . Our job is to construct a proper
structure M̂ such that M̂ satisﬁes Φ. The idea is to let the elements of M̂
be the equivalence classes under the equivalence relation =M . Axioms
EA4 and EA5 insure that the interpretation of each function and predicate
symbol under M induces a corresponding function or predicate in M̂.
Further each object assignment for M induces an object assignment ˆ
on M̂. Then for every formula A and object assignment , we show by
structural induction on A that M |= A[ ] iﬀ M̂ |= A[ ˆ ].
2
II.3.1. Equality Axioms for LK. For the purpose of using an LK proof
to establish Φ |= A, we can replace the standard equality axioms EA1, . . . ,
EA5 by the following quantiﬁer-free sequent schemes, where we must
include an instance of the sequent for all terms t, u, v, ti , ui (not involving
“bound” variables x, y, z, . . . ).
Deﬁnition II.3.6 (Equality Axioms for LK).
E1. −→ t = t;
E2. t = u −→ u = t;
E3. t = u, u = v −→ t = v;
E4. t1 = u1 , . . . , tn = un −→ ft1 . . . tn = fu1 . . . un , for each f in L;
E5. t1 = u1 , . . . , tn = un , Pt1 . . . tn −→ Pu1 . . . un , for each P in L (here
P is not =).
Note that the universal closures of E1, . . . , E5 are semantically equivalent to EA1, . . . , EA5, and in fact using the LK rule ∀-right repeatedly,
−→ EAi is easily derived in LK from Ei (with terms t, u, etc., taken to
be distinct variables), i = 1, . . . , 5. Thus Corollary II.3.5 above still holds
when Ψ = Φ ∪ {E1, . . . , E5}.

II.3. Equality Axioms

33

Deﬁnition II.3.7 (Revised Deﬁnition of LK with =). If Φ is a set of
L-formulas, where L includes =, then by an LK-Φ proof we now mean
an LK-Ψ proof in the sense of the earlier deﬁnition, page 24, where Ψ is
Φ together with all instances of the equality axioms E1, . . . , E5. If Φ is
empty, we simply refer to an LK-proof (but allow E1, . . . , E5 as axioms).
II.3.2. Revised Soundness and Completeness of LK.
Theorem II.3.8 (Revised Soundness and Completeness of LK). For
any set Φ of formulas and sequent S,
∀Φ |= S iﬀ S has an LK-Φ proof.
Notation. Φ  A means that there is an LK-Φ proof of −→ A.
Recall that if Φ is a set of sentences, then ∀Φ is the same as Φ. Therefore
Φ |= A iﬀ Φ  A, if Φ is a set of sentences.
Restricted use of cut. Note that E1, . . . , E5 have no universal quantiﬁers,
but instead have instances for all terms t, u, . . . . Recall that in an anchored
LK proof, cuts are restricted so that cut formulas must occur in the
nonlogical axioms. In the presence of equality, the nonlogical axioms must
include E1, . . . , E5, but the only formulas occurring here are equations of
the form t = u. Since the Anchored LK Completeness Theorem (page
30) still holds when Φ is a set of sequents rather than a set of formulas,
and since E1, . . . , E5 are closed under substitution of terms for variables,
we can extend this theorem so that it works in the presence of equality.
Deﬁnition II.3.9 (Anchored LK Proof). An LK-Φ proof  is anchored 1 provided every cut formula in  is a formula in some nonlogical
axiom of  (including possibly E1, . . . , E5).
Theorem II.3.10 (Anchored LK Completeness with Equality). Suppose that Φ is a set of formulas closed under substitution of terms for variables
and that the sequent S is a logical consequence of ∀Φ. Then there is an
anchored LK-Φ proof of S.
The proof is immediate from the Anchored LK Completeness Theorem
(page 30) and the above discussion about axioms E1, . . . , E5.
We are interested in anchored proofs because of their subformula property. The following result generalizes Proposition II.1.15.
Theorem II.3.11 (Subformula Property of Anchored LK Proofs). If 
is an anchored LK-Φ proof of a sequent S, then every formula in every
sequent of  is a term substitution instance of a subformula of a formula
either in S or in a nonlogical axiom of  (including E1, . . . , E5).
1 The deﬁnition of anchored in [27] is slightly stronger and more complicated.

34

II. The Predicate Calculus and the System LK

Proof sketch. The proof is by induction on the number of sequents in
. The induction step is proved by inspecting each LK rule. The case of
the cut rule uses the fact that every cut formula in an anchored proof is
a formula in some nonlogical axiom. The reason that we must consider
term substitutions is because of the four quantiﬁer rules. For example, in
∃-right, the formula A(t) occurs on top, and this is a substitution instance
of a subformula of ∃xA(x), which occurs on the bottom.
2

II.4. Major Corollaries of Completeness
Theorem II.4.1 (Löwenheim/Skolem). If a set Φ of formulas from a
countable vocabulary is satisﬁable, then Φ is satisﬁable in a countable (possibly ﬁnite) universe.
Proof. Suppose that Φ is a satisﬁable set of sentences. We apply the
proof of the Completeness Lemma (Lemma II.2.24), treating = as any
binary relation, replacing Φ by Φ = Φ ∪ EL , and taking Γ −→ Δ to be
the empty sequent (always false). In this case Γ −→ Δ is not a logical
consequence of Φ , so the proof constructs a term model M satisfying Φ
(see page 29). This structure has a countable universe M consisting of
all the L-terms. By the proof of the Equality Theorem, we can pass to
equivalence classes and construct a countable structure M̂ which satisﬁes
Φ (and interprets = as true equality).
2
As an application of the above theorem, we conclude that no countable
set of ﬁrst-order sentences can characterize the real numbers. This is
because if the ﬁeld of real numbers forms a model for the sentences,
then there will also be a countable model for the sentences. But the
countable model cannot be isomorphic to the ﬁeld of reals, because there
are uncountably many real numbers.
Theorem II.4.2 (Compactness). If Φ is an unsatisﬁable set of predicate
calculus formulas then some ﬁnite subset of Φ is unsatisﬁable.
(See also the three alternative forms in Theorem II.1.16.)
Proof. First note that we may assume that Φ is a set of sentences, by
replacing the free variables in Φ by distinct new constant symbols. The
resulting set of sentences is satisﬁable iﬀ the original set of formulas is
satisﬁable. Since Φ is unsatisﬁable iﬀ the empty sequent −→ is a logical
consequence of Φ, and since LK-Ψ proofs are ﬁnite, the theorem now
follows from Corollary II.3.5.
2
Theorem II.4.3. Suppose L has only ﬁnitely many function and predicate
symbols (or recursively enumerable sets of function and predicate symbols.)
Then the set of valid L-sentences is recursively enumerable. Similarly for
the set of unsatisﬁable L-sentences.

II.5. The Herbrand Theorem

35

Concerning this theorem, a set is recursively enumerable if there is an
algorithm for enumerating its members. To enumerate the valid formulas,
enumerate ﬁnite LK proofs. To enumerate the unsatisﬁable formulas, note
that A is unsatisﬁable iﬀ ¬A is valid.
Exercise II.4.4 (Application of Compactness). Show that if a set Φ of
sentences has arbitrarily large ﬁnite models, then Φ has an inﬁnite model.
(Hint: For each n construct a sentence An which is satisﬁable in any
universe with n or more elements but not satisﬁable in any universe with
fewer than n elements.)

II.5. The Herbrand Theorem
The Herbrand Theorem provides a complete method for proving the
unsatisﬁability of a set of universal sentences. It can be extended to a
complete method for proving the unsatisﬁability of an arbitrary set of
ﬁrst-order sentences by ﬁrst converting the sentences to universal sentences by introducing “Skolem” functions for the existentially quantiﬁed
variables. This forms the basis of the resolution proof method, which is
used extensively by automated theorem provers.
Deﬁnition II.5.1. A formula A is quantiﬁer-free if A has no occurrence of either of the quantiﬁers ∀ or ∃. A ∀-sentence is a sentence
of the form ∀x1 . . . ∀xk B where k ≥ 0 and B is a quantiﬁer-free formula. A ground instance of this sentence is a sentence of the form
B(t1 /x1 )(t2 /x2 ) . . . (tk /xk ), where t1 , . . . , tk are ground terms (i.e., terms
with no variables) from the underlying vocabulary.
Notice that a ground instance of a ∀-sentence A is a logical consequence
of A. Therefore if a set Φ0 of ground instances of A is unsatisﬁable, then
A is unsatisﬁable. The Herbrand Theorem implies a form of the converse.
Deﬁnition II.5.2 (L-Truth Assignment). An L-truth assignment (or
just truth assignment) is a map
 : {L-atomic formulas} → {T, F }.
We extend  to the set of all quantiﬁer-free L-formulas by applying the
usual rules for propositional connectives.
The above deﬁnition of truth assignment is the same as in the propositional calculus, except now we take the set of atoms to be the set of
L-atomic formulas. Thus we say that a set Φ0 of quantiﬁer-free formulas is propositionally unsatisﬁable if no truth assignment satisﬁes every
member of Φ0 .
Lemma II.5.3. If a set Φ0 of quantiﬁer-free sentences is propositionally
unsatisﬁable, then Φ0 is unsatisﬁable (in the ﬁrst-order sense).

36

II. The Predicate Calculus and the System LK

Proof. We prove the contrapositive: Suppose that Φ0 is satisﬁable, and
let M be a ﬁrst-order structure which satisﬁes Φ0 . Then M induces a
truth assignment  by the deﬁnition B  = T iﬀ M |= B for each atomic
sentence B. Then B  = T iﬀ M |= B for each quantiﬁer-free sentence B,
so  satisﬁes Φ0 .
2
We can now state our simpliﬁed proof method, which applies to sets
of ∀-sentences: Simply take ground instances of sentences in Φ together
with the equality axioms EL until a propositionally unsatisﬁable set Φ0
is found. The method does not specify how to check for propositional
unsatisﬁability: any method (such as truth tables) for that will do. Notice
that by propositional compactness, it is suﬃcient to consider ﬁnite sets
Φ0 of ground instances. The Herbrand Theorem states that this method
is sound and complete.
Theorem II.5.4 (Herbrand Theorem, Form 1). Suppose that the underlying vocabulary L has at least one constant symbol, and let Φ be a set of
∀-sentences. Then Φ is unsatisﬁable iﬀ some ﬁnite set Φ0 of ground instances
of sentences in Φ ∪ EL is propositionally unsatisﬁable.
Corollary II.5.5 (Herbrand Theorem, Form 2). Let Φ be a set of ∀sentences and let A(x, y) be a quantiﬁer-free formula with all free variables
indicated such that
Φ |= ∀x∃yA(x, y).
Then there exist ﬁnitely many terms t1 (x), . . . , tk (x) in the vocabulary of Φ
and A(x, y) such that


Φ |= ∀x A(x, t1 (x)) ∨ · · · ∨ A(x, tk (x)) .
We will use Form 2 in later chapters to prove “witnessing theorems”
for various theories. The idea is that one of the terms t1 (x), . . . , tk (x)
“witnesses” the existential quantiﬁer ∃y in the formula ∀x∃yA(x, y).
Exercise II.5.6. Prove Form 2 from Form 1. Start by showing that
under the hypotheses of Form 2, Φ ∪ {∀y¬A(c, y)} is unsatisﬁable, where
c is a list of new constants.
Example II.5.7. Let c be a constant symbol, and let
Φ = {∀x(Px ⊃ Pfx), Pc, ¬Pffc}.
Then the set H of ground terms is {c, fc, ffc, . . . }. We can take the set
Φ0 of ground instances to be
Φ0 = {(Pc ⊃ Pfc), (Pfc ⊃ Pffc), Pc, ¬Pffc}.
Then Φ0 is propositionally unsatisﬁable, so Φ is unsatisﬁable.
Proof of the Soundness direction of Theorem II.5.4. If Φ0 is propositionally unsatisﬁable, then Φ is unsatisﬁable. This follows easily from
2
Lemma II.5.3, since Φ0 is a logical consequence of Φ.

II.5. The Herbrand Theorem

37

Proof of the Completeness Direction of Theorem II.5.4. This follows from the Anchored LK Completeness Theorem (see Exercise II.5.9
below). Here we give a direct proof.
We prove the contrapositive: If every ﬁnite set of ground instances of Φ∪
EL is propositionally satisﬁable, then Φ is satisﬁable. By Corollary II.3.4,
we may ignore the special status of =.
Let Φ0 be the set of all ground instances of Φ ∪ EL (using ground
terms from L). Assuming that every ﬁnite subset of Φ0 is propositionally
satisﬁable, it follows from propositional compactness (Theorem II.1.16,
Form 3) that the entire set Φ0 is propositionally satisﬁable. Let  be a
truth assignment which satisﬁes Φ0 . We use  to construct an L-structure
M which satisﬁes Φ. We use a term model, similar to that used in the
proof of the Completeness Lemma (Deﬁnition II.2.26).
Let the universe M of M be the set H of all ground L-terms.
For each n-ary function symbol f deﬁne
f M (t1 , . . . , tn ) = ft1 . . . tn .
(In particular, c M = c for each constant c, and it follows by induction
that t M = t for each ground term t.)
For each n-ary predicate symbol P of L, deﬁne
P M = {t1 , . . . , tn  : (Pt1 . . . tn ) = T }.
This completes the speciﬁcation of M. It follows easily by structural
induction that M |= B iﬀ B  = T , for each quantiﬁer-free L-sentence
B with no variables. Thus M |= B for every ground instance B of any
sentence in Φ. Since every member of Φ is a ∀-sentence, and since the
elements of the universe are precisely the ground terms, it follows that
M satisﬁes every member of Φ. (A formal proof would use the Basic
Semantic Deﬁnition (Deﬁnition II.2.8) and the Substitution Theorem
(Theorem II.2.14).
2
Exercise II.5.8. Show (from the proof of the Herbrand Theorem) that
a satisﬁable set of ∀ sentences without = and without function symbols
except the constants c1 , . . . , cn for n ≥ 1 has a model with exactly n
elements in the universe. Give an example showing that n − 1 elements
would not suﬃce in general.
Exercise II.5.9. Show that the completeness direction of the Herbrand
Theorem (Form 1) follows from the Anchored LK Completeness Theorem
(with equality, Deﬁnition II.3.9 and Theorem II.3.10) and the following
syntactic lemma.
Lemma II.5.10. Let Φ be a set of formulas closed under substitution of
terms for variables. Let  be an LK-Φ proof in which all formulas are
quantiﬁer-free, let t be a term and let b be a variable, and let (t/b) be the

38

II. The Predicate Calculus and the System LK

result of replacing every occurrence of b in  by t. Then (t/b) is an LK-Φ
proof.
Deﬁnition II.5.11 (Prenex Form). We say that a formula A is in prenex
form if A has the form Q1 x1 . . . Qn xn B, where each Qi is either ∀ or ∃, and
B is a quantiﬁer-free formula.
Theorem II.5.12 (Prenex Form). There is a simple procedure which,
given a formula A, produces an equivalent formula A in prenex form.
Proof. First rename all quantiﬁed variables in A so that they are all
distinct (see the remark on page 21). Now move all quantiﬁers out past the
connectives ∧, ∨, ¬ by repeated use of the equivalences below. (Recall that
by the Formula Replacement Theorem (Theorem II.2.15), we can replace
a subformula in A by an equivalent formula and the result is equivalent
to A.)
Note. In each of the following equivalences, we must assume that x
does not occur free in C .
(∀xB ∧ C ) ⇐⇒ ∀x(B ∧ C )

(∀xB ∨ C ) ⇐⇒ ∀x(B ∨ C )

(C ∧ ∀xB) ⇐⇒ ∀x(C ∧ B)

(C ∨ ∀xB) ⇐⇒ ∀x(C ∨ B)

(∃xB ∧ C ) ⇐⇒ ∃x(B ∧ C )

(∃xB ∨ C ) ⇐⇒ ∃x(B ∨ C )

(C ∧ ∃xB) ⇐⇒ ∃x(C ∧ B)

(C ∨ ∃xB) ⇐⇒ ∃x(C ∨ B)

¬∀xB ⇐⇒ ∃x¬B

¬∃xB ⇐⇒ ∀x¬B.

2

II.6. Notes
Our treatment of PK in sections II.1.1 and II.1.2 is adapted from Section
1.2 of [27].
Sections II.2.1 to II.2.3 roughly follow Sections 2.1 and 2.2 of [27].
However an important diﬀerence is that the deﬁnition of Φ |= A in [27]
treats free variables as though they are universally quantiﬁed, but our
deﬁnition does not.
The proof of the Anchored LK Completeness Theorem outlined in
Exercise II.2.29 grew out of discussions with S. Buss.

Chapter III

PEANO ARITHMETIC AND ITS SUBSYSTEMS

Peano Arithmetic is the ﬁrst order theory of N with simple axioms for
+, ·, ≤, and the induction axiom scheme. Here we focus on the subsystem
IΔ0 of Peano Arithmetic, in which induction is restricted to bounded
formulas. This subsystem plays an essential role in the development of
the theories in later chapters: All (two-sorted) theories introduced in
this book extend V 0 , which is a conservative extension of IΔ0 . At the
end of the chapter we brieﬂy discuss Buss’s hierarchy S21 ⊆ T21 ⊆ S22 . . . .
These single-sorted theories establish a link between bounded arithmetic
and the polynomial time hierarchy, and have played a central role in the
study of bounded arithmetic. In later chapters we introduce their twosorted versions, including V 1 , a theory that characterizes P. The theories
considered in this chapter are singled-sorted, and the intended domain is
N = {0, 1, 2, . . . }.
Subsection III.3.3 shows that the relation y = 2x is deﬁnable by a
bounded formula in the vocabulary of IΔ0 , and in Section III.4 this is
used to show that bounded formulas represent precisely the relations in
the Linear Time Hierarchy (LTH).

III.1. Peano Arithmetic
See Section II.2 for notions such as vocabulary, formula, and logical
consequence.
Deﬁnition III.1.1. A theory over a vocabulary L is a set T of formulas
over L which is closed under logical consequence and universal closure.
We often specify a theory by a set Γ of axioms for T , where Γ is a set of
L-formulas. In that case
T = {A : A is an L-formula and ∀Γ |= A}.
Here ∀Γ is the set of universal closures of formulas in Γ (Deﬁnition II.2.22).
Note that it is more usual to require that a theory be a set of sentences,
rather than formulas. Our version of a usual theory T is T together with
39

40

III. Peano Arithmetic and Its Subsystems

all formulas (with free variables) which are logical consequences of T .
Recall ∀A |= A, for any formula A.
Notation. We sometimes write T  A to mean A ∈ T . If T  A we
say that A is a theorem of T .
The theories that we consider in this section have the vocabulary of
arithmetic
LA = [0, 1, +, · ; =, ≤]
as the underlying vocabulary (Deﬁnition II.2.3).
Recall that the standard model N for LA has universe M = N and
0, 1, +, ·, =, ≤ get their standard meanings in N.
Notation. t < u stands for (t ≤ u ∧ t = u). For each n ∈ N we deﬁne
a term n called the numeral for n inductively as follows:
0 = 0, 1 = 1,

for n ≥ 1, n + 1 = (n + 1).

For example, 3 is the term ((1+1)+1). In general, the term n is interpreted
as n in the standard model.
Deﬁnition III.1.2. TA (True Arithmetic) is the theory over LA consisting of all formulas whose universal closures are true in the standard
model:
TA = {A : N |= ∀A}.
It follows from Gödel’s Incompleteness Theorem that TA has no computable set of axioms. The theories we deﬁne below are all proper subtheories of TA with nice, computable sets of axioms.
Note that by Deﬁnition II.2.6, = is interpreted as true equality in all
LA -structures, and hence we do not need to include the Equality Axioms
in our list of axioms. (Of course LK proofs still need equality axioms: see
Deﬁnition II.3.7 and Corollaries II.3.4, II.3.5).
We start by listing nine “basic” quantiﬁer-free formulas B1, . . . , B8 and
C, which comprise the axioms for our basic theory. See Figure 1 below.
B1. x + 1 = 0
B2. x + 1 = y + 1 ⊃ x = y
B3. x + 0 = x
B4. x + (y + 1) = (x + y) + 1
C. 0 + 1 = 1

B5. x · 0 = 0
B6. x · (y + 1) = (x · y) + x
B7. (x ≤ y ∧ y ≤ x) ⊃ x = y
B8. x ≤ x + y

Figure 1. 1-BASIC.
These axioms provide recursive deﬁnitions for + and ·, and some basic
properties of ≤. Axiom C is not necessary in the presence of induction,
since it then follows from the theorem 0 + x = x (see Example III.1.8,
O2). However we put it in so that ∀B1, . . . , ∀B8, ∀C alone imply all true
quantiﬁer-free sentences over LA .

III.1. Peano Arithmetic

41

Lemma III.1.3. If ϕ is a quantiﬁer-free sentence of LA , then
TA  ϕ

iﬀ

1-BASIC  ϕ.

Proof. The direction ⇐= holds because the axioms of 1-BASIC are
valid in N.
For the converse, we start by proving by induction on m that if m < n,
then 1-BASIC  m = n. The base case follows from B1 and C, and the
induction step follows from B2 and C.
Next we use B3, B4 and C to prove by induction on n that if m + n = k,
then 1-BASIC  m + n = k. Similarly we use B5, B6 and C to prove that
if m · n = k then 1-BASIC  m · n = k.
Now we use the above results to prove by structural induction on t, that
if t is any term without variables, and t is interpreted as n in the standard
model N, then 1-BASIC  t = n.
It follows from the above results that if t and u are any terms without
variables, then TA  t = u implies 1-BASIC  t = u, and TA  t = u
implies 1-BASIC  t = u.
Consequently, if m ≤ n, then for some k, 1-BASIC  n = m + k,
and hence by B8, 1-BASIC  m ≤ n. Also if not m ≤ n, then n < m,
so by the above 1-BASIC  m = n and 1-BASIC  n ≤ m, so by B7,
1-BASIC  ¬m ≤ n.
Finally let ϕ be any quantiﬁer-free sentence. We prove by structural
induction on ϕ that if TA  ϕ then 1-BASIC  ϕ and if TA  ¬ϕ then
1-BASIC  ¬ϕ. For the base case ϕ is atomic and has one of the forms
t = u or t ≤ u, so the base case follows from the above. The induction
step involves the three cases ∧, ∨, and ¬, which are immediate.
2
Deﬁnition III.1.4 (Induction Scheme). If Φ is a set of formulas, then
Φ-IND axioms are the formulas
[ϕ(0) ∧ ∀x, ϕ(x) ⊃ ϕ(x + 1)] ⊃ ∀zϕ(z)

(10)

where ϕ is a formula in Φ. Note that ϕ(x) is permitted to have free
variables other than x.
Deﬁnition III.1.5 (Peano Arithmetic). The theory PA has as axioms
B1, . . . , B8, together with the Φ-IND axioms, where Φ is the set of all LA
formulas.
(As we noted earlier, C is provable from the other axioms in the presence
of induction.)
PA is a powerful theory capable of formalizing the major theorems of
number theory. We deﬁne subsystems of PA by restricting the induction
axiom to certain sets of formulas. We use the following notation.
Deﬁnition III.1.6 (Bounded Quantiﬁers). If the variable x does not
occur in the term t, then ∃x ≤ tA stands for ∃x(x ≤ t ∧ A), and ∀x ≤ tA

42

III. Peano Arithmetic and Its Subsystems

stands for ∀x(x ≤ t ⊃ A). Quantiﬁers that occur in this form are said
to be bounded, and a bounded formula is one in which every quantiﬁer is
bounded.
Notation. Let ∃x stand for ∃x1 ∃x2 . . . ∃xk , k ≥ 0.
Deﬁnition III.1.7 (IOPEN , IΔ0 , IΣ1 ). OPEN is the set of open (i.e.,
quantiﬁer-free) formulas; Δ0 is the set of bounded formulas; and Σ1 is the
set of formulas of the form ∃xϕ, where ϕ is bounded and x is a possibly
empty vector of variables. The theories IOPEN, IΔ0 , and IΣ1 are the
subsystems of PA obtained by restricting the induction scheme so that Φ
is OPEN, Δ0 , and Σ1 , respectively.
Note that the underlying vocabulary of the theories deﬁned above is LA .
Example III.1.8. The following formulas (and their universal closures)
are theorems of IOPEN:
O1. (x + y) + z = x + (y + z) (Associativity of +);
O2. x + y = y + x (Commutativity of +);
O3. x · (y + z) = (x · y) + (x · z) (Distributive law);
O4. (x · y) · z = x · (y · z) (Associativity of ·);
O5. x · y = y · x (Commutativity of ·);
O6. x + z = y + z ⊃ x = y (Cancellation law for +);
O7. 0 ≤ x;
O8. x ≤ 0 ⊃ x = 0;
O9. x ≤ x;
O10. x = x + 1.
Proof. O1. Induction on z.
O2. Induction on y, ﬁrst establishing the special cases y = 0 and y = 1.
O3. Induction on z.
O4. Induction on z, using O3.
O5. Induction on y, after establishing (y + 1) · x = y · x + x by induction
on x.
O6. Induction on z.
O7. B8, O2, B3.
O8. O7, B7.
O9. B8, B3.
O10. Induction on x and B2.
2
Recall that x < y stands for (x ≤ y ∧ x = y).
Example III.1.9. The following formulas (and their universal closures)
are theorems of IΔ0 :
D1. x = 0 ⊃ ∃y ≤ x(x = y + 1) (Predecessor);
D2. ∃z(x + z = y ∨ y + z = x);
D3. x ≤ y ↔ ∃z(x + z = y);
D4. (x ≤ y ∧ y ≤ z) ⊃ x ≤ z (Transitivity);

III.1. Peano Arithmetic

43

D5. x ≤ y ∨ y ≤ x (Total order);
D6. x ≤ y ↔ x + z ≤ y + z;
D7. x ≤ y ⊃ x · z ≤ y · z;
D8. x ≤ y + 1 ↔ (x ≤ y ∨ x = y + 1) (Discreteness 1);
D9. x < y ↔ x + 1 ≤ y (Discreteness 2);
D10. x · z = y · z ∧ z = 0 ⊃ x = y (Cancellation law for ·).
Proof. D1. Induction on x.
D2. Induction on x. Base case: B2, O2. Induction step: B3, B4, D1.
D3. =⇒: D2, B3 and B7; ⇐=: B8.
D4. D3, O1.
D5. D2, B8.
D6. =⇒: D3, O1, O2; ⇐=: D3, O6.
D7. D3 and algebra (O1, . . . , O8).
D8. =⇒: D3, D1, and algebra; ⇐=: O9, B8, D4.
D9. =⇒: D3, D1, and algebra; ⇐=: D3 and algebra.
D10. Exercise.

2

Taken together, these results show that all models of IΔ0 are commutative discretely-ordered semi-rings.
Exercise III.1.10. Show that IΔ0 proves the division theorem:
IΔ0  ∀x∀y(0 < x ⊃ ∃q ∃r < x, y = x · q + r).
It follows from Gödel’s Incompleteness Theorem that there is a bounded
formula ϕ(x) such that ∀xϕ(x) is true but IΔ0  ∀xϕ(x). However if ϕ
is a true sentence in which all quantiﬁers are bounded, then intuitively ϕ
expresses information about only ﬁnitely many tuples of numbers, and in
this case we can show IΔ0  ϕ. The same applies more generally to true
Σ1 sentences ϕ.
Lemma III.1.11. If ϕ is a Σ1 sentence, then TA  ϕ iﬀ IΔ0  ϕ.
Proof. The direction ⇐= follows because all axioms of IΔ0 are true in
the standard model.
For the converse, we prove by structural induction on bounded sentences ϕ that if TA  ϕ then IΔ0  ϕ, and if TA  ¬ϕ then IΔ0  ¬ϕ.
The base case is ϕ is atomic, and this follows from Lemma III.1.3. For
the induction step, the cases ∨, ∧, and ¬ are immediate. The remaining
cases are ϕ is ∀x ≤ t (x) and ϕ is ∃x ≤ t (x), where t is a term without
variables, and (x) is a bounded formula with no free variable except
possibly x. These cases follow from Lemma III.1.3 and Lemma III.1.12
below.
Now suppose that ϕ is a true Σ1 sentence of the form ∃x (x), where
(x) is a bounded formula. Then (n) is a true bounded sentence for
some numerals n 1 , . . . , n k , so IΔ0  (n). Hence IΔ0  ϕ.
2

44

III. Peano Arithmetic and Its Subsystems

Lemma III.1.12. For each n ∈ N,
IΔ0  x ≤ n ↔ (x = 0 ∨ x = 1 ∨ · · · ∨ x = n).
Proof. Induction on n. The base case n = 0 follows from O7 and O8,
and the induction step follows from D8.
2
III.1.1. Minimization.
Deﬁnition III.1.13 (Minimization). The minimization axioms (or
least number principle axioms) for a set Φ of formulas are denoted Φ-MIN
and consist of the formulas


∃zϕ(z) ⊃ ∃y ϕ(y) ∧ ¬∃x(x < y ∧ ϕ(x))
where ϕ is a formula in Φ.
Theorem III.1.14. IΔ0 proves Δ0 -MIN.
Proof. The contrapositive of the minimization axiom for ϕ(z) follows from the induction axiom for the bounded formula (z) ≡ ∀y ≤
z(¬ϕ(y)).
2
Exercise III.1.15. Show that IΔ0 can be alternatively axiomatized by
B1, . . . , B8, O10 (Example III.1.8), D1 (Example III.1.9), and the axiom
scheme Δ0 -MIN.
III.1.2. Bounded Induction Scheme. The Δ0 -IND scheme of IΔ0 can be
replaced by the following bounded induction scheme for Δ0 formulas, i.e.,


ϕ(0) ∧ ∀x < z(ϕ(x) ⊃ ϕ(x + 1)) ⊃ ϕ(z)
(11)
where ϕ(x) is any Δ0 formula. (Note that the IND formula (10) for ϕ(x)
is a logical consequence of the universal closure of this.)
Exercise III.1.16. Prove that IΔ0 remains the same if the Δ0 -IND
scheme is replaced by the above bounded induction scheme for Δ0 formulas. (It suﬃces to show that the new scheme is provable in IΔ0 .)
III.1.3. Strong Induction Scheme. The strong induction axiom for a formula ϕ(x) is the following formula:


∀x (∀y < xϕ(y)) ⊃ ϕ(x) ⊃ ∀zϕ(z).
(12)
Exercise III.1.17. Show that IΔ0 proves the strong induction axiom
scheme for Δ0 formulas.

III.2. Parikh’s Theorem
By the results in the previous section, IΔ0 can be axiomatized by a set
of bounded formulas. We say that it is a polynomial-bounded theory, a
concept we will now deﬁne.

III.2. Parikh’s Theorem

45

In general, a theory T may have symbols other than those in LA . We
say that a term t(x) is a bounding term for a function symbol f(x) in T if
T  ∀x f(x) ≤ t(x).

(13)

We say that f is polynomially bounded (or just p-bounded) in T if it has a
bounding term in the vocabulary LA .
Exercise III.2.1. Let T be an extension of IΔ0 and let L be the vocabulary of T . Suppose that the functions of L are polynomially bounded in
T . Show that for each L-term s(x), there is an LA -term t(x) such that
T  ∀x s(x) ≤ t(x).
Suppose that a theory T is an extension of IΔ0 . We can still talk about
bounded formulas ϕ in T using the same deﬁnition (Deﬁnition III.1.6)
as before, but now ϕ may have function and predicate symbols not in the
vocabulary [0, 1, +, ·; =, ≤] of IΔ0 , and in particular the terms t bounding
the quantiﬁers ∃x ≤ t and ∀x ≤ t may have extra function symbols.
Note that by the exercise above, in the context of polynomial-bounded
theories (deﬁned below) we may assume without loss of generality that
the bounding terms are LA -terms.
Deﬁnition III.2.2 (Polynomial-Bounded Theory). Let T be a theory
with vocabulary L. Then T is a polynomial-bounded theory (or just pbounded theory) if (i) it extends IΔ0 ; (ii) it can be axiomatized by a set of
bounded formulas; and (iii) each function f ∈ L is polynomially bounded
in T .
Note that IΔ0 is a polynomial-bounded theory.
Theories which satisfy (ii) are often called bounded theories.
Theorem III.2.3 (Parikh’s Theorem). If T is a polynomial-bounded theory and ϕ(x, y) is a bounded formula with all free variables displayed such
that T  ∀x∃yϕ(x, y), then there is a term t involving only variables in x
such that T proves ∀x∃y ≤ tϕ(x, y).
It follows from Exercise III.2.1 that the bounding term t can be taken
to be an LA -term. In fact, Parikh’s Theorem can be generalized to say
that if ϕ is a bounded formula and T  ∃yϕ, then there are LA -terms
t1 , . . . , tk not involving any variable in y or any variable not occurring free
in ϕ such that T proves ∃y1 ≤ t1 . . . ∃yk ≤ tk ϕ. This follows from the
above remark, and the following lemma.
Lemma III.2.4. Let T be an extension of IΔ0 . Let z be a variable distinct
from y1 , . . . , yk and not occurring in ϕ. Then
T  ∃yϕ ↔ ∃z∃y1 ≤ z . . . ∃yk ≤ z ϕ.
Exercise III.2.5. Give a careful proof of the above lemma, using the
theorems of IΔ0 described in Example III.1.9.

46

III. Peano Arithmetic and Its Subsystems

In section III.3.3 we will show how to represent the relation y = 2x
by a bounded formula ϕexp (x, y). It follows immediately from Parikh’s
Theorem that
IΔ0  ∀x∃yϕexp (x, y).
On the other hand PA easily proves the ∃yϕexp (x, y) by induction on x.
Therefore IΔ0 is a proper sub-theory of PA.
Our proof of Parikh’s Theorem will be based on the Anchored LK
Completeness Theorem with Equality (II.3.10). Let T be a polynomialbounded theory and ∀x∃yϕ(x, y) a theorem of T . We will look into an
anchored proof of ∀x∃yϕ(x, y) and show that a term t (not involving y)
can be constructed so that ∀x∃y ≤ tϕ(x, y) is also a theorem of T . In
order to apply the Anchored LK Completeness Theorem (with Equality),
we need to ﬁnd an axiomatization of T which is closed under substitution
of terms for variables. Note that T is already axiomatized by a set of
bounded formulas (Deﬁnition III.2.2). The desired axiomatization of T
is obtained by substituting terms for all the free variables. We will consider
the example where T is IΔ0 . The general case is similar.
Recall that the axioms for IΔ0 consist of B1–B8 (page 40) and the
Δ0 -IND scheme, which can be replaced by the Bounded Induction Scheme
(11).
Deﬁnition III.2.6 (ID0 ). ID0 is the set of all term substitution instances of B1–B8 and the Bounded Induction Scheme, where now the
terms contain only “free” variables a, b, c, . . . .
Note that all formulas in ID0 are bounded.
For example (c · b) + 1 = 0 is an instance of B1, and hence is in ID0 .
Also
a + 0 = 0 + a ∧ ∀x < b(a + x = x + a ⊃ a + (x + 1) = (x + 1) + a)
⊃a +b =b+a
is an instance of (11) useful in proving the commutative law a + b = b + a
by induction on b, and is in ID0 .
The following is an immediate consequence of the Anchored LK Completeness Theorem II.3.10 and Derivational Soundness of LK (Theorem
II.2.23).
Theorem III.2.7 (LK-ID0 Adequacy). Let A be an LA formula satisfying the LK constraint that only variables a, b, c, . . . occur free and only
x, y, z, . . . occur bound. Then IΔ0  A iﬀ A has an anchored LK-ID0 proof.
Proof of Parikh’s Theorem. Suppose that T is a polynomial-bounded theory which is axiomatized by a set of bounded axioms such that
T  ∀x∃yϕ(x, y), where ϕ(x, y) is a bounded formula. Let T be the
set of all term substitution instances of the axioms of T . By arguing as
above in the case T = IΔ0 , we can assume that −→ ∃yϕ(a, y) has an

III.2. Parikh’s Theorem

47

anchored LK-T proof . Further we may assume that  is in free variable
normal form (Section II.2.4). By the sub-formula property of anchored
proofs (II.3.11), every formula in every sequent of  is either bounded, or
a substitution instance of the endsequent ∃yϕ(a, y). But in fact the proof
of the sub-formula property actually shows more: Every formula in  is
either bounded or it must be syntactically identical to ∃yϕ(a, y), and in
the latter case it must occur in the consequent (right side) of a sequent.
The reason is that once an unbounded quantiﬁer is introduced in , the
resulting formula can never be altered by any rule, since cut formulas are
restricted to the bounded formulas occurring in T, and since no altered
version of ∃yϕ(a, y) occurs in the endsequent. (We may assume that
∃yϕ(a, y) is an unbounded formula, since otherwise there is nothing to
prove.)
We will convert  to an LK-T proof  of ∃y ≤ tϕ(y) for some term t
not containing y, by replacing each sequent S in  by a suitable sequent
S  , sometimes with a short derivation D(S) of S  inserted.
Here and in general we treat the cedents Γ and Δ of a sequent Γ −→ Δ
as multi-sets in which the order of formulas is irrelevant. In particular we
ignore instances of the exchange rule.
The conversion of a sequent S in  to S  , and the associated derivation
D(S), are deﬁned by induction on the depth of S in  such that the
following is satisﬁed:
Induction Hypothesis. If S has no occurrence of ∃yϕ, then S  = S. If S
has one or more occurrences of ∃yϕ, then S  is a sequent which is the same
as S except all occurrences of ∃yϕ are replaced by a single occurrence of
∃y ≤ tϕ, where the term t depends on S and the placement of S in .
Further t satisﬁes the condition
Every variable in t occurs free in the original sequent S.

(14)

Thus the endsequent of  has the form −→ ∃y ≤ tϕ, where every
variable in t occurs free in ∃yϕ.
In order to maintain the condition (14) we use our assumption that 
is in free variable normal form. Thus if the variable b occurs in t in the
formula ∃y ≤ tϕ, so b occurs in S, then b cannot be eliminated from the
descendants of S except by the rule ∀-right or ∃-left. These rules require
special attention in the argument below.
We consider several cases, depending on the inference rule in  forming
S, and whether ∃yϕ is the principle formula of that rule.
Case I. S is the result of ∃-right applied to ϕ(s) for some term s, so
the inference has the form
Γ −→ Δ, ϕ(s)
Γ −→ Δ, ∃yϕ(y)

(15)

48

III. Peano Arithmetic and Its Subsystems

where S is the bottom sequent. Suppose ﬁrst that Δ has no occurrence of
∃yϕ. Since ID0 proves s ≤ s there is a short LK-T derivation of
Γ −→ Δ, ∃y ≤ sϕ(y)

(16)

from the top sequent. Let D(S) be that derivation and let S  be the sequent
(16).
If Δ has one or more occurrence of ∃yϕ, then by the induction hypothesis the top sequent S1 of (15) was converted to a sequent S1 in which all
of these occurrences have been replaced by a single occurrence of the form
∃y ≤ tϕ. We proceed as before, producing a sequent of the form
Γ −→ Δ , ∃y ≤ tϕ, ∃y ≤ sϕ.

(17)

Since ID0 proves the two sequents −→ s ≤ s + t and −→ t ≤ s + t, it
follows that T proves
∃y ≤ sϕ −→ ∃y ≤ (s + t)ϕ
and
∃y ≤ tϕ −→ ∃y ≤ (s + t)ϕ.
We can use these and (17) with two cuts and a contraction to obtain a
derivation of
Γ −→ Δ , ∃y ≤ (s + t)ϕ(y).

(18)

Let D(S) be this derivation and let S  be the resulting sequent (18).
Case II. S is the result of weakening right, which introduces ∃yϕ. Thus
the inference has the form
Γ −→ Δ
Γ −→ Δ, ∃yϕ

(19)

where S is the bottom sequent. If Δ does not contain ∃yϕ, then deﬁne S 
to be
Γ −→ Δ, ∃y ≤ 0 ϕ
(introduced by weakening). If Δ contains one or more occurrences of
∃yϕ, then take S  = S1 , where S1 is the top sequent of (19).
Case III. S is the result of ∀-right or ∃-left. We consider the case
∃-left. The other case is similar and we leave it as an exercise. The new
quantiﬁer introduced must be bounded, since all formulas in  except ∃yϕ
are bounded, and the latter must occur on the right. Thus the inference
has the form
b ≤ r ∧ (b), Γ −→ Δ
∃x ≤ r (x), Γ −→ Δ

(20)

III.3. Conservative Extensions of IΔ0

49

where S is the bottom sequent. If Δ has no occurrence of ∃yϕ, then deﬁne
S  = S and let D(S) be the derivation (20). Otherwise, by the induction
hypothesis, the top sequent was converted to a sequent of the form
b ≤ r ∧ (b), Γ −→ Δ , ∃y ≤ s(b)ϕ(y).

(21)

Note that b may appear on the succedent and thus violate the Restriction
of the ∃-left rule (page 22).
In order to apply the ∃-left rule (and continue to satisfy the condition
(14)), we replace the bounding term s(b) by an LA -term t that does not
contain b. This is possible since the functions of T are polynomially
bounded in T . In particular, by Exercise III.2.1, we know that there are
LA -terms r  , s  (b) such that T proves both
r ≤ r

and

s(b) ≤ s  (b).

Let t = s  (r  ). Then by the monotonicity of LA -terms, T proves b ≤
r −→ s(b) ≤ t. Thus T proves
b ≤ r, ∃y ≤ s(b)ϕ(y) −→ ∃y ≤ tϕ(y)
(i.e., the above sequent has an LK-T derivation). From this and (21)
applying cut with cut formula ∃y ≤ s(b)ϕ we obtain
b ≤ r ∧ (b), Γ −→ Δ , ∃y ≤ tϕ(y)
where t does not contain b. We can now apply the ∃-left rule to obtain
∃x ≤ r (x), Γ −→ Δ , ∃y ≤ tϕ(y).

(22)

Let D(S) be this derivation and let S  be the resulting sequent (22).
Case IV. S results from a rule with two parents. Note that if this rule
is cut, then the cut formula cannot be ∃yϕ, because  is anchored. The
only diﬃculty in converting S is that the two consequents Δ and Δ of the
parent sequents may have been converted to consequents with diﬀerent
bounded formulas ∃y ≤ t1 ϕ and ∃y ≤ t2 ϕ. In this case proceed as in the
second part of Case I to combine these two formulas to the single formula
∃y ≤ (t1 + t2 )ϕ.
Case V. All remaining cases. The inference is of the form derive S
from the single sequent S1 . Then take S  to be the result of applying the
same rule in the same way to S1 , except in the case of contraction right
when the principle formula is ∃yϕ. In this case take S  = S1 .
2
Exercise III.2.8. Work out the sub-case ∀-right in Case III.

III.3. Conservative Extensions of IΔ0
In this section we occasionally present simple model-theoretic arguments, and the following standard deﬁnition from model theory is useful.

50

III. Peano Arithmetic and Its Subsystems

Deﬁnition III.3.1 (Expansion of a Model). Let L1 ⊆ L2 be vocabularies and let Mi be an Li structure for i = 1, 2. We say M2 is an
expansion of M1 if M1 and M2 have the same universe and the same
interpretation for symbols in L1 .
III.3.1. Introducing New Function and Predicate Symbols. In the following discussion we assume that all predicate and function symbols have
a standard interpretation in the set N of natural numbers. A theory T
which extends IΔ0 has deﬁning axioms for each predicate and function
symbol in its vocabulary which ensure that they receive their standard
interpretations in a model of T which is an expansion of the standard
model N. We often use the same notation for both the function symbol
and the function that it is intended to represent. For example, the predicate symbol P might be Prime, where Prime(x) is intended to mean that
x is a prime number. Or f might be LPD, where LPD(x) is intended to
mean the least prime number dividing x (or x if x ≤ 1).
Notation (unique existence). ∃!xϕ(x) stands for ∃x, ϕ(x)∧∀y(ϕ(y) ⊃
x = y), where y is a new variable not appearing in ϕ(x). ∃!x ≤ tϕ(x),
where t does not involve x, stands for
∃x ≤ t, ϕ(x) ∧ ∀y ≤ t(ϕ(y) ⊃ x = y)
where y is a new variable not appearing in ϕ(x) or t.
Deﬁnition III.3.2 (Deﬁnable Predicates and Functions). Let T be a
theory with vocabulary L, and let Φ be a set of L-formulas.
(a) We say that a predicate symbol P(x) not in L is Φ-deﬁnable in T if
there is an L-formula ϕ(x) in Φ such that
P(x) ↔ ϕ(x).

(23)

(b) We say that a function symbol f(x) not in L is Φ-deﬁnable in T if
there is a formula ϕ(x, y) in Φ such that
T  ∀x∃!yϕ(x, y),

(24)

y = f(x) ↔ ϕ(x, y).

(25)

and that
We say that (23) is a deﬁning axiom for P(x) and (25) is a deﬁning axiom
for f(x). We say that a symbol is deﬁnable in T if it is Φ-deﬁnable in T
for some Φ.
Although the choice of ϕ in the above deﬁnition is not uniquely determined by the predicate or function symbol, we will assume that a speciﬁc
ϕ has been chosen, so we will speak of the deﬁning axiom for the symbol.
For example, the deﬁning axiom for the predicate Prime(x) (in any
theory whose vocabulary contains LA ) might be
Prime(x) ↔ 1 < x ∧ ∀y < x∀z < x(y · z = x).

III.3. Conservative Extensions of IΔ0

51

Notation. Note that Δ0 and Σ1 (Deﬁnition III.1.7) are sets of LA formulas. In general, given a vocabulary L the sets Δ0 (L) and Σ1 (L) are
deﬁned as in Deﬁnition III.1.7 but the formulas are from L. In this case
we require that the terms bounding the quantiﬁers are LA -terms.
In Deﬁnition III.3.2, if Φ = Δ0 (L) (resp. Φ = Σ1 (L)) then we sometimes
omit mention of L and simply say that the symbols P, f are Δ0 -deﬁnable
(resp. Σ1 -deﬁnable) in T .
In the case of functions, the choice Φ = Σ1 (L) plays a special role. A
Σ1 -deﬁnable function in T is also called a provably total function in T . For
example one can show that the provably total functions of TA are precisely
all total computable functions. The provably total functions of IΣ1 are
precisely the primitive recursive functions, and of S21 (see Section III.5) the
polytime functions. In Section III.4 we will show that the provably total
functions of IΔ0 are precisely the functions of the Linear Time Hierarchy.
Exercise III.3.3. Suppose that the functions
f(x1 , . . . , xm ) and hi (x1 , . . . , xn ) (for 1 ≤ i ≤ m)
are Σ1 -deﬁnable in a theory T . Show that the function f(h1(x), . . . , hm (x))
(where x stands for x1 , . . . , xn ) is also Σ1 -deﬁnable in T . (In other words,
show that Σ1 -deﬁnable functions are closed under composition.)
Deﬁnition III.3.4 (Conservative Extension). Suppose that T1 and T2
are two theories, where T1 ⊆ T2 , and the vocabulary of T2 may contain
function or predicate symbols not in T1 . We say T2 is a conservative
extension of T1 if for every formula A in the vocabulary of T1 , if T2  A
then T1  A.
Theorem III.3.5 (Extension by Deﬁnition). If T2 results from T1 by expanding the vocabulary of T1 to include deﬁnable symbols, and by adding the
deﬁning axioms for these symbols, then T2 is a conservative extension of T1 .
Proof. We give a simple model-theoretic argument. Suppose that A
is a formula in the vocabulary of T1 and suppose that T2  A. Let M1
be a model of T1 . We expand M1 to a model M2 of T2 by interpreting
each new predicate and function symbol so that its deﬁning axiom (23) or
(25) is satisﬁed. Notice that this interpretation is uniquely determined by
the deﬁning axiom, and in the case of a function symbol the provability
condition (24) is needed (both existence and uniqueness of y) in order to
ensure that both directions of the equivalence (25) hold.
Since M2 is a model of T2 , it follows that M2 |= A, and hence M1 |= A.
2
Since M1 is an arbitrary model of T1 , it follows that T1  A.
Corollary III.3.6. Let T be a theory and T0 = T ⊂ T1 ⊂ · · · be a
sequence of extensions of T where each Tn+1 is obtained by adding to Tn
a deﬁnable
 symbol (in the vocabulary of Tn ) and its deﬁning axiom. Let
T∞ = n≥0 Tn . Then T∞ is a conservative extension of T .

52

III. Peano Arithmetic and Its Subsystems

Exercise III.3.7. Prove the corollary using the Extension by Deﬁnition
Theorem and the Compactness Theorem.
As an application of the Extension by Deﬁnition Theorem, we can
conservatively extend PA to include symbols for all the arithmetical predicates (i.e., predicates deﬁnable by LA -formulas). In fact, the extension of
PA remains conservative even if we allow induction on formulas over the
expanded vocabulary.
Similarly we can also obtain a conservative extension of IΔ0 by adding
to it predicate symbols and their deﬁning axioms for all arithmetical
predicates. However such a conservative extension of IΔ0 no longer proves
the induction axiom scheme on bounded formulas over the expanded
vocabulary. It does so if we only add Δ0 -deﬁnable symbols, and in fact we
may add both Δ0 -deﬁnable predicate and function symbols. To show this,
we start with the following important application of Parikh’s Theorem.
Theorem III.3.8 (Bounded Deﬁnability). Let T be a polynomial-bounded theory. A function f(x) (not in T ) is Σ1 -deﬁnable in T iﬀ it has a
deﬁning axiom
y = f(x) ↔ ϕ(x, y)
where ϕ is a bounded formula with all free variables indicated, and there is
an LA -term t = t(x) such that T proves ∀x∃!y ≤ tϕ(x, y).
Proof. The IF direction is immediate from Deﬁnition III.3.2. The
ONLY IF direction follows from the discussion after Parikh’s Theorem III.2.3.
2
Corollary III.3.9. If T is a polynomial-bounded theory, then a function
f is Σ1 -deﬁnable in T iﬀ f is Δ0 -deﬁnable in T .
From the above theorem we see that the function 2x is not Σ1 -deﬁnable
in any polynomial-bounded theory, even though we shall show in Section III.3.3 that the relation (y = 2x ) is Δ0 -deﬁnable in IΔ0 . Since the
function 2x is Σ1 -deﬁnable in PA, it follows that IΔ0  PA.
Lemma III.3.10 (Conservative Extension). Suppose that T is a polynomial-bounded theory and T + is the conservative extension of T obtained
by adding to T a Δ0 -deﬁnable predicate or a Σ1 -deﬁnable function symbol
and its deﬁning axiom. Then T + is a polynomial-bounded theory and
every bounded formula ϕ + in the vocabulary of T + can be translated into a
bounded formula ϕ in the vocabulary of T such that
T +  ϕ + ↔ ϕ.
The following corollary follows immediately from the lemma.
Corollary III.3.11. Let T and T + be as in the Conservative Extension
Lemma. Let L and L+ denote the vocabulary of T and T + , respectively.
Assume further that T proves the Δ0 (L)-IND axiom scheme. Then T +
proves the Δ0 (L+ )-IND axiom scheme.

III.3. Conservative Extensions of IΔ0

53

Proof of the Conservative Extension Lemma. First, suppose that
T + is obtained from T by adding to it a Δ0 -deﬁnable predicate symbol P
and its deﬁning axiom (23). That T + is polynomial-bounded is immediate
from Deﬁnition III.2.2. Now each bounded formula in the vocabulary
of T + can be translated to a bounded formula in the vocabulary of T
simply by replacing each occurrence of a formula of the form P(t) by ϕ(t)
(see the Formula Replacement Theorem, II.2.15). Note that the deﬁning
axiom (23) becomes the valid formula ϕ(x) ↔ ϕ(x).
Next suppose that T + is obtained from T by adding to it a Σ1 -deﬁnable
function symbol f and its deﬁning axiom (25). That T + is polynomialbounded follows from Theorem III.3.8.
Start translating ϕ + by replacing every bounded quantiﬁer ∀x ≤ u
by ∀x ≤ u  (x ≤ u ⊃ ), where u  is obtained from u by replacing every
occurrence of every function symbol other than +, · by its bounding term
in LA . Similarly replace ∃x ≤ u by ∃x ≤ u  (x ≤ u ∧ ).
Now we may suppose by Theorem III.3.8 that f has a bounded deﬁning
axiom
y = f(x) ↔ ϕ1 (x, y)
and f(x) has an LA bounding term t(x). Repeatedly remove occurrences
of f in an atomic formula (s(f(u))) by replacing this with
∃y ≤ t(u), ϕ1 (u, y) ∧ (s(y)).

2

Now we summarize the previous results.
Theorem III.3.12 (Conservative Extension). Let T0 be a polynomialbounded theory over a vocabulary L0 which proves the Δ0 (L0 )-IND axioms.
Let T0 ⊂ T1 ⊂ T2 ⊂ . . . be a sequence of extensions of T0 where each Ti+1
is obtained from Ti by adding a Σ1 -deﬁnable function symbol fi+1 (or a
Δ0 -deﬁnable predicate symbol Pi+1 ) and its deﬁning axiom. Let

T =
Ti .
i≥0

Then T is a polynomial-bounded theory and is a conservative extension of
T0 . Furthermore, if L is the vocabulary of T , then T proves the equivalence
of each Δ0 (L) formula with some Δ0 (L0 ) formula, and T  Δ0 (L)-IND.
Proof. First, we prove by induction on i that
1) Ti is a polynomial-bounded theory;
2) Ti is a conservative extension of T0 ; and
3) Ti proves that each Δ0 (Li ) formula is equivalent to some Δ0 (L0 )
formula, where Li is the vocabulary of Ti .
The induction step follows from the Conservative Extension Lemma.
It follows from the induction arguments above that T is a polynomialbounded theory, and that T proves the equivalence of each Δ0 (L) formula

54

III. Peano Arithmetic and Its Subsystems

with some Δ0 (L0 ) formula, and T  Δ0 (L)-IND. It follows from Corollary III.3.6 that T is a conservative extension of T0 .
2
III.3.2. IΔ0 : A Universal Conservative Extension of IΔ0 . (This subsection is not needed for the remainder of this chapter, but it is needed for
later chapters.)
We begin by introducing terminology that allows us to restate the Herbrand Theorem (see Section II.5).
A universal formula is a formula in prenex form (Deﬁnition II.5.11) in
which all quantiﬁers are universal. A universal theory is a theory which can
be axiomatized by universal formulas. Note that by deﬁnition (III.1.1),
a universal theory can be equivalently axiomatized by a set of quantiﬁerfree formulas, or by a set of ∀ sentences (Deﬁnition II.5.1). We can now
restate Form 2 of the Herbrand Theorem II.5.5 as follows.
Theorem III.3.13 (Herbrand Theorem, Form 2). Let T be a universal
theory, and let ϕ(x1 , . . . , xm , y) be a quantiﬁer-free formula with all free
variables indicated such that
T  ∀x1 . . . ∀xm ∃yϕ(x, y).

(26)

Then there exist ﬁnitely many terms t1 (x), . . . , tn (x) such that


T  ∀x1 . . . ∀xm ϕ(x, t1 (x)) ∨ · · · ∨ ϕ(x, tn (x)) .
Note that the theorem easily extends to the case where
T  ∀x1 . . . ∀xm ∃y1 . . . ∃yk ϕ(x, y)
instead of (26), where ϕ(x, y) is a quantiﬁer-free formula.
Proof. As we have remarked earlier, T can be axiomatized by a set Γ
of ∀ sentences. From (26) it follows that
Γ ∪ {∃x1 . . . ∃xm ∀y¬ϕ(x, y)}

(27)

is unsatisﬁable. Let c1 , . . . , cm be new constant symbols. Then it is easy
to check that (27) is unsatisﬁable if and only if
Γ ∪ {∀y¬ϕ(c, y)}
is unsatisﬁable. (We will need only the ONLY IF (=⇒) direction.)
Now by Form 1 (Theorem II.5.4), there are terms t1 (c), . . . , tn (c) such
that
Γ ∪ {¬ϕ(c, t1 (c)), . . . , ¬ϕ(c, tn (c))}
is unsatisﬁable. (We can assume that n ≥ 1, since n = 0 implies that Γ is
itself unsatisﬁable, and in that case the theorem is vacuously true.) Then
it follows easily that


2
T  ∀x1 . . . ∀xm ϕ(x, t1 (x)) ∨ · · · ∨ ϕ(x, tn (x)) .

III.3. Conservative Extensions of IΔ0

55

As stated, the Herbrand Theorem applies only to universal theories.
However every theory has a universal conservative extension, which can
be obtained by introducing “Skolem functions”. The idea is that these
functions explicitly witness the existence of existentially quantiﬁed variables. Thus we can replace each axiom (which contains ∃) of a theory T
by a universal axiom.
Lemma III.3.14. Suppose that (x) ≡ ∃yϕ(x, y) is an axiom of a theory
T . Let f be a new function symbol, and let T  be the theory over the extended
vocabulary with the same set of axioms as T except that (x) is replaced
by
ϕ(x, f(x)).
Then T  is a conservative extension of T .
The new function f is called a Skolem function.
Exercise III.3.15. Prove the above lemma by a simple model-theoretic
argument showing that every model of T can be expanded to a model of
T  . It may be helpful to assume that the vocabulary of T is countable,
so by the Löwenheim/Skolem Theorem (Theorem II.4.1) we may restrict
attention to countable models.
By the lemma, for each axiom of T we can successively eliminate the
existential quantiﬁers, starting from the outermost quantiﬁer, using the
Skolem functions. It follows that every theory has a universal conservative
extension. For example, we can obtain a universal conservative extension
of IΔ0 by introducing Skolem functions for every instance of the Δ0 -IND
axiom scheme. Let ϕ(z) be a Δ0 formula (possibly with other free variables
x). Then the induction scheme for ϕ(z) can be written as


∀x∀z ϕ(z) ∨ ¬ϕ(0) ∨ ∃y(ϕ(y) ∧ ¬ϕ(y + 1)) .
Consider the simple case where ϕ is an open formula. The single Skolem
function (as a function of x, z) for the above formula is required to “witness” the existence of y (in case such a y exists).
Although the Skolem functions witness the existence of existentially
quantiﬁed variables, it is not speciﬁed which values they take (and in
general there may be many diﬀerent values). Here we can construct a
universal conservative extension of IΔ0 by explicitly taking the smallest
values of the witnesses if they exist. Using the least number principle
(Deﬁnition III.1.13), these functions are indeed deﬁnable in IΔ0 .
Let ϕ(z) be an open formula (possibly with other free variables), and
t a term. Let x be the list of all variables of t and other free variables of
ϕ(z) (thus x may contain z if t does). Let fϕ(z),t (x) be the least y < t
such that ϕ(y) holds, or t if no such y exists. Then fϕ(z),t is total and can
be deﬁned as follows (we assume that y, v do not appear in x):


(28)
y = fϕ(z),t (x) ↔ y ≤ t ∧ (y < t ⊃ ϕ(y)) ∧ ∀v < y¬ϕ(v) .

56

III. Peano Arithmetic and Its Subsystems

Note that (28) contains an implicit existential quantiﬁer ∃v (consider
the direction ←). Our universal theory will contain the following equivalent axiom instead:

 

f(x) ≤ t ∧ f(x) < t ⊃ ϕ(f(x)) ∧ v < f(x) ⊃ ¬ϕ(v)
(29)
(here f = fϕ(z),t ).
A consequence of (29) is
∃z ≤ tϕ(z) ↔ ϕ(fϕ(z),t (x))
so introduction of the function symbols fϕ(z),t allows us to eliminate
bounded quantiﬁers (Lemma III.3.19).
Although the predecessor function pd(x) can be deﬁned by a formula
of the form (29), we will use the following two recursive deﬁning axioms
instead.
D1 . pd(0) = 0;
D1 . x = 0 ⊃ pd(x) + 1 = x.
Note that D1 implies D1 (see Example III.1.9), and D1 is needed to
deﬁne pd(0).
We are now ready to deﬁne the vocabulary LΔ0 of the universal theory IΔ0 . This vocabulary has a function symbol for every Δ0 -deﬁnable
function in IΔ0 .
Deﬁnition III.3.16 (LΔ0 ). Let LΔ0 be the smallest set that satisﬁes
1) LΔ0 includes LA ∪ {pd};
2) For each open LΔ0 -formula ϕ(z) and LA -term t there is a function
fϕ(z),t in LΔ0 .
Note that LΔ0 can be alternatively deﬁned as follows. Let
L0 = LA ∪ {pd},
for n ≥ 0: Ln+1 = Ln ∪ {fϕ(z),t : ϕ(z) is an open Ln -formula,
t is an LA -term}.
Then
LΔ0 =



Ln .

n≥0

Our universal theory IΔ0 requires two more axioms in the style of
1-BASIC.
B8 . 0 ≤ x;
B8 . x < x + 1.
Deﬁnition III.3.17 (IΔ0 ). Let IΔ0 be the theory over LΔ0 with the following set of axioms: B1, . . . , B8, B8 , B8 , D1 , D1 and (29) for each
function fϕ(z),t of LΔ0 .

III.3. Conservative Extensions of IΔ0

57

Thus IΔ0 is a universal theory. Note that there is no induction scheme
among its axioms. Nevertheless we show below that IΔ0 proves the
Δ0 -IND axiom scheme, and hence IΔ0 extends IΔ0 . From this it is easy to
verify that IΔ0 is a polynomial-bounded theory.
Theorem III.3.18. IΔ0 is a conservative extension of IΔ0 .
To show that IΔ0 extends IΔ0 we show that it proves the Δ0 -IND axiom scheme. Note that if the functions of LΔ0 receive their intended
meaning, then every bounded LA -formula is equivalent to an open LΔ0 formula. Therefore, roughly speaking, the Δ0 -MIN (and thus Δ0 -IND)
axiom scheme is satisﬁed by considering the appropriate functions of LΔ0 .
Lemma III.3.19. For each Δ0 (LA ) formula ϕ, there is an open LΔ0 formula ϕ  such that IΔ0  ϕ ↔ ϕ  .
Proof. We use structural induction on ϕ. The only interesting cases
are for bounded quantiﬁers. It suﬃces to consider the case when ϕ is
∃y ≤ t (y). Then take ϕ  to be  (f  ,t (x)). It is easy to check that
IΔ0  ϕ ↔ ϕ  using (29). No properties of ≤ and < are needed for this
implication except the deﬁnition y < f(x) stands for (y ≤ f(x) ∧ y =
f(x)).
2
Proof of Theorem III.3.18. First we show that IΔ0 is an extension of
IΔ0 , i.e., Δ0 -IND is provable in IΔ0 .
By the above lemma, it suﬃces to show that IΔ0 proves the Induction
axiom scheme for open LΔ0 -formulas. Let ϕ(x, z) be any open LΔ0 formula. We need to show that (omitting x)
IΔ0  (ϕ(0) ∧ ¬ϕ(z)) ⊃ ∃y(ϕ(y) ∧ ¬ϕ(y + 1)).
Assuming (ϕ(0) ∧ ¬ϕ(z)), we show in IΔ0 that (ϕ(y) ∧ ¬ϕ(y + 1)) holds
for y = pd(f¬ϕ,z (x, z)), using (29). We need to be careful when arguing
about ≤, because the properties O1–O9 and D1–D10 which we have been
using for reasoning in IΔ0 require induction to prove.
First we rewrite (29) for the case f is f¬ϕ,z .

 

f(x, z) ≤ z ∧ f(x, z) < z ⊃ ¬ϕ(f(x, z)) ∧ v < f(x, z) ⊃ ϕ(v) .
(30)
Now 0 < z by B8 and our assumptions ϕ(0) and ¬ϕ(z), so f(x, z) = 0
by (30). Hence y + 1 = pd(f(x, z)) + 1 = f(x, z) by D1 . Therefore
¬ϕ(y + 1) by (30) and the assumption ¬ϕ(z).
To establish ϕ(y) it suﬃces by (30) to show y < f(x, z). This holds
because f(x, z) = y + 1 as shown above, and y < y + 1 by B8 .
This completes the proof that IΔ0 extends IΔ0 . Next, we show that IΔ0
is conservative over IΔ0 . Let f1 = pd, f2 , f3 , . . . be an enumeration of
LΔ0 \ LA such that for n ≥ 1, fn+1 is deﬁned using some LA -term t and
(LA ∪ {f1 , . . . , fn })-formula ϕ as in (29).

58

III. Peano Arithmetic and Its Subsystems

For n ≥ 0 let Ln denote LA ∪ {f1 , . . . , fn }. Let T0 = IΔ0 , and for n ≥ 0
let Tn+1 be the theory over Ln+1 which is obtained from Tn by adding the
deﬁning axiom for fn+1 (in particular, T1 is axiomatized by IΔ0 and D1 ,
D1 ). Then

and
IΔ0 =
Tn .
T0 = IΔ0 ⊂ T1 ⊂ T2 ⊂ · · ·
n≥0

By Corollary III.3.6, it suﬃces to show that for each n ≥ 0, fn+1 is
deﬁnable in Tn . In fact, we prove the following by induction on n ≥ 0:
1) Tn proves the Δ0 (Ln )-IND axiom scheme;
2) fn+1 is Δ0 (Ln )-deﬁnable in Tn .
Consider the induction step. Suppose that the hypothesis is true for n
(n ≥ 0). We prove it for n + 1. By the induction hypothesis, Tn proves
the Δ0 (Ln )-IND axiom scheme and Δ0 (Ln )-deﬁnes fn+1 . Therefore by
Corollary III.3.11, Tn+1 proves the Δ0 (Ln+1 )-IND axiom scheme. Consequently, Tn+1 also proves the Δ0 (Ln+1 )-MIN axiom scheme. The deﬁning
equation for fn+2 has the form (29), and hence Tn+1 proves (28) where f
is fn+2 . Thus (28) is a deﬁning axiom which shows that fn+2 is Δ0 (Ln+1 )deﬁnable in Tn+1 . Here we use the Δ0 (Ln+1 )-MIN axiom scheme to prove
∃y in (24).
2
III.3.2.1. An alternative proof of Parikh’s Theorem for IΔ0 . Now we will
present an alternative proof of Parikh’s Theorem for IΔ0 from Herbrand
Theorem applied to IΔ0 , using the fact that IΔ0 is a conservative extension
of IΔ0 .
In proving that IΔ0 is conservative over IΔ0 (see the proof of Theorem III.3.18), in the induction step we have used Corollary III.3.11
(the case of adding Σ1 -deﬁnable function) to show that Tn proves the
Δ0 (Ln )-IND axiom scheme. The proof of Corollary III.3.11 (and of the
Conservative Extension Lemma) in turn relies on the Bounded Deﬁnability Theorem III.3.8, which is proved using Parikh’s Theorem. However,
for IΔ0 , the function fn+1 in the induction step in the proof of Theorem III.3.18 is already Δ0 -deﬁnable in Tn and comes with a bounding term
t. Therefore we have actually used only a simple case of Corollary III.3.11
(i.e., adding Δ0 -deﬁnable functions with bounding terms). Thus in fact
Parikh’s Theorem is not necessary in proving Theorem III.3.18.
Proof of Parikh’s Theorem. Suppose that ∀x∃yϕ(x, y) is a theorem
of IΔ0 , where ϕ is a bounded formula. We will show that there is an
LA -term s such that
IΔ0  ∀x∃y ≤ sϕ(x, y).
By Lemma III.3.19, there is an open LΔ0 -formula ϕ  (x, y) such that
IΔ0  ∀x∀y(ϕ(x, y) ↔ ϕ  (x, y)).

III.3. Conservative Extensions of IΔ0

59

Then since IΔ0 extends IΔ0 , it follows that
IΔ0  ∀x∃yϕ  (x, y).
Now since IΔ0 is a universal theory, by Form 2 of the Herbrand Theorem III.3.13 there are LΔ0 -terms t1 , . . . , tn such that


IΔ0  ∀x ϕ  (x, t1 (x)) ∨ · · · ∨ ϕ  (x, tn (x)) .
(31)
Also since IΔ0 is a polynomial-bounded theory, there is an LA -term s such
that
IΔ0  ti (x) < s(x)
for all i, 1 ≤ i ≤ n.
Consequently,
IΔ0  ∀x∃y < sϕ  (x, y).
Hence
IΔ0  ∀x∃y < sϕ(x, y).
By the fact that IΔ0 is conservative over IΔ0 we have
IΔ0  ∀x∃y < sϕ(x, y).

2

Note that we have proved more than a bound on the existential quantiﬁer ∃y. In fact, (31) allows us to explicitly deﬁne a Skolem function
y = f(x), using deﬁnition by cases. This idea will serve as a method for
proving witnessing theorems in future chapters.
III.3.3. Deﬁning y = 2x and BIT(i, x) in IΔ0 . In this subsection we
show that the relation BIT(i, x) is Δ0 -deﬁnable in IΔ0 , where BIT(i, x)
holds iﬀ the i-th bit in the binary notation for x is 1. This is useful
particularly in Section III.4 where we show that IΔ0 characterizes the
Linear Time Hierarchy.
In order to deﬁne BIT we will show that the relation y = 2x is Δ0 deﬁnable in IΔ0 . On the other hand, by Parikh’s Theorem III.2.3, the
function f(x) = 2x is not Σ1 -deﬁnable in IΔ0 , because it grows faster than
any polynomial.
Our method is to introduce a sequence of new function and predicate
symbols, and show that each can be Δ0 -deﬁned in IΔ0 extended by the
previous symbols. These new symbols together with their deﬁning axioms
determine a sequence of conservative extensions of IΔ0 , and according to
the Conservative Extension Theorem III.3.12, bounded formulas using the
new symbols are provably equivalent to bounded formulas in the vocabulary LA of IΔ0 , and hence the induction scheme is available on bounded
formulas with the new symbols. Finally the bounded formula ϕexp (x, y)
given in (34) deﬁnes (y = 2x ), and the bounded formula BIT(i, x) given
in (35) deﬁnes the BIT predicate. These formulas are provably equivalent to bounded formulas in IΔ0 , and IΔ0 proves the properties of their
translations, such as those in Exercise III.3.28.

60

III. Peano Arithmetic and Its Subsystems

·
We start by Δ
√0 -deﬁning the following functions in· IΔ0 : x − y, x/y,
x mod y and  x. We will show in detail that x − y is Δ0 -deﬁnable in
IΔ0 . A detailed proof for other functions is left as an exercise. It might be
helpful to revisit the basic properties O1, . . . , O10, D1, . . . , D10 of IΔ0
in Examples III.1.8, III.1.9.
·
1) Limited subtraction. The function x −
y = max{0, x − y} can be
deﬁned by


z = x −· y ↔ (y + z = x) ∨ (x ≤ y ∧ z = 0) .

In order to show that IΔ0 can Δ0 -deﬁne this function we must show
that
IΔ0  ∀x∀y∃!zϕ(x, y, z)
where ϕ is the RHS of the above equivalence (see Deﬁnition III.3.2
(b)).
For the existence of z, by D2 we know that there is some z  such
that
x + z  = y ∨ y + z  = x.
If y + z  = x then simply take z = z  . Otherwise x + z  = y, then
by B8, x ≤ x + z  , hence x ≤ y, and thus we can take z = 0.
For the uniqueness of z, ﬁrst suppose that x ≤ y. Then we have to
show that y + z = x ⊃ z = 0. Assume y + z = x. By B8, y ≤ y + z,
hence y ≤ x. Therefore x = y by B7. Now from x + 0 = x (B3)
and x + z = x we have z = 0, by O2 (Commutativity of +) and O6
(Cancellation law for +).
Next, suppose that ¬(x ≤ y). Then y + z = x, and by O2 and
O6, y + z = x ∧ y + z  = x ⊃ z = z  .
2) Division. The function x div y = x/y can be deﬁned by


z = x/y ↔ (y · z ≤ x ∧ x < y · (z + 1)) ∨ (y = 0 ∧ z = 0) .
The existence of z is proved by induction on x. The uniqueness of z
follows from transitivity of ≤ (D4), Total Order (D5), and O5, D7.
3) Remainder. The function x mod y can be deﬁned by
·
(y · x/y).
x mod y = x −

Since x mod y is a composition of Σ1 -deﬁnable functions, it is Σ1 deﬁnable by Exercise III.3.3. Hence it is Δ0 -deﬁnable by Corollary III.3.9.
4) Square root.


√
y =  x ↔ y · y ≤ x ∧ x < (y + 1)(y + 1) .
The existence of y follows from the least number principle. The
uniqueness of y follows from Transitivity of ≤ (D4), Total Order
(D5), and O5, D7.

61

III.3. Conservative Extensions of IΔ0
√

Exercise III.3.20. Show carefully that the functions x/y and  x
are Δ0 -deﬁnable in IΔ0 .
Next we deﬁne the following relations x|y, Pow2(x), Pow4(x) and
LenBit(y, x):
5) Divisibility. This relation is deﬁned by
x|y ↔ ∃z ≤ y(x · z = y).
6) Powers of 2 and 4.
x is a power of 2:


Pow2(x) ↔ x = 0 ∧ ∀y ≤ x((1 < y ∧ y|x) ⊃ 2|y) ,
x is a power of 4: Pow4(x) ↔ (Pow2(x) ∧ x mod 3 = 1).
7) LenBit. We want the relation LenBit(2i , x) to hold iﬀ the i-th bit in
the binary expansion of x is 1, where the least signiﬁcant bit is bit 0.
Although we cannot yet deﬁne y = 2i , we can deﬁne
LenBit(y, x) ↔ (x/y mod 2 = 1).
Note that we intend to use LenBit(y, x) only when y is a power of
2, but it is deﬁned for all values of y.
Notation. (∀2i ) stands for “for all powers of 2”, i.e.,
(∀2i ) A(2i ) stands for ∀x (Pow2(x) ⊃ A(x)),
(∀2i ≤ t) A(2i ) stands for ∀x ((Pow2(x) ∧ x ≤ t) ⊃ A(x)).
Same for (∃2i ) and (∃2i ≤ t).
Exercise III.3.21. Show that the following are theorems of IΔ0 :
(a) Pow2(x) ↔ Pow2(2x).
(b) (∀2i )(∀2j )(2i < 2j ⊃ 2i |2j ). (Hint: using strong induction (12).)
(c) (∀2i )(∀2j ≤ 2i ) Pow2(2i /2j ).
(d) (∀2i )(∀2j )(2i < 2j ⊃ 2 · 2i ≤ 2j ).
(e) (∀2i )(∀2j ) Pow2(2i · 2j ).
(f) (∀2i )(∃2j ≤ 2i ) ((2j )2 = 2i ∨ 2(2j )2 = 2i )).
We also need the following function:
8) Greatest power of 2 less than or equal to x.
y = gp(x) ↔
((x = 0 ∧ y = 0) ∨ (Pow2(y) ∧ y ≤ x ∧ (∀2i ≤ x) 2i ≤ y)).
Exercise III.3.22. Show that IΔ0 can Δ0 -deﬁne gp(x). (Hint: Use
induction on x.)
Exercise III.3.23. Prove the following in IΔ0 :
(a) x > 0 ⊃ (gp(x) ≤ x < 2gp(x)).
(b) x > 0 ⊃ LenBit(gp(x), x).

62

III. Peano Arithmetic and Its Subsystems

·
gp(x) ⊃ (∀2i ≤ y) (LenBit(2i , y) ↔ LenBit(2i , x)).
(c) y = x −

It is a theorem of IΔ0 that the binary representation of a number
uniquely determines the number. This theorem can be proved in IΔ0
by using strong induction (12) and part (c) of the above exercise. Details
are left as an exercise.
Theorem III.3.24.
IΔ0  ∀y∀x < y(∃2i ≤ y)(LenBit(2i , y) ∧ ¬LenBit(2i , x)).
Exercise III.3.25. Prove the above theorem.
III.3.3.1. Deﬁning the Relation y = 2x . This is much more diﬃcult to
Δ0 -deﬁne than any of the previous relations and functions. A ﬁrst attempt
to deﬁne y = 2x might be to assert the existence of a number s coding the
sequence 20 , 21 , . . . , 2x . The main diﬃculty in this attempt is that the
number of bits in s is Ω(|y|2 ) (where |y| is the number of bits in y), and
so s cannot be bounded by any IΔ0 term in x and y.
We get around this by coding a much shorter sequence, of length |x|
instead of length x, of numbers of the form 2z . Suppose that x > 0, and
(xk−1 . . . x0 )2 is the binary representation of x (where xk−1 = 1), i.e.,
k−1

xi 2 i

x=

(and xk−1 = 1).

i=0

We start by coding the sequence a1 , a2 , . . . , ak , where ai consists of
the ﬁrst i high-order bits of x, so ak = x. Then we code the sequence
b1 , . . . , bk , where bi = 2ai , so y = bk .
We have (note that xk−1 = 1):
b1 = 2.

a1 = 1,

For 1 ≤ i < k: ai+1 = xk−i−1 + 2ai ,

bi+1 = 2xk−i−1 bi2 .

(32)

i

Note that ai < 2i and bi < 22 for 1 ≤ i ≤ k.
We will code the sequences a1 , . . . , ak  and b1 , . . . , bk  by the numbers
a and b, respectively, such that ai and bi are represented by the bits 2i to
2i+1 − 1 of a and b, respectively. In order to extract ai and bi from a and
b we use the function
ext(u, z) = z/u mod u.
i

(33)

Thus if u = 22 then ai = ext(u, a) and bi = ext(u, b). It is easy to see
that the function ext is Δ0 -deﬁnable in IΔ0 .
k+1
k−1
Note that a, b < 22 , and y ≥ 22 . Hence the numbers a and b
can be bounded by a, b < y 4 . Below we will explain how to express the
i
condition that a number has the form 22 . Once this is done, we can

63

III.3. Conservative Extensions of IΔ0
express
y = 2x ↔ ϕexp (x, y)

where ϕexp ≡ (x = 0 ∧ y = 1) ∨
∃a, b < y 4

exp (x, y, a, b)

(34)

and exp (x, y, a, b) is the formula stating that the following conditions
(expressing the above recurrences) hold, for x > 0, y > 1:
1

1

1) ext(22 , a) = 1, and ext(22 , b) = 2.
1
i
2) For all u, 22 ≤ u ≤ y of the form 22 , either
(a) ext(u 2 , a) = 2ext(u, a) and ext(u 2 , b) = (ext(u, b))2 , or
(b) ext(u 2 , a) = 1 + 2ext(u, a) and ext(u 2 , b) = 2(ext(u, b))2 .
i
3) There is u ≤ y 2 of the form 22 such that ext(u, a) = x and
ext(u, b) = y.
Note that condition (2)(a) holds if xk−i = 0, and condition (2)(b)
holds if xk−i = 1. The conditions do not need to mention xk−i explicitly,
because condition (3) ensures that ai = x for some i, so all bits of x must
have been chosen correctly up to this point.
i
It remains to express “x has the form 22 ”. First, the set of numbers of
the form


22

m =

i

i=0

can be Δ0 -deﬁned by the formula
ϕp (x) ≡ ¬LenBit(1, x) ∧ LenBit(2, x) ∧ ∀2i ≤ x, 2 < 2i ⊃
√
(LenBit(2i , x) ↔ (Pow4(2i ) ∧ LenBit( 2i , x))).
i

From this we can Δ0 -deﬁne numbers of the form x = 22 as the powers of
2 for which LenBit(x, m ) holds for some m < 2x:
i

x is of form 22 : PPow2(x) ↔ Pow2(x) ∧ ∃m < 2x (ϕp (m) ∧
LenBit(x, m)).
This completes our description of the deﬁning axiom ϕexp (x, y) for the
relation y = 2x . It remains to show that IΔ0 proves some properties of
this relation. First we need to verify in IΔ0 the properties of PPow2.
Exercise III.3.26. The following are theorems of IΔ0 :
(a) PPow2(z) ↔ PPow2(z 2 ).

2

(b) (PPow2(z) ∧ PPow2(z  ) ∧
√ z <2 z ) ⊃ z ≤ z .
(c) (PPow2(x) ∧ 4 ≤ x) ⊃  x = x.
i

We have noted earlier that ai < 2i and bi < 22 . Here we need to show
that these are indeed provable in IΔ0 . We will need this fact in order to
prove (in IΔ0 ) the correctness of our deﬁning axiom ϕexp for the relation
y = 2x (e.g., Exercise III.3.28 (c) and (d)).

64

III. Peano Arithmetic and Its Subsystems

Exercise III.3.27. Assuming (y > 1∧

exp (x, y, a, b)), show in IΔ0 that

(a) ∀u ≤ y , (PPow2(u) ∧ 4 ≤ u) ⊃ 1 + ext(u, a) < u.
(b) ∀u ≤ y 2 , (PPow2(u) ∧ 4 ≤ u) ⊃ 2ext(u, b) ≤ u.
2

Exercise III.3.28. Show that IΔ0 proves the following:
(a) ϕexp (x, y) ⊃ Pow2(y).
(b) Pow2(y) ⊃ ∃x < y ϕexp (x, y). (Hint: strong induction on y, using
Exercise III.3.21 (f).)
(c) ϕexp (x, y1 ) ∧ ϕexp (x, y2 ) ⊃ y1 = y2 .
(d) ϕexp (x1 , y) ∧ ϕexp (x2 , y) ⊃ x1 = x2 .
(e) ϕexp (x + 1, 2y) ↔ ϕexp (x, y). (Hint: Look at the least signiﬁcant 0
bit of x.)
(f) ϕexp (x1 , y1 ) ∧ ϕexp (x2 , y2 ) ⊃ ϕexp (x1 + x2 , y1 · y2 ). (Hint: Induction
on y2 .)
Although the function 2x is not Δ0 -deﬁnable in IΔ0 , it is easy to see
using ϕexp (and useful to know) that the function
Exp(x, y) = min(2x , y)
is Δ0 -deﬁnable in IΔ0 .
Exercise III.3.29. The relation y = z x can be deﬁned using the same
techniques that have been used to deﬁne the relation y = 2x . Here the
sequence b1 , . . . , bk  needs to be modiﬁed.
(a) Modify the recurrence in (32).
Each bi now may not ﬁt in the bits 2i to 2i+1 − 1 of b, but it ﬁts in a bigger
segment of b. Let  be the least number such that


z ≤ 22 .
+i

(b) Show that for 1 ≤ i ≤ k, zbi ≤ 22 .
(c) Show that the function lpp(z), which is the least number of the form
i
22 that is ≥ z, is Δ0 -deﬁnable in IΔ0 .
(d) Show that IΔ0  z > 1 ⊃ (z ≤ lpp(z) < z 2 ).
(e) What are the bounds on the values of the numbers a and b that
respectively code the sequences a1 , . . . , ak  and b1 , . . . , bk ?
(f) Give a formula that deﬁnes the relation y = z x by modifying the
conditions 1–3.
III.3.3.2. The BIT and NUMONES Relations. The relation BIT(i, x)
can be deﬁned as follows, where BIT(i, x) holds iﬀ the i-th bit (i.e.,
coeﬃcient of 2i ) of the binary notation for x is 1:
BIT(i, x) ↔ ∃z ≤ x(z = 2i ∧ LenBit(z, x)).

(35)

Exercise III.3.30. Show that the length function, |x| = log2 (x + 1),
is Δ0 -deﬁnable in IΔ0 .

III.4. IΔ0 and the Linear Time Hierarchy

65

Lemma III.3.31. The relation NUMONES(x, y), asserting that y is the
number of one-bits in the binary notation for x, is Δ0 -deﬁnable.
Proof sketch. We code a sequence s0 , s1 , . . . , sn  of numbers si of at
most  bits each using a number s such that bits i to i +  − 1 of s are
the bits of si . Then we can extract si from s using the equation
si = s/2i  mod 2 .
Our ﬁrst attempt to deﬁne NUMONES(x, y) might be to state the existence of a sequence s0 , s1 , . . . , sn , where n = |x|, si is the number of ones
in the ﬁrst i bits of x, and  = ||x||. However the number coding this
sequence has n log n bits, which is too many.
We get around this problem using “Bennett’s Trick” [15], which is to
state the existence of a sparse subsequence of s0 , s1 , . . . , sn  and assert
that adjacent pairs in the subsequence can be ﬁlled in. Thus

NUMONES(x, y) ↔ ∃m ≤ |x| |x| ≤ m 2 ∧

∃t0 , . . . , tm  t0 = 0 ∧ tm = y ∧ ∀i < m∃u0 , . . . , um (u0 = ti ∧

um = ti+1 ∧ ∀j < m(uj+1 = uj + FBIT(im + j, x)))
where the function FBIT(i, x) is bit i of x.

2

III.4. IΔ0 and the Linear Time Hierarchy
III.4.1. The Polynomial and Linear Time Hierarchies. An element of
a complexity class such as P (polynomial time) is often taken to be a
vocabulary L, where L is a set of ﬁnite strings over some ﬁxed ﬁnite
alphabet Σ. In the context of bounded arithmetic, it is convenient to
consider elements of P to be subsets of N, or more generally relations
over N, and in this case it is assumed that numbers are presented in
binary notation to the accepting machine. In this context, the notation
Σp0 is sometimes used for polynomial time. Thus Σp0 = P is the set of
all relations R(x1 , . . . , xk ), k ≥ 1 over N such that some polynomial time
Turing machine MR , given input x1 , . . . , xk (k numbers in binary notation
separated by blanks) determines whether R(x1 , . . . , xk ) holds.
The class Σp0 has a generalization to Σpi , i ≥ 0, which is the i-th level
of the polynomial-time hierarchy. This can be deﬁned inductively by the
recurrence
p
Σpi+1 = NPΣi
p

where NPΣi is the set of relations accepted by a nondeterministic polynomial time Turing machine which has access to an oracle in Σpi .
For i ≥ 1, Σpi can be characterized as the set of relations accepted by
some alternating Turing machine (ATM) in polynomial time, making at

66

III. Peano Arithmetic and Its Subsystems

most i alternations, beginning with an existential state. In any case,
Σp1 = NP.
We deﬁne the polynomial time hierarchy by
PH =

∞


p

Σi .

i=0

In the context of IΔ0 , we are interested in the Linear Time Hierarchy
(LTH), which is deﬁned analogously to PH. We use NLinTime to denote
time O(n) on a nondeterministic multi-tape Turing machine. Then
Σlin
1 = NLinTime

(36)

and for i ≥ 1
lin

Σi
Σlin
.
i+1 = NLinTime

(37)

Alternatively, we can deﬁne Σlin
i to be the relations accepted in linear time
on an ATM with i alternations, beginning with an existential state. In
either case,2
∞

LTH =
Σlin
i .
i=1

LinTime is not as robust a class as polynomial time; for example it is
plausible that a k + 1-tape deterministic linear time Turing machine can
accept sets not accepted by any k tape such machine, and linear time
Random Access Machines may accept sets not in LinTime. However it is
not hard to see that NLinTime is more robust, in the sense that every set
in this class can be accepted by a two tape nondeterministic linear time
Turing machine.
III.4.2. Representability of LTH Relations. Recall the deﬁnition of deﬁnable predicates and functions (Deﬁnition III.3.2). If Φ is a class of
L-formulas, T a theory over L, and R a Φ-deﬁnable relation (over the
natural numbers) in T , then we simply say that R is Φ-deﬁnable (or
Φ-representable).
Thus when Φ is a class of LA -formulas, a k-ary relation R over the
natural numbers is Φ-deﬁnable if there is a formula ϕ(x1 , . . . , xk ) ∈ Φ
such that for all (n1 , . . . , nk ) ∈ Nk ,
(n1 , . . . , nk ) ∈ R

iﬀ

N |= ϕ(n1 , . . . , nk ).

(38)

More generally, if Φ is a class of L-formulas for some vocabulary L
extending LA , then instead of N we will take the expansion of N where the
extra symbols in L have their intended meaning.
2 LTH is diﬀerent from LH, the logtime-hierarchy discussed in Section IV.1.

III.4. IΔ0 and the Linear Time Hierarchy

67

(Note that a relation R(x) is sometimes called representable (or weakly
representable) in a theory T if there is some formula ϕ(x) so that for all
n ∈ N,
R(n)
iﬀ
T  ϕ(n).
Our notation here is the special case where T = TA.)
For example, the class of Σ1 -representable sets (i.e., unary relations)
is precisely the class of r.e. sets. In the context of Buss’s S2i hierarchy
(Section III.5), NP relations are precisely the Σb1 -representable relations.
(Σb1 is deﬁned for the vocabulary LS2 of S2 .) Here we show that the LTH
relations are exactly the Δ0 -representable relations.
Deﬁnition III.4.1. ΔN
0 is the class of Δ0 -representable relations.
For instance, we have shown that the relations BIT and NUMONES
are in ΔN
0 . So is the relation Prime(x) (x is a prime number), because
Prime(x) ≡ 1 < x ∧ ∀y < x∀z < x(y · z = x).
Theorem III.4.2 (LTH Theorem). LTH = ΔN
0.
Proof sketch. First consider the inclusion LTH ⊆ ΔN
0 . This can be
done using the recurrence (36), (37). The hard part here is the base case,
showing NLinTime ⊆ ΔN
0 . Once this is done we can show the induction
step by, given a nondeterministic linear time oracle Turing machine M ,
deﬁning the relation RM (x, y, b) to assert “M accepts input x, assuming
that it makes the sequence of oracle queries coded by y, and the answers
to those queries are coded by b.” This relation RM is accepted by some
nondeterministic linear time Turing machine (with no oracle), and hence
it is in ΔN
0 by the base case.
To show NLinTime ⊆ ΔN
0 we need to represent the computation of a
nondeterministic linear time Turing machine by a constant number k of
strings x1 , . . . , xk of linear length. One string will code the sequence of
states of the computation, and for each tape there is a string coding the
sequence of symbols printed and another string coding the head moves.
In order to check that the computation is correctly encoded it is necessary
to deduce the position of each tape head at each step of the computation,
from the sequence of head moves. This can be done by counting the number of left shifts and of right shifts, using the relation NUMONES(x, y),
and subtracting. It is also necessary to determine the symbol appearing
on a given tape square at a given step, and this can be done by determining
the last time that the head printed a symbol on that square.
We prove the inclusion ΔN
0 ⊆ LTH by structural induction on Δ0 formulas. The induction step is easy, since bounded quantiﬁers correspond
to ∃ and ∀ states in an ATM. The only interesting case is one of the base
cases: the atomic formula x · y = z. To show that this relation R(x, y, z)
is in LTH we use Corollary III.4.5 below which shows that L ⊆ LTH.
(L is the class of relations computable in logarithmic space using Turing

68

III. Peano Arithmetic and Its Subsystems

machines. See Appendix A.1.1.) It is not hard to see that using the school
algorithm for multiplication the relation x · y = z can be checked in space
O(log n), and thus it is in L.
2
Exercise III.4.3. Give more details of the proof showing LTH ⊆ ΔN
0.
Theorem III.4.4 (Nepomnjaščij’s Theorem). Let  be a rational number, 0 <  < 1, and let a be a positive integer. Then
NTimeSpace(n a , n  ) ⊆ LTH.
In the above, NTimeSpace(f(n), g(n)) consists of all relations accepted
simultaneously in time O(f(n)) and space O(g(n)) on a nondeterministic
multi-tape Turing machine.
Proof Idea. We use Bennett’s Trick, as in the proof of Lemma III.3.31.
Suppose we want to show
NTimeSpace(n 2 , n 0.6 ) ⊆ LTH.
Let M be a nondeterministic TM running in time n2 and space n 0.6 . Then
M accepts an input x iﬀ
∃y(y represents an accepting computation for x).
Here y = y1 , . . . , yn 2 , where each yi is a string of length n 0.6 representing
a conﬁguration of M . The total length of y is |y| = n 2.6 , which is too long
for an ATM to guess in linear time.
So we guess a vector z = z1 , . . . , zn representing every n-th string in y,
so now M accepts x iﬀ
∃z∀i < n∃u(u shows zi+1 follows from zi in n steps and zn is accepting).
Now the lengths of z and u are only n 1.6 , and we have made progress. Two
more iterations of this idea (one for the ∃y, one for the ∃u; increasing the
nesting depth of quantiﬁers) will get the lengths of the quantiﬁed strings
below linear.
2
For the following corollary, NL is the class of relations computable by
nondeterministic Turing machines in logarithmic space. See Appendix A.2.
Corollary III.4.5. NL ⊆ LTH.
2
Proof. We use the fact that NL ⊆ NTimeSpace(n O(1) , log n).
Remark. We know
L ⊆ LTH ⊆ PH ⊆ PSPACE
where no two adjacent inclusions are known to be proper, although we
know L ⊂ PSPACE by a simple diagonal argument.
Also LTH ⊆ LinSpace ⊂ PSPACE, where the ﬁrst inclusion is not
known to be proper. Finally P and LTH are thought to be incomparable,
but no proof is known. In fact it is diﬃcult to ﬁnd a natural example of a
problem in P which seems not to be in LTH.

III.4. IΔ0 and the Linear Time Hierarchy

69

III.4.3. Characterizing the LTH by IΔ0 . First note that LTH is a class
of relations. The corresponding class of functions is deﬁned in terms of
function graphs. Given a function f(x), its graph Gf (x, y) is the relation
Gf (x, y) ↔ (y = f(x)).
Deﬁnition III.4.6 (FLTH). A function f : Nk → N is in FLTH if its
graph Gf (x, y) is in LTH and its length has at most linear growth, i.e.,
f(x) = (x1 + · · · + xk )O(1) .
Exercise III.4.7. In future chapters we will deﬁne the class of functions
associated with a class of relations using the bit graph Bf (i, x, y) of f
instead of the graph Gf (x, y), where
Bf (i, x) ↔ BIT(i, f(x)).
Show that the class FLTH remains the same if Bf replaces Gf in the above
deﬁnition.
In general, in order to associate a theory with a complexity class we
should show that the functions in the class coincide with the Σ1 -deﬁnable
functions in the theory. The next result justiﬁes associating the theory IΔ0
with the complexity class LTH.
Theorem III.4.8 (IΔ0 -Deﬁnability). A function is Σ1 -deﬁnable in IΔ0 iﬀ
it is in FLTH.
Proof. The =⇒ direction follows from the Bounded Deﬁnability Theorem III.3.8, the above deﬁnition of LTH functions and the LTH Theorem III.4.2.
For the ⇐= direction, suppose f(x) is an LTH function. By deﬁnition the graph (y = f(x)) is an LTH relation, and hence by the LTH
Theorem III.4.2 there is a Δ0 formula ϕ(x, y) such that
y = f(x) ↔ ϕ(x, y).
Further, by deﬁnition, |f(x)| is linear bounded, so there is an LA -term
t(x) such that
f(x) ≤ t(x).

(39)

The sentence ∀x∃!yϕ(x, y) is true, but unfortunately there is no reason
to believe that it is provable in IΔ0 . We can solve the problem of proving
uniqueness by taking the least y satisfying ϕ(x, y). In general, for any
formula A(y), we deﬁne Miny [A(y)](y) to mean that y is the least number
satisfying A(y). Thus
Miny [A(y)](y) ≡def A(y) ∧ ∀z < y(¬A(z)).
If A(y) is bounded, then we can apply the least number principle to A(y)
to obtain
IΔ0  ∃yA(y) ⊃ ∃!yMiny [A(y)](y).

(40)

70

III. Peano Arithmetic and Its Subsystems

This solves the problem of proving uniqueness. To prove existence, we
modify ϕ and deﬁne
(x, y) ≡def (ϕ(x, y) ∨ y = t(x) + 1)
where t(x) is the bounding term from (39). Now deﬁne
ϕ  (x, y) ≡ Miny [ (x, y)](x, y).
Then ϕ  (x, y) also represents the relation (y = f(x)), and since trivially
IΔ0 proves ∃y (x, y) we have by (40)
IΔ0  ∀x∃!yϕ  (x, y).

2

III.5. Buss’s S2i Hierarchy: The Road Not Taken
Buss’s PhD thesis Bounded Arithmetic (published as a book in 1986,
[20]) introduced the hierarchies of bounded theories
S21 ⊆ T21 ⊆ S22 ⊆ T22 ⊆ · · · ⊆ S2i ⊆ T2i ⊆ · · · .
These theories, whose deﬁnable functions are those in the polynomial
hierarchy, are of central importance in the area of bounded arithmetic.
We present these theories in detail in Section VIII.8. Here we present
abrief overview of the theories S2i and T2i , and their union S2 = T2 =
∞
i
i=1 S2 . The idea is to modify the theory IΔ0 so that the deﬁnable
functions are those in the polynomial hierarchy as opposed to the Linear
Time Hierarchy, and more importantly to introduce the theory S21 whose
deﬁnable functions are precisely the polynomial time functions. In order
to do this, the underlying vocabulary is augmented to include the function
symbol #, whose intended interpretation is x#y = 2|x|·|y|. Thus terms in
S2 represent functions which grow at the rate of polynomial time functions,
as opposed to the linear-time growth rate of IΔ0 terms. The full vocabulary
for S2 is
1
LS2 = [0, S, +, ·, #, |x|,  x; =, ≤].
2
(S is the Successor function, |x| is the length (of the binary representation)
of x).
Sharply bounded quantiﬁers have the form ∀x ≤ |t| or ∃x ≤ |t| (where
x does not occur in t). These are important because sharply bounded (as
opposed to just bounded) formulas represent polynomial time relations
(and in fact TC 0 relations). The syntactic class Σbi (b for “bounded”)
consists essentially of those formulas with at most i blocks of bounded
quantiﬁers beginning with ∃, with any number of sharply bounded quantiﬁers of both kinds mixed in. The formulas in Σb1 represent precisely
the NP relations, and more generally formulas in Σbi represent precisely
the relations in the level Σpi in the polynomial hierarchy. In summary,

III.6. Notes

71

bounded formulas in the vocabulary of S2 represent precisely the relations
in the polynomial hierarchy.
The axioms for T2i consist of 32 ∀-sentences called BASIC which deﬁne
the symbols of LS2 , together with the Σbi -IND scheme. The axioms for S2i
are the same as those of T2i , except for Σbi -IND is replaced by the Σbi -PIND
scheme:


1
ϕ(0) ∧ ∀x(ϕ( x) ⊃ ϕ(x)) ⊃ ∀xϕ(x)
2
where ϕ(x) is any Σbi formula. Note that this axiom scheme is true in N.
Also for i ≥ 1, T2i proves the Σbi -PIND axiom scheme, and S2i+1 proves
the Σbi -IND axiom scheme. (Thus for i ≥ 1, S2i ⊆ T2i ⊆ S2i+1 .)
For i ≥ 1, the functions Σbi -deﬁnable in S2i are precisely those polytime
reducible to relations in Σpi−1 (level i − 1 of the polynomial hierarchy). In
particular, the functions Σb1 -deﬁnable in S21 are precisely the polynomial
time functions.
Since S2 is a polynomial-bounded theory, Parikh’s Theorem III.2.3 can
be applied to show that all Σ1 -deﬁnable functions in S2 are polynomial
time reducible to PH. To show that the Σb1 -deﬁnable functions in S21 are
polynomial-time computable requires a more sophisticated “witnessing”
argument introduced by Buss. We shall present this argument later in the
context of the two-sorted ﬁrst-order theory V 1 .
In Chapters VI and VIII we present two-sorted versions V i of S2i and
TV i of T2i . In Section VIII.8 we show that two-sorted versions are essentially equivalent to the originals.

III.6. Notes
The main references for this chapter are [27, 28] and [54, pp. 277–293].
Parikh’s Theorem originally appears in [88], and the proof there is based
in the Herbrand Theorem, and resembles our “Alternative Proof ” given at
the end of Section III.3.2. Buss [20] gives a proof based on cut elimination
which is closer to our ﬁrst proof.
James Bennett [15] was the ﬁrst to show that the relation y = z x can be
deﬁned by Δ0 formulas. Hájek and Pudlák [54] give a diﬀerent deﬁnition
and show how to prove its basic properties in IΔ0 , and give a history of
such deﬁnitions and proofs. Our treatment of the relations y = 2x and
BIT(i, x) in Section III.3.3 follows that of Buss in [28], simpliﬁed with an
idea from earlier proofs.
Bennett’s Trick, described in the proof of Lemma III.3.31, is due to
Bennett [15] Section 1.7, where it is used to show that the rudimentary
functions are closed under a form of bounded recursion on notation.
Theorem III.4.2, stating LTH = ΔN
0 , is due to Wrathall [111]. Nepomnjaščij’s Theorem III.4.4 appears in [81].

Chapter IV

TWO-SORTED LOGIC AND COMPLEXITY CLASSES

In this chapter we introduce two-sorted ﬁrst-order logic (sometimes called
second-order logic), an extension of the (single-sorted) ﬁrst-order logic
that we use in the previous chapters. The reason for using two-sorted
logic is that our theories capture complexity classes deﬁned in terms of
Turing machines or Boolean circuits. The inputs to these devices are bit
strings, whereas the objects in the universe of discourse in our single-sorted
theories are numbers. Although we can code numbers by bit strings using
binary notation, this indirection is sometimes awkward, especially for
low-level complexity classes. In particular, our single-sorted theories all
include multiplication as a primitive operation, but binary multiplication
is not in the complexity class AC 0 , whose theory V 0 serves as the basis for
all our two-sorted theories. Our complexity reductions and completeness
notions are generally deﬁned using AC 0 functions.
The two-sorted theories retain the natural numbers as the ﬁrst sort, and
the objects in the second sort are bit strings (precisely, ﬁnite sets of natural
numbers, whose characteristic vectors are bit strings). We need the ﬁrst
sort (numbers) in order to reason about the second sort. The numbers
involved for this reasoning are small; they are used to index bit positions
in the second sort (strings). In deﬁning two-sorted complexity classes, the
number inputs to the devices are coded in unary notation, and are treated
as auxiliary to the main (second) sort, whose elements are coded by binary
strings. In particular we use these conventions to deﬁne the two-sorted
complexity class AC 0 . We prove the ΣB0 Representation Theorem IV.3.6,
which states that the set ΣB0 of two-sorted formulas represent precisely the
AC 0 relations.
In Chapters VII and X we show how to translate bounded theorems
in our theories into families of propositional proofs. This translation is
made especially simple and elegant by using two-sorted theories.
The historical basis for using two-sorted logic to represent complexity
classes is descriptive complexity theory, where each object (a language or
a relation) in a complexity class is described by a logical formula whose set
of ﬁnite models corresponds to the object. In the two-sorted logic setting,

73

74

IV. Two-Sorted Logic and Complexity Classes

each object corresponds to the set of interpretations of a variable in the
formula satisfying the formula in the standard model.
In the ﬁrst part of this chapter we present a brief introduction to descriptive complexity theory. (A comprehensive treatment can be found in
[59].) Then we introduce two-sorted ﬁrst-order logic, describe two-sorted
complexity classes, and explain how relations in these classes are represented by certain classes of formulas. We revisit the LTH theorem for
two-sorted logic. We present the sequent calculus LK 2 , the two-sorted
version of LK. Finally we show how to interpret two-sorted logic into
single-sorted logic.

IV.1. Basic Descriptive Complexity Theory
In descriptive complexity theory, an object (e.g. a set of graphs) in
a complexity class is speciﬁed as the set of all ﬁnite models of a given
formula. Here we consider the case in which the object is a language
L ⊆ {0, 1}∗, and the formula is a formula of the ﬁrst-order predicate
calculus. We assume that the underlying vocabulary consists of
LFO = [0, max; X, BIT , ≤, =]

(41)

where 0, max are constants, X is a unary predicate symbol, and BIT, ≤,
= are binary predicate symbols. We consider ﬁnite LFO -structures M in
which the universe M = {0, . . . , n − 1} for some natural number n ≥ 1,
and max is interpreted by n − 1. The symbols 0, =, ≤, and BIT receive
their standard interpretations. (Recall that BIT(i, x) holds iﬀ the i-th bit
in the binary representation of x is 1. In the previous chapter we showed
how to deﬁne BIT in IΔ0 , but note that here it is a primitive symbol in
LFO .)
Thus the only symbol without a ﬁxed interpretation is the unary predicate symbol X , and to specify a structure it suﬃces to specify the tuple of
truth values X (0), X (1), . . . , X (n − 1). By identifying  with 1 and ⊥
with 0, we see that there is a natural bijection between the set of structures
and the set {0, 1}+ of nonempty binary strings.
The class FO (First-Order) of languages describable by LFO formulas
is deﬁned as follows. For each binary string X we denote by M[X ]
the structure which is speciﬁed by X as above. Then the language L(ϕ)
associated with an LFO sentence ϕ is the set of strings whose associated
structures satisfy ϕ:
L(ϕ) = {X ∈ {0, 1}+ : M[X ] |= ϕ}.
Deﬁnition IV.1.1 (The Class FO).
FO = {L(ϕ) : ϕ is an LFO -sentence}.

IV.1. Basic Descriptive Complexity Theory

75

For example, let Leven be the set of strings whose even positions (starting
from the right at position 0) have 1. Then Leven ∈ FO, since Leven = L(ϕ),
where
ϕ ≡ ∀y(¬BIT (0, y) ⊃ X (y)).
To give a more interesting example, we use the fact [59, page 14] that the
relation x + y = z can be expressed by a ﬁrst-order formula ϕ+ (x, y, z)
in the vocabulary LFO . Then the set PAL of binary palindromes is represented by the sentence
∀x∀y, ϕ+ (x, y, max) ⊃ (X (x) ↔ X (y)).
Thus PAL ∈ FO.
Immerman showed that the class FO is the same as a uniform version
of AC 0 . Originally AC 0 was deﬁned in its nonuniform version, which
we shall refer to as AC 0 /poly. A language in AC 0 /poly is speciﬁed by
a polynomial size bounded depth family Cn  of Boolean circuits, where
each circuit Cn has n input bits, and is allowed to have ¬-gates, as well as
unbounded fan-in ∧-gates and ∨-gates. In the uniform version, the circuit
Cn must be speciﬁed in a uniform way; for example one could require that
Cn  is in FO. (See also Appendix A.5.)
Immerman showed that this deﬁnition of uniform AC 0 is robust, in the
sense that it has several quite diﬀerent characterizations. For example, the
logtime hierarchy LH consists of all languages recognizable by an ATM
(Alternating Turing Machine) in time O(log n) with a constant number
of alternations. Also CRAM[1] consists of all languages recognizable in
constant time on a so-called Concurrent Random Access Machine. The
following theorem is from [59, Corollary 5.32].
Theorem IV.1.2. FO = AC 0 = CRAM[1] = LH.
Of course the nonuniform class AC 0 /poly contains non-computable
sets, and hence it properly contains the uniform class AC 0 . Nevertheless
in 1983 Ajtai [3] (and independently Furst, Saxe, and Sipser [52]) proved
that even such a simple set as PARITY (the set of all strings with an odd
number of 1’s) is not in AC 0 /poly (and hence not in FO).
On the positive side, we pointed out that the set PAL of palindromes
is in FO, and hence in AC 0 . If we code a triple U, V, W  of strings as a
single string in some reasonable way then it is easy to see using a carry
look-ahead adder that binary addition (the set U, V, U + V ) is in AC 0
(see page 85). Do not confuse this result with the result of [59, page
14] mentioned above that some ﬁrst-order formula φ+ (x, y, z) represents
x + y = z, since here x, y, z represent elements in the model M, which
have nothing much to do with the input string X .
In fact PARITY is eﬃciently reducible to binary multiplication, so
Ajtai’s result implies that the set U, V, U · V  is not in AC 0 . In contrast,

76

IV. Two-Sorted Logic and Complexity Classes

there is a ﬁrst-order formula in the vocabulary LFO which represents
x · y = z in standard model with universe M = {0, . . . , n − 1}.

IV.2. Two-Sorted First-Order Logic
IV.2.1. Syntax. Our two-sorted ﬁrst-order logic is an extension of the
(single-sorted) ﬁrst-order logic introduced in Chapter II. Here there are
two kinds of variables: the variables x, y, z, . . . of the ﬁrst sort are called
number variables, and are intended to range over the natural numbers; and
the variables X, Y, Z, . . . of the second sort are called set (or also string)
variables, and are intended to range over ﬁnite subsets of natural numbers
(which represent binary strings). Function and predicate symbols may
involve either or both sorts.
Deﬁnition IV.2.1 (Two-Sorted First-Order Vocabularies). A two-sorted ﬁrst-order vocabulary (or just two-sorted vocabulary, or vocabulary,
or language) L is speciﬁed by a set of function symbols and predicate
symbols, just as in the case of a single-sorted vocabulary (Section II.2.1),
except that the functions and predicates now can take arguments of both
sorts, and there are two kinds of functions: the number-valued functions
(or just number functions) and the string-valued functions (or just string
functions).
In particular, for each n, m ∈ N, there is a set of (n, m)-ary number
function symbols, a set of (n, m)-ary string function symbols, and a set
of (n, m)-ary predicate symbols. A (0, 0)-ary function symbol is called
a constant symbol, which can be either a number constant or a string
constant.
We use f, g, h, . . . as meta-symbols for number function symbols; F, G,
H, . . . for string function symbols; and P, Q, R, . . . for predicate symbols.
For example, consider the following two-sorted extension of LA (Deﬁnition II.2.3):
Deﬁnition IV.2.2. L2A = [0, 1, +, ·, | | ; =1 , =2 , ≤, ∈].
Here the symbols 0, 1, +, ·, =1 and ≤ are from LA ; they are function
and predicate symbols over the ﬁrst sort (=1 corresponds to = of LA ).
The function |X | (the “length of X ”) is a number-valued function and is
intended to denote the least upper bound of the set X (roughly the length
of the corresponding string). The binary predicate ∈ takes a number and
a set as arguments, and is intended to denote set membership. Finally, =2
is the equality predicate for the second-sort objects. We will write = for
both =1 and =2 , since it will be clear from the context which is intended.
We will use the abbreviation
X (t) =def t ∈ X

IV.2. Two-Sorted First-Order Logic

77

where t is a number term (Deﬁnition IV.2.3 below). Thus we think of
X (i) as the i-th bit of the binary string X .
Note that in L2A the function symbols +, · each has arity (2, 0), while | |
has arity (0, 1) and the predicate symbol ∈ has arity (1, 1).
For a two-sorted vocabulary L, the notions of L-terms and L-formulas
generalize the corresponding notions in the single-sorted case (Deﬁnitions II.2.1 and II.2.2). Here we have two kinds of terms: number terms
and string terms. As before, we will drop mention of L when it is not
important, or clear from the context. Also, we are interested only in vocabularies L that extend L2A , and we may list only the elements of the set
L − L2A (sometimes without the braces {, } for set). In such cases, the notations L-terms, L-formulas, ΣBi (L), etc. refer really to the corresponding
notions for L ∪ L2A .
Deﬁnition IV.2.3 (L-Terms). Let L be a two-sorted vocabulary:
1) Every number variable is an L-number term.
2) Every string variable is an L-string term.
3) If f is an (n, m)-ary number function symbol of L, t1 , . . . , tn are Lnumber terms, and T1 , . . . , Tm are L-string terms, then ft1 . . . tn T1
. . . Tm is an L-number term.
4) If F is an (n, m)-ary string function symbol of L, and t1 , . . . , tn and
T1 , . . . , Tm are as above, then Ft1 . . . tn T1 . . . Tm is an L-string term.
Note that all constants in L are L-terms.
We often denote number terms by r, s, t, . . . , and string terms by S,T, . . . .
The formulas over a two-sorted vocabulary L are deﬁned as in the
single-sorted case (Deﬁnition II.2.2), with the addition of quantiﬁers over
string variables. These are called string quantiﬁers, and the quantiﬁers
over number variables are called number quantiﬁers. Also note that a
predicate symbol in general may have arguments from both sorts.
Deﬁnition IV.2.4 (L-Formulas). Let L be a two-sorted ﬁrst-order vocabulary. Then a two-sorted ﬁrst-order formula in L (or L-formula, or just
formula) are deﬁned inductively as follows:
1) If P is an (n, m)-ary predicate symbol of L, t1 , . . . , tn are L-number
terms and T1 , . . . , Tm are L-string terms, then
Pt1 . . . tn T1 . . . Tm
is an atomic L-formula. Also, each of the logical constants ⊥,  is
an atomic formula.
2) If ϕ, are L-formulas, so are ¬ϕ, (ϕ ∧ ), and (ϕ ∨ ).
3) If ϕ is an L-formula, x is a number variable and X is a string variable,
then ∀xϕ, ∃xϕ, ∀Xϕ and ∃Xϕ are L-formulas.
We often denote formulas by ϕ, , . . . .

78

IV. Two-Sorted Logic and Complexity Classes

For readability we will usually use commas to separate the arguments
of functions and predicates. Thus we write f(x1 , . . . , xn , X1 , . . . , Xm ) and
P(x1 , . . . , xn , X1 , . . . , Xm ) instead of fx1 . . . xn X1 . . . Xm and Px1 . . . xn X1
. . . Xm .
Recall that in L2A we write X (t) for t ∈ X .
Example IV.2.5 (L2A -Terms and L2A -Formulas).
1) The only string terms of L2A are the string variables X, Y, Z, . . . .
2) The number terms of L2A are obtained from the constants 0, 1,
number variables x, y, z, . . . , and the lengths of the string variables
|X |, |Y |, |Z|, . . . using the binary function symbols +, ·.
3) The only atomic formulas of L2A are ⊥,  or those of the form s = t,
X = Y , s ≤ t and X (t) for string variables X, Y and number terms
s, t.
IV.2.2. Semantics. As for single-sorted ﬁrst-order logic, the semantics
of a two-sorted vocabulary is given by structures and object assignments.
Here the universe of a structure contains two sorts of objects, one for
the number variables and one for the string variables. As in the singlesorted case, we also require that the predicate symbols =1 and =2 must
be interpreted as the true equality in the respective sort. The following
deﬁnition generalizes the notion of a (single-sorted) structure given in
Deﬁnition II.2.6.
Deﬁnition IV.2.6 (Two-Sorted Structures). Let L be a two-sorted vocabulary. Then an L-structure M consists of the following:
1) A pair of two nonempty sets U1 and U2 , which together are called the
universe. Number (resp. string) variables in L-formulas are intended
to range over U1 (resp. U2 ).
2) For each (n, m)-ary number function symbol f of L an associated
function f M : U1n × U2m → U1 .
3) For each (n, m)-ary string function symbol F of L an associated
function F M : U1n × U2m → U2 .
4) For each (n, m)-ary predicate symbol P of L an associated relation
P M ⊆ U1n × U2m .
Thus for our “base” vocabulary L2A , an L2A -structure with universe
U1 , U2  contains the following interpretations of L2A :
• Elements 0M , 1M ∈ U1 to interpret 0 and 1, respectively;
• Binary functions +M , ·M : U1 × U1 → U1 to interpret + and ·,
respectively;
• A binary predicate ≤M ⊆ U12 interpreting ≤;
• A function | |M : U2 → U1 ;
• A binary relation ∈M ⊆ U1 × U2 .
In this book all two-sorted vocabularies L that we consider contain L2A ,
so in particular they contain the length function | | and the element-of

IV.2. Two-Sorted First-Order Logic

79

predicate ∈. Our intention is that an element α ∈ U2 can be speciﬁed by
a pair (|α|, Sα ), where |α| = |α|M ∈ U1 , and Sα = {u ∈ U1 : u ∈M α}.
Thus we want two elements α1 and α2 in U2 to be equal iﬀ |α1 |M = |α2 |M
and the subsets of U1 speciﬁed by interpreting ∈M at α1 and α2 are
the same. In fact all two-sorted theories that we consider include the
extensionality axiom SE (see Figure 2 on page 96). Thus we may assume
that in any model of such a theory, elements α of U2 are speciﬁed by the
pair (|α|, Sα ) as above.
Example IV.2.7 (The Standard Two-Sorted Model N2 ). The standard
model N2 has U1 = N and U2 the set of ﬁnite subsets of N. The number
part of the structure is the standard single-sorted ﬁrst-order structure N.
The relation ∈ gets its usual interpretation (membership), and for each
ﬁnite subset S ⊆ N, |S| is interpreted as one plus the largest element in S,
or 0 if S is empty.
As in the single-sorted case, the truth value of a formula in a structure
is deﬁned based on the interpretations of free variables occurring in it.
Here we need to generalize the notion of an object assignment (Deﬁnition II.2.7):
Deﬁnition IV.2.8 (Two-Sorted Object Assignment). A two-sorted object assignment (or just an object assignment) for a two-sorted structure
M is a mapping from the number variables to U1 together with a mapping
from the string variables to U2 .
Notation. We will write (x) for the ﬁrst-sort object assigned to the
number variable x by , and (X ) for the second-sort object assigned
to the string variable X by . Also as in the single-sorted case, if x is a
variable and m ∈ U1 , then the object assignment (m/x) is the same as
except it maps x to m, and if X is a variable and M ∈ U2 , then the object
assignment (M/X ) is the same as except it maps X to M .
Now the Basic Semantic Deﬁnition II.2.8 generalizes in the obvious
way.
Deﬁnition IV.2.9 (Basic Semantic Deﬁnition, Two-Sorted Case). Let
L be a two-sorted ﬁrst-order vocabulary, let M be an L-structure with
universe U1 , U2 , and let be an object assignment for M. Each Lnumber term t is assigned an element t M [ ] in U1 , and each L-string term
T is assigned an element T M [ ] in U2 , deﬁned by structural induction on
terms t and T , as follows (refer to Deﬁnition IV.2.3 for the deﬁnition of
L-term):
(a) x M [ ] is (x), for each number variable x;
(b) X M [ ] is (X ), for each string variable X ;
(c) (ft1 · · · tn T1 . . . Tm )M [ ] = f M (t1M [ ], . . . , tnM [ ],
T1M [ ], . . . , TmM [ ]);

80

IV. Two-Sorted Logic and Complexity Classes

(d) (Ft1 · · · tn T1 . . . Tm )M [ ] = F M (t1M [ ], . . . , tnM [ ],
T1M [ ], . . . , TmM [ ]).
Deﬁnition IV.2.10. For ϕ an L-formula, the notion M |= ϕ[ ] (M
satisﬁes ϕ under ) is deﬁned by structural induction on formulas ϕ as
follows (refer to Deﬁnition IV.2.4 for the deﬁnition of a formula):
(a) M |=  and M |= ⊥.
(b) M |= (Pt1 · · · tn T1 . . . Tm )[ ] iﬀ
t1M [ ], . . . , tnM [ ], T1M [ ], . . . , TmM [ ] ∈ P M .
(c1) If L contains =1 , then M |= (s = t)[ ] iﬀ s M [ ] = t M [ ].
(c2) If L contains =2 , then M |= (S = T )[ ] iﬀ S M [ ] = T M [ ].
(d) M |= ¬ϕ[ ] iﬀ M |= ϕ[ ].
(e) M |= (ϕ ∨ )[ ] iﬀ M |= ϕ[ ] or M |= [ ].
(f) M |= (ϕ ∧ )[ ] iﬀ M |= ϕ[ ] and M |= [ ].
(g1) M |= (∀xϕ)[ ] iﬀ M |= ϕ[ (m/x)] for all m ∈ U1 .
(g2) M |= (∀Xϕ)[ ] iﬀ M |= ϕ[ (M/X )] for all M ∈ U2 .
(h1) M |= (∃xϕ)[ ] iﬀ M |= ϕ[ (m/x)] for some m ∈ U1 .
(h2) M |= (∃Xϕ)[ ] iﬀ M |= ϕ[ (M/X )] for some M ∈ U2 .
Note that items (c1) and (c2) in the deﬁnition of M |= A[ ] follow
M
from (b) and the fact that =M
1 and =2 are always the equality relations
in the respective sorts.
The notions of “M |= ϕ”, “logical consequence”, “validity”, etc.,
are deﬁned as before (Deﬁnition II.2.10), and we do not repeat them
here. Also, the Substitution Theorem (II.2.14) generalizes to the current
context, and the Formula Replacement Theorem (II.2.15) continues to
hold, and we will not restate them.

IV.3. Two-Sorted Complexity Classes
IV.3.1. Notation for Numbers and Finite Sets. In Section III.4 we explained how to interpret an element of a complexity class such as P (polynomial time) and LTH (Linear Time Hierarchy) as a relation over N. In
this context the numerical inputs x1 , . . . , xk of a relation R(x1 , . . . , xk )
are presented in binary to the accepting machine. In the two-sorted context, however, the relations R(x1 , . . . , xk , X1 , . . . , Xm ) in question have
arguments of both sorts, and now the numbers xi are presented to the
accepting machines using unary notation (n is represented by a string of n
1’s) instead of binary. The elements Xi of the second sort are ﬁnite subsets
of N, and we represent them as binary strings (see below) for the purpose
of presenting them as inputs to the accepting machine. The intuitive reason that we represent the numerical arguments in unary is that now they

IV.3. Two-Sorted Complexity Classes

81

play an auxiliary role as indices to the string arguments, and hence their
values are comparable in size to the length of the string arguments.
Thus a numerical relation R(x) with no string argument is in two-sorted
polynomial time iﬀ it is computed in time 2O(n) on some Turing machine,
where n is the binary length of the input x. In particular, the relation
Prime(x) is easily seen to be in this class, using a “brute force” algorithm
that tries all possible divisors between 1 and x.
The binary string representation of a ﬁnite subset of N is deﬁned as
follows. Recall that we write S(i) for i ∈ S (for i ∈ N and S ⊆ N). Thus
if we write 0 for ⊥ and 1 for , then we can use the binary string
w(S) = S(n)S(n − 1) . . . S(1)S(0)

(42)

to interpret the ﬁnite nonempty subset S of N, where n is the largest
member of S. We deﬁne w(∅) to be the empty string. For example,
w({0, 2, 3}) = 1101.
Notice that the intended interpretation of |S| (one plus the largest element
of S, or 0 if S = ∅) is precisely the length of the associated string w(S).
Thus w is an injective map from ﬁnite subsets of N to {0, 1}∗, but it
is not surjective, since the string w(S) begins with 1 for all nonempty S.
Nevertheless w(S) is a useful way to represent S as an input to a Turing
machine or circuit.
Using the method just described of representing numbers and strings,
we can deﬁne two-sorted complexity classes as sets of relations. For
example two-sorted P consists of the set of all relations R(x, X ) which
are accepted in polynomial time by some deterministic Turing machine,
where each numerical argument xi is represented in unary as an input, and
each subset argument Xi is represented by the string w(Xi ) as an input.
Similar deﬁnitions specify the two-sorted polynomial hierarchy PH, and
the two-sorted complexity classes AC 0 and LTH.
IV.3.2. Representation Theorems.
Notation. If T = T1 , . . . Tn , is a sequence of string terms, then |T |
denotes the sequence |T1 |, . . . , |Tn | of number terms.
Bounded number quantiﬁers are deﬁned as in the single-sorted case
(Deﬁnition III.1.6). To deﬁne bounded string quantiﬁers, we need the
length function |X | of L2A .
Notation. A two-sorted vocabulary L is always assumed to be an extension of L2A .
Deﬁnition IV.3.1 (Bounded Formulas). Let L be a two-sorted vocabulary. If x is a number variable and X a string variable that do not occur
in the L-number term t, then ∃x ≤ tϕ stands for ∃x(x ≤ t ∧ ϕ), ∀x ≤ tϕ
stands for ∀x(x ≤ t ⊃ ϕ), ∃X ≤ tϕ stands for ∃X (|X | ≤ t ∧ ϕ), and

82

IV. Two-Sorted Logic and Complexity Classes

∀X ≤ tϕ stands for ∀X (|X | ≤ t ⊃ ϕ). Quantiﬁers that occur in this
form are said to be bounded, and a bounded formula is one in which every
quantiﬁer is bounded.
Notation. ∃x ≤ tϕ stands for ∃x1 ≤ t1 . . . ∃xk ≤ tk ϕ for some k,
where no xi occurs in any tj (even if i < j). Similarly for ∀x ≤ t, ∃X ≤ t,
and ∀X ≤ t.
If the above convention is violated in the sense that xi occurs in tj for
−
→
i < j, and the terms t are L2A -terms, then new bounding terms t  in L2A
can be found which satisfy the convention. For example ∃x1 ≤ t1 ∃x2 ≤
t2 (x1 )ϕ is equivalent to
∃x1 ≤ t1 ∃x2 ≤ t2 (t1 )(x2 ≤ t2 (x1 ) ∧ ϕ).
We will now deﬁne the following important classes of formulas.
Deﬁnition IV.3.2 (The Σ11 (L), ΣBi (L) and ΠBi (L) Formulas). Let L ⊇
2
LA be a two-sorted vocabulary. Then ΣB0 (L) = ΠB0 (L) is the set of Lformulas whose only quantiﬁers are bounded number quantiﬁers (there
can be free string variables). For i ≥ 0, ΣBi+1 (L) (resp. ΠBi+1 (L)) is the set
of formulas of the form ∃X ≤ tϕ(X ) (resp. ∀X ≤ tϕ(X )), where ϕ is a
ΠBi (L) formula (resp. a ΣBi (L) formula), and t is a sequence of L2A -terms
not involving any variable in X . Also, a Σ11 (L) formula is one of the form
∃X ϕ, where X is a vector of zero or more string variables, and ϕ is a
ΣB0 (L) formula.
We usually write ΣBi for ΣBi (L2A ) and ΠBi for ΠBi (L2A ).
We have
ΣB0 (L) ⊆ ΣB1 (L) ⊆ ΣB2 (L) ⊆ · · · ,
ΣB0 (L) ⊆ ΠB1 (L) ⊆ ΠB2 (L) ⊆ · · ·
and for i ≥ 0
ΣBi (L) ⊆ ΠBi+1 (L) and ΠBi (L) ⊆ ΣBi+1 (L).
Notice the “strict” requirements on ΣBi (L) and ΠBi (L): all string quantiﬁers must occur in front. For example, ΣB1 (L2A ) is sometimes called strict
Σ1,b
1 in the literature. (Also notice that the bounding terms t must be in the
basic vocabulary L2A .) We will show that some theories prove replacement
theorems, which assert the equivalence of a non-strict ΣBi formula (for
certain values if i) with its strict counterpart.
In Section III.3.1 we discussed the deﬁnability of predicates (i.e., relations) and functions in a single-sorted theory. In the case of relations, the
notion is purely semantic, and does not depend on the theory, but only
the underlying vocabulary and the standard model. The situation is the
same for the two-sorted case, and so we will deﬁne the notion of a relation
R(x, X ) represented by a formula, without reference to a theory. As in the

IV.3. Two-Sorted Complexity Classes

83

single-sorted case, we assume that each relation symbol has a standard
interpretation in an expansion of the standard model, in this case N2 , and
formulas in the following deﬁnition are interpreted in the same model.
Deﬁnition IV.3.3 (Representable/Deﬁnable Relations). Let L ⊇ L2A
be a two-sorted vocabulary, and let ϕ be an L-formula. Then we say that
ϕ(x, X ) represents (or deﬁnes) a relation R(x, X ) if
R(x, X ) ↔ ϕ(x, X ).

(43)

If Φ is a set of L-formulas, then we say that R(x, X ) is Φ-representable
(or Φ-deﬁnable) if it is represented by some ϕ ∈ Φ.
If we want to precisely represent a language L ⊆ {0, 1}∗ , then we need
to consider strings that do not necessarily begin with 1. Thus the relation
RL (X ) corresponding to L is deﬁned by
RL (X ) ↔ w  (X ) ∈ L
where the string w  (X ) is obtained from w(X ) (42) by deleting the initial
1 (and w  (∅) and w  ({1}) both are the empty string).
Example IV.3.4. The language PAL (page 75) of binary palindromes is
represented by the formula
ϕPAL (X ) ↔ |X | ≤ 1 ∨ ∀x, y < |X |, x + y + 2 = |X | ⊃ (X (x) ↔ X (y)).
Despite this example, we emphasize that the objects of the second sort
in our complexity classes are ﬁnite sets of natural numbers, and we will
not be much concerned by the fact that the corresponding strings (for
nonempty sets) all begin with 1.
We deﬁne two-sorted AC 0 using the log time hierarchy LH. We could
deﬁne LH using alternating Turing machines (those relations accepted in
log time with a constant number of alternations), but we choose instead
to deﬁne the levels of the hierarchy using a recurrence analogous to our
deﬁnition of LTH in Section III.4.1. Thus we deﬁne NLogTime to be the
class of relations R(x, X ) accepted by a nondeterministic index Turing
machine M in time O(log n). (See also Appendix A.2.)
As explained before, normally inputs x are presented in unary and X are
presented in binary. However in deﬁning LH it is convenient to change
this convention and assume that the number inputs x are presented in
binary (string inputs X are also presented in binary as before). To keep
the meaning of “log time” unchanged, we deﬁne the length of a number
input xi to be xi , even though the actual length of the binary notation
is |xi |. The reason for using binary notation is that in time O(log xi ) a
Turing machine M can read the entire binary notation for xi .
The machine M accesses its string inputs using index tapes; one such
tape for each string argument Xi of R(x, X ). When M enters the query
state for an input Xi , if the index tape contains the number j written

84

IV. Two-Sorted Logic and Complexity Classes

in binary, then j-th bit of Xi is returned. The index tape is not erased
between input queries. Since M runs in log time, only O(log |Xi |) bits of
Xi can be accessed during any one computation.
Now deﬁne
Σlog
1 = NLogTime

(44)

and for i ≥ 1
log

Σi
.
Σlog
i+1 = NLogTime

Then
LH =



(45)

Σlog
i .

i

Deﬁnition IV.3.5 (Two-Sorted AC 0 ). AC 0 = LH.
log

The notation NLogTimeΣi in (45) refers to a nondeterministic log time
Turing machine M as above, except now M has access to an oracle for a
relation S(y, Y ) in Σlog
i . In order to explain how M in log time accesses an
arbitrary input (y, Y ) to S, we simplify things by requiring that X = Y ;
that is the string inputs to S are the same as the string inputs to M .
However the number inputs y to S are arbitrary: M has time to write
them in binary on a special query tape. (See Appendix A.3 for oracle
Turing machines).
Two-sorted AC 0 restricted to numerical relations R(x) is exactly the
same as single-sorted LTH as deﬁned in Section III.4.1. The amount of
time allotted for the Turing machines under the two deﬁnitions for an
input x is the same, namely O(log(Σxi )).
Thus for numerical relations, the following representation theorem is
the same as the LTH Theorem III.4.2 (LTH = ΔN
0 ). For string relations,
it can be considered a restatement of Theorem IV.1.2 (FO = AC 0 ).
Theorem IV.3.6 (ΣB0 Representation). A relation R(x, X ) is in AC 0 iﬀ
it is represented by some ΣB0 formula ϕ(x, X ).
Proof sketch. In light of the above discussion, the proof is essentially
the same as for Theorem III.4.2. To show that every relation R(x, X ) in
AC 0 (i.e. LH) is representable by a ΣB0 formula ϕ(x, X ) we use the recurrence (44), (45). The proof is almost the same as showing LTH ⊆ ΔN
0.
There is an extra consideration in the base case, showing how the formula
ϕ(x, X ) represents the computation of a log time nondeterministic Turing machine M that now accesses its string inputs using index tapes. The
computation is represented as before, except now ϕ(x, X ) uses an extra
number variable ji for each string input variable Xi . Here ji holds the
current numerical value of the index tape for Xi .

85

IV.3. Two-Sorted Complexity Classes

The proof of the converse, that every relation representable by a ΣB0
formula is in LH, is straightforward and similar to the proof that ΔN
0 ⊆
LTH.
2
Notation. For X a ﬁnite subset of N, let bin(X ) be the number whose
binary notation is w(X ) (see (42)). Thus
X (i)2i

bin(X ) =

(46)

i

where here we treat the predicate X (i) as a 0-1-valued function. For
example, bin({0, 2, 3}) = 22 + 23 = 12.
Deﬁne the relations R+ and R× by
R+ (X, Y, Z) ↔ bin(X ) + bin(Y ) = bin(Z),
R× (X, Y, Z) ↔ bin(X ) · bin(Y ) = bin(Z).
As mentioned earlier, PARITY is eﬃciently reducible to R× , and hence
R× is not in AC 0 , and cannot be represented by any ΣB0 formula. However
R+ is in AC 0 . To represent it as a ΣB0 formula, we ﬁrst deﬁne the relation
Carry(i, X, Y ) to mean that there is a carry into bit position i when computing bin(X ) + bin(Y ). Then (using the idea behind a carry-lookahead
adder)

Carry(i, X, Y ) ↔ ∃k < i X (k) ∧ Y (k) ∧

∀j < i(k < j ⊃ (X (j) ∨ Y (j))) . (47)
Thus

R+ (X, Y, Z) ↔ |Z| ≤ |X | + |Y | ∧


∀i < |X | + |Y |(Z(i) ↔ (X (i) ⊕ Y (i) ⊕ Carry(i, X, Y )))

where ⊕ represents exclusive or.
Note that the ΣB0 Representation Theorem can be alternatively proved
by using the characterization AC 0 = FO. Here we need the fact that
FO[BIT] = FO[PLUS, TIMES]
i.e., the vocabulary LFO in (41) can be equivalently deﬁned as
[0, max, +, · ; X, ≤, =].
Note also that in LFO we have only one “free” unary predicate symbol X ,
so technically speaking, LFO formulas can describe only unary relations
(i.e., languages). In order to describe a k-ary relation, one way is to extend
the vocabulary LFO to include additional “free” unary predicates. Then
Theorem IV.1.2 continues to hold. Now the ΣB0 Representation Theorem
can be proved by translating any ΣB0 formula ϕ into an FO formula ϕ 
that describes the relation represented by ϕ, and vice versa.

86

IV. Two-Sorted Logic and Complexity Classes

We use ΣPi to denote level i ≥ 1 of the two-sorted polynomial hierarchy.
In particular, ΣP1 denotes two-sorted NP. Thus a relation R(x, X ) is in
ΣPi iﬀ it is accepted by some polynomial time ATM with at most i alternations, starting with existential, using the input conventions described in
Section IV.3.1. (See also Appendices A.2 and A.3.)
Theorem IV.3.7 (ΣBi and Σ11 Representation). For i ≥ 1, a relation R(x,
X ) is in ΣPi iﬀ it is represented by some ΣBi formula. The relation is recursively
enumerable iﬀ it is represented by some Σ11 formula.
Proof. We show that a relation R(x, X ) is in NP iﬀ it is represented by
a ΣB1 formula. (The other cases are proved similarly.) First suppose that
R(x, X ) is accepted by a nondeterministic polytime Turing machine M.
Then the ΣB1 formula that represents R has the form
∃Y ≤ t(x, X ) ϕ(x, X , Y )
where Y codes an accepting computation of M on input x, X , t represents the upper bound on the length of such computation, and ϕ is a ΣB0
formula that veriﬁes the correctness of Y . Here the bounding term t exists
by the assumption that M works in polynomial time, and the formula ϕ
can be easily constructed given the transition function of M.
On the other hand, suppose that R(x, X ) is represented by the ΣB1
formula
∃Y ≤ t(x, X ) ϕ(x, X , Y ).
Then the polytime NTM M that accepts R works as follows. On input
x, X  M simply guesses the values of Y , and then veriﬁes that ϕ(x, X , Y )
holds. The veriﬁcation can be easily done in polytime (it is in fact in AC 0
as shown by the ΣB0 Representation Theorem).
2
IV.3.3. The LTH Revisited. Consider LTH (Linear Time Hierarchy,
Section III.4) as a two-sorted complexity class. Here we can deﬁne the
relations in this class by linearly bounded formulas, a concept deﬁned
below.
Deﬁnition IV.3.8. A formula ϕ over L2A is called a linearly bounded
formula if all of its quantiﬁers are bounded by terms not involving ·.
Theorem IV.3.9 (Two-Sorted LTH). A relation is in LTH if and only if
it is represented by some linearly bounded formula.
The proof of this theorem is similar to the proof of Theorem III.4.2.
Here the (⇐=) direction is simpler: For the base case, we need to calculate
the number terms t(x1 , . . . , xk , |X1 |, . . . , |Xm |) in time linear in ( xi +
|Xj |), and this is straightforward.
For the other direction, as in the proof of the single-sorted LTH Theorem, the interesting part is to show that relations in NLinTime can be
represented by linearly bounded formulas. Here we do not need to deﬁne

IV.4. The Proof System LK 2

87

x

the relation y = 2 as in the single-sorted case, since the relation X (i)
(which stands for i ∈ X ) is already in our vocabulary. We still need to
“count” the number of 1-bits in a string, i.e., we need to deﬁne the twosorted version of Numones: Numones2 (a, i, X ) is true iﬀ a is the number
of 1-bits in the ﬁrst i low-order bits of X . Again, Numones2 can be deﬁned
using Bennett’s Trick.
Exercise IV.3.10.
√ (a) Deﬁne using linearly bounded formula the relation m =  i.
(b) Deﬁne using linearly bounded formula the relation “k = the number
of 1-bits in the substring X (im) . . . X (im + m − 1)”.
(c) Now deﬁne Numones2 (a, i, X ) using linearly bounded formula.
Exercise IV.3.11. Complete the proof of the Two-Sorted LTH Theorem.
In [113], Zambella considers the subset of L2A without the number
function ·, denoted here by L2−
A , and introduces the notion of linear
formulas, which are the bounded formulas in the vocabulary L2−
A . Then
LTH is also characterized as the class of relations representable by linear
formulas. In order to prove this claim from the Two-Sorted LTH Theorem
above, we need to show that the relation x · y = z is deﬁnable by some
linear formula.
Exercise IV.3.12. Deﬁne the relation x · y = z using a linear formula.
(Hint: First deﬁne the relation “z is a multiple of y”.)
We have shown how to deﬁne the relation y = 2x using Δ0 formula in
Section III.3.3. Here it is much easier to deﬁne this relation using linearly
bounded formulas.
Exercise IV.3.13. Show how to express y = 2x using linearly bounded
formula. (Hint: Use Numones2 from Exercise IV.3.10.)

IV.4. The Proof System LK 2
Now we extend the sequent system LK (Section II.2.3) to a system
LK 2 for a two-sorted vocabulary L2 . As for LK, here we introduce the
free string variables denoted by α, , , . . . , and the bound string variables
X, Y, Z, . . . in addition to the free number variables denoted by a, b, c, . . . ,
and the bound number variables denoted by x, y, z, . . . .
Also, in LK 2 the terms (of both sorts) do not involve any bound variable,
and the formulas do not have any free occurrence of any bound variable.
The system LK 2 includes all axioms and rules for LK as described in
Section II.2.3, where the term t is a number term respecting our convention
for free and bound variables above. In addition LK 2 has the following

88

IV. Two-Sorted Logic and Complexity Classes

four rules introducing string quantiﬁers, here T is any string term that
does not contain any bound string variable X, Y, Z, . . . :
String ∀ introduction rules
left:

ϕ(T ), Γ −→ Δ
∀Xϕ(X ), Γ −→ Δ

right:

Γ −→ Δ, ϕ( )
Γ −→ Δ, ∀Xϕ(X )

String ∃ introduction rules
left:

ϕ( ), Γ −→ Δ
∃Xϕ(X ), Γ −→ Δ

right:

Γ −→ Δ, ϕ(T )
Γ −→ Δ, ∃Xϕ(X )

Restriction. The free variable must not occur in the conclusion of ∀-right
and ∃-left.
The notion of LK 2 proofs generalizes the notion of LK proofs and
anchored LK proofs. The Derivational Soundness, the Completeness
Theorem (II.2.23), and the Anchored Completeness Theorem (II.2.28)
continue to hold for LK 2 (without equality).
In general, when the vocabulary L does not contain either of the equality
predicate symbols, then the notion of LK 2 -Φ proof is deﬁned as in Deﬁnition II.2.21. In the sequel our two-sorted vocabularies will all contain
both of the equality predicates, so we will restrict our attention to this case.
Here we need to generalize the Equality Axioms given in Deﬁnition II.3.6.
Recall that we write = for both =1 and =2 .
Deﬁnition IV.4.1 (LK 2 Equality Axioms for L). Suppose that L is a
two-sorted vocabulary containing both =1 and =2 . The LK 2 Equality
Axioms for L consists of the following axioms. (We let Λ stand for
t1 = u1 , . . . , tn = un , T1 = U1 , . . . , Tm = Um
in E4 , E4 and E5 .) Here t, u, ti , ui are number terms, and T, U, Ti , Ui
are string terms.
E1 . −→ t = t;
E1 . −→ T = T ;
E2 . t = u −→ u = t;
E2 . T = U −→ U = T ;
E3 . t = u, u = v −→ t = v;
E3 . T = U, U = V −→ T = V ;
E4 . Λ −→ ft1 . . . tn T1 . . . Tm = fu1 . . . un U1 . . . Um for each f in L;
E4 . Λ −→ Ft1 . . . tn T1 . . . Tm = Fu1 . . . un U1 . . . Um for each F in L;
E5 . Λ, Pt1 . . . tn T1 . . . Tm −→ Pu1 . . . un U1 . . . Um for each P in L (here
P is not =1 or =2 ).
Deﬁnition IV.4.2 (LK 2 -Φ Proofs). Suppose that L is a two-sorted vocabulary containing both =1 and =2 , and Φ is a set of L-formulas. Then
an LK 2 -Φ proof (or a Φ-proof) is an LK 2 -Ψ proof in the sense of Deﬁnition II.2.21, where Ψ is Φ together with all instances of the LK 2 Equality

IV.4. The Proof System LK 2








89



Axioms E1 , E1 , . . . , E4 , E4 , E5 for L. If Φ is empty, we simply refer
to an LK 2 -proof (but allow E1 , . . . , E5 as axioms).
Recall that if ϕ is a formula with free variables a1 , . . . , an , α1 , . . . , αm ,
then ∀ϕ, the universal closure of ϕ, is the sentence
∀x1 . . . ∀xn ∀X1 . . . ∀Xm ϕ(x1 /a1 , . . . , xn /an , X1 /α1 , . . . , Xm /αm )
where x1 , . . . , xn , X1 , . . . , Xm is a list of new bound variables. Also recall
that if Φ is a set of formulas, then ∀Φ is the set of all sentences ∀ϕ, for
ϕ ∈ Φ.
The following Soundness and Completeness Theorem for the twosorted system LK 2 is the analogue of Theorem II.3.8, and is proved in
the same way.
Theorem IV.4.3 (Soundness and Completeness of LK 2 ). For any set Φ
of formulas and sequent S,
∀Φ |= S iﬀ S has an LK 2 -Φ proof.
Below we will state the two-sorted analogue of the Anchored LK Completeness Theorem and the Subformula Property of Anchored LK Proofs
(Theorems II.3.10 and II.3.11). They can be proved just as in the case of
LK.
Deﬁnition IV.4.4 (Anchored LK 2 Proof). An LK 2 -Φ proof  is anchored provided every cut formula in  is a formula in some non-logical
axiom of  (including possibly E1 , E1 , . . . , E5 ).
Theorem IV.4.5 (Anchored LK 2 Completeness). Suppose that Φ is a
set of formulas closed under substitution of terms for variables and that the
sequent S is a logical consequence of ∀Φ. Then there is an anchored LK 2 -Φ
proof of S.
Theorem IV.4.6 (Subformula Property of Anchored LK 2 Proofs). If 
is an anchored LK 2 -Φ proof of a sequent S, then every formula in every
sequent of  is a term substitution instance of a sub-formula of a formula
either in S or in a non-logical axiom of  (including E1 , . . . , E4 , E5 ).
As in the case for LK where the Anchored LK Completeness Theorem
is used to prove the Compactness Theorem (Theorem II.4.2), the above
Anchored LK 2 Completeness Theorem can be used to prove the following
(two-sorted) Compactness Theorem.
Theorem IV.4.7 (Compactness). If Φ is an unsatisﬁable set of (twosorted ) formulas, then some ﬁnite subset of Φ is unsatisﬁable.
(See also the three alternative forms in Theorem II.1.16.)
Form 1 of the Herbrand Theorem (Theorem II.5.4) can also be extended
to the two-sorted logic, with the set of (single-sorted) equality axioms EL
now replaced by the set of two-sorted equality axioms E1 , E1 , . . . , E4 ,
E5 above. Below we will state only Form 2 of the Herbrand Theorem for

90

IV. Two-Sorted Logic and Complexity Classes

the two-sorted logics. Note that it also follows from Form 1, just as in the
single-sorted case.
A two-sorted theory (or just theory, when it is clear) is deﬁned as in Definition III.1.1, where now it is understood that the underlying vocabulary
L is a two-sorted vocabulary. Also, a universal theory is a theory which
can be axiomatized by universal formulas, (i.e., formulas in prenex form,
in which all quantiﬁers are universal).
Theorem IV.4.8 (Herbrand Theorem for Two-Sorted Logic). (a) Let
T be a universal (two-sorted ) theory, and let ϕ(x1 , . . . , xk , X1 , . . . , Xm , Z)
be a quantiﬁer-free formula with all free variables displayed such that
T  ∀x1 . . . ∀xk ∀X1 . . . ∀Xm ∃Zϕ(x, X , Z).
Then there exist ﬁnitely many string terms T1 (x, X ), . . . , Tn (x, X ) such
that

T  ∀x1 . . . ∀xk ∀X1 . . . ∀Xm ϕ(x, X , T1 (x, X )) ∨ · · · ∨

ϕ(x, X , Tn (x, X )) .
(b) Similarly, let the theory T be as above, and let
ϕ(x1 , . . . , xk , z, X1 , . . . , Xm )
be a quantiﬁer-free formula with all free variables displayed such that
T  ∀x1 . . . ∀xk ∀X1 . . . ∀Xm ∃zϕ(x, z, X ).
Then there exist ﬁnitely many number terms t1 (x, X ), . . . , tn (x, X ) such
that

T  ∀x1 . . . ∀xk ∀X1 . . . ∀Xm ϕ(x, t1 (x, X ), X ) ∨ · · · ∨

ϕ(x, tn (x, X ), X ) .
The theorem easily extends to the cases where
T  ∀x∀X ∃z1 . . . ∃zm ∃Z1 . . . ∃Zn ϕ(x, z, X , Z).
IV.4.1. Two-Sorted Free Variable Normal Form. The notion of free
variable normal form (Section II.2.4) generalizes naturally to LK 2 proofs,
where now the term free variable refers to free variables of both sorts.
Again there is a simple procedure for putting any LK 2 proof into free
variable normal form (with the same endsequent), provided that the underlying vocabulary has constant symbols of both sorts. This procedure
preserves the size and shape of the proof, and takes an anchored LK 2 -Φ
proof to an anchored LK 2 -Φ proof, provided that the set Φ of formulas is
closed under substitution of terms for free variables.
In the case of L2A , there is no string constant symbol, so we expand the
notion of a LK 2 -Φ proof over L2A by allowing the constant symbol ∅ (for

IV.5. Single-Sorted Logic Interpretation

91

the empty string) and assume that Φ contains the following axiom:
E. |∅| = 0.
Adding this symbol and axiom to any theory T over L2A we consider
will result in a conservative extension of T , since every model for T can
trivially be expanded to a model of T ∪ {E}. Now any LK 2 proof over
L2A can be transformed to one in free variable normal form with the same
endsequent, and similarly for LK 2 -Φ for suitable Φ.

IV.5. Single-Sorted Logic Interpretation
In this section we will brieﬂy discuss how the Compactness Theorem
and Herbrand Theorem in the two-sorted logic follow from the analogous
results for the single-sorted logic that we have seen in Chapter II. This
section is independent with the rest of the book, and it is the approach
that we follow to prove the above theorems in Section IV.4 that will be
useful in later chapters, not the approach that we present here.
Although a two-sorted logic is a generalization of a single-sorted logic
by having one more sort, it can be interpreted as a single-sorted logic by
merging both sorts and using 2 extra unary predicate symbols to identify
elements of the 2 sorts.
More precisely, for each two-sorted vocabulary L, w.l.o.g., we can assume that it does not contain the unary predicate symbols FS (for ﬁrst
sort) and SS (for second sort). Let L1 = {FS, SS} ∪ L, where it is understood that the functions and predicates in L1 take arguments from a
single sort.
In addition, let ΦL be the set of L1 -formulas which consists of
1) (∀x, FS(x) ∨ SS(x)) ∧ (∃x∃y, FS(x) ∧ SS(y)).
2) For each function symbol f of L1 (where f has arity (n, m) in L)
the formula
∀x∀y, (FS(x1 ) ∧ · · · ∧ FS(xn ) ∧ SS(y1 ) ∧ · · · ∧ SS(ym )) ⊃ FS(f(x, y)).
(If f is a number constant c, the above formula is just FS(c).)
3) For each function symbol F of L1 (where F has arity (n, m) in L)
the formula
∀x∀y, (FS(x1 ) ∧ · · · ∧ FS(xn ) ∧ SS(y1 ) ∧ · · · ∧ SS(ym )) ⊃ SS(F (x, y)).
(If F is a string constant α, the above formula is just SS(α).)
4) For each predicate symbol P of L1 (where P has arity (n, m) in L)
the formula
∀x∀y, P(x, y) ⊃ (FS(x1 ) ∧ · · · ∧ FS(xn ) ∧ SS(y1 ) ∧ · · · ∧ SS(ym )).
Lemma IV.5.1. For each nonempty two-sorted vocabulary L, the set ΦL
is satisﬁable.

92

IV. Two-Sorted Logic and Complexity Classes

Proof. The proof is straightforward: For an arbitrary (two-sorted)
L-structure M with universe U1 , U2 , we construct a (single-sorted) L1 structure M1 that has universe U1 , U2 , FSM1 = U1 , SSM1 = U2 , and
the same interpretation as in M for each symbol of L. It is easy to verify
2
that M1 |= ΦL .
It is also evident from the above proof that any model M1 of ΦL can
be interpreted as a two-sorted L-structure M.
Now we construct for each L-formula ϕ an L1 -formula ϕ 1 inductively
as follows.
1) If ϕ is an atomic sentence, then ϕ 1 =def ϕ.
2) If ϕ ≡ ϕ1 ∧ ϕ2 (or ϕ ≡ ϕ1 ∨ ϕ2 , or ϕ ≡ ¬ ), then ϕ 1 =def ϕ11 ∧ ϕ21
(or ϕ 1 ≡ ϕ11 ∨ ϕ21 , or ϕ 1 ≡ ¬ 1 , respectively).
3) If ϕ ≡ ∃x (x), then ϕ 1 =def ∃x(FS(x) ∧ 1 (x)).
4) If ϕ ≡ ∀x (x), then ϕ 1 =def ∀x(FS(x) ⊃ 1 (x)).
5) If ϕ ≡ ∃X (X ), then ϕ 1 =def ∃x(SS(x) ∧ 1 (x)).
6) If ϕ ≡ ∀X (X ), then ϕ 1 =def ∀x(SS(x) ⊃ 1 (x)).
Note that when ϕ is a sentence, then ϕ 1 is also a sentence.
For a set Ψ of L-formulas, let Ψ1 denote the set {ϕ 1 : ϕ ∈ Ψ}. The
lemma above can strengthened as follows.
Theorem IV.5.2. A set Ψ of L-sentences ϕ is satisﬁable iﬀ the set of
ΦL ∪ Ψ1 of L1 -sentences is satisﬁable.
Notice that in the statement of the theorem, Ψ is a set of sentences. In
general, the theorem may not be true if Ψ is a set of formulas.
Proof. For simplicity, we will prove the theorem when Ψ is the set of a
single sentence ϕ. The proof for the general case is similar.
For the ONLY IF direction, for any model M of ϕ we construct a
L1 -structure M1 as in the proof of Lemma IV.5.1. It can be proved by
structural induction on ϕ that M1 |= ϕ 1 . By the lemma, M1 |= ΦL .
Hence M1 |= ΦL ∪ {ϕ 1 }.
For the other direction, suppose that M1 is a model for ΦL ∪ {ϕ 1 }.
Construct the two-sorted L-structure M from M1 as in the remark following the proof of Lemma IV.5.1. Now we can prove by structural induction
on ϕ that M is a model for ϕ. Therefore ϕ is also satisﬁable.
2
Exercise IV.5.3. Prove the Compactness Theorem for the two-sorted
logic (IV.4.7) from the Compactness Theorem for single-sorted logic
(II.4.2).
Exercise IV.5.4. Prove the Herbrand Theorem for the two-sorted logic
(IV.4.8) from Form 2 of the Herbrand Theorem for single-sorted logic
(III.3.13).

IV.6. Notes

93

IV.6. Notes
Historically, Buss [20] was the ﬁrst to use multi-sorted theories to capture complexity classes such as polynomial space and exponential time.
The main reference for Section IV.1 is [59] Sections 1.1, 1.2, 5.5. Our
two-sorted vocabulary L2A is from Zambella [112, 113]. Zambella [112]
states the representation theorems IV.3.6 and IV.3.7, although Theorem IV.3.7 essentially goes back to [111], [50], and [105].

Chapter V

THE THEORY V 0 AND AC 0

In this chapter we introduce the family of two-sorted theories V 0 ⊂ V 1 ⊆
V 2 ⊆ · · · over the vocabulary L2A . For i ≥ 1, V i corresponds to Buss’s
single-sorted theory S2i (Section III.5). The theory V 0 characterizes AC 0
in the same way that IΔ0 characterizes LTH. Similarly V 1 characterizes
P, and in general for i > 1, V i is related to the i-th level of the polynomial
time hierarchy.
Here we concentrate on the theory V 0 , which will serve as the base
theory: all two-sorted theories introduced in this book are extensions
of V 0 . It is axiomatized by the set 2-BASIC of the deﬁning axioms for
the symbols in L2A , together with ΣB0 -COMP (the comprehension axiom
scheme for ΣB0 formulas). For i ≥ 1, V i is the same as V 0 except that
ΣB0 -COMP is replaced by ΣBi -COMP. We show that for i ≥ 0, V i proves
the ΣBi induction scheme, even though it is not explicitly postulated as a
set of axioms. We generalize Parikh’s Theorem, and show that it applies
to each of the theories V i .
The main result of this chapter is that V 0 characterizes AC 0 : The
provably total functions in V 0 are precisely the AC 0 functions. The proof
of this characterization is somewhat more involved than the proof of
the analogous characterization of LTH by IΔ0 (Theorem III.4.8). The
hard part here is the Witnessing Theorem for V 0 , which is proved by
analyzing anchored LK 2 -V 0 proofs. We also give an alternative proof of
0
the witnessing theorem based on the universal conservative extension V
of V 0 , using the Herbrand Theorem.

V.1. Deﬁnition and Basic Properties of V i
The set 2-BASIC of axioms is given in Figure 2. Recall that t < u
stands for (t ≤ u ∧ t = u).
Axioms B1, . . . , B8 are taken from the axioms in 1-BASIC for IΔ0 ,
and B9, . . . , B12 are theorems of IΔ0 (see Examples III.1.8 and III.1.9).
Axioms L1 and L2 characterize |X | to be one more than the largest
element of X , or 0 if X is empty. Axiom SE (extensionality) speciﬁes that
95

96

V. The Theory V 0 and AC 0
B1. x + 1 = 0
B7. (x ≤ y ∧ y ≤ x) ⊃ x = y
B2. x + 1 = y + 1 ⊃ x = y
B8. x ≤ x + y
B3. x + 0 = x
B9. 0 ≤ x
B4. x + (y + 1) = (x + y) + 1 B10. x ≤ y ∨ y ≤ x
B5. x · 0 = 0
B11. x ≤ y ↔ x < y + 1
B6. x · (y + 1) = (x · y) + x
B12. x = 0 ⊃ ∃y ≤ x(y + 1 = x)
L1. X
(y)
⊃
y
<
|X
|
L2.
y + 1 = |X | ⊃ X (y)

SE. |X | = |Y | ∧ ∀i < |X |(X (i) ↔ Y (i)) ⊃ X = Y
Figure 2. 2-BASIC.

sets X and Y are the same if they have the same elements. Note that the
converse
X = Y ⊃ (|X | = |Y | ∧ ∀i < |X |(X (i) ↔ Y (i)))
is valid because in every L2A -structure, =2 must be interpreted as true
equality over the strings.
Exercise V.1.1. Show that the following formulas are provable from
2-BASIC.
(a) ¬x < 0.
(b) x < x + 1.
(c) 0 < x + 1.
(d) x < y ⊃ x + 1 ≤ y. (Use B10, B11, B7.)
(e) x < y ⊃ x + 1 < y + 1.
Deﬁnition V.1.2 (Comprehension Axiom). If Φ is a set of formulas,
then the comprehension axiom scheme for Φ, denoted by Φ-COMP, is the
set of all formulas
∃X ≤ y∀z < y(X (z) ↔ ϕ(z)),

(48)

where ϕ(z) is any formula in Φ, and X does not occur free in ϕ(z).
In the above deﬁnition ϕ(z) may have free variables of both sorts, in
addition to z. We are mainly interested in the cases in which Φ is one of
the formula classes Σ Bi .
Notation. Since (48) states the existence of a ﬁnite set X of numbers,
we will sometimes use standard set-theoretic notation in deﬁning X :
X = {z : z < y ∧ ϕ(z)}.

(49)

Deﬁnition V.1.3 (V i ). For i ≥ 0, the theory V i has the vocabulary L2A
and is axiomatized by 2-BASIC and ΣBi -COMP.
There are no explicit induction axioms for V i , but nevertheless induction is provable (See Corollary V.1.8).

V.1. Deﬁnition and Basic Properties of V i

97

Notation. Since now there are two sorts of variables, there are two
diﬀerent types of induction axioms: One is on numbers, and is deﬁned as
in Deﬁnition III.1.4 (where now Φ is a set of two-sorted formulas), and
one is on strings, which we will discuss later. For this reason, we will speak
of number induction axioms and string induction axioms. Similarly, we will
use the notion of number minimization axioms, which is diﬀerent from the
string minimization axioms (to be introduced later). For convenience we
repeat the deﬁnitions of the axiom schemes for numbers below.
Deﬁnition V.1.4 (Number Induction Axiom). If Φ is a set of two-sorted formulas, then Φ-IND axioms are the formulas


ϕ(0) ∧ ∀x(ϕ(x) ⊃ ϕ(x + 1)) ⊃ ∀zϕ(z)
where ϕ is a formula in Φ.
Deﬁnition V.1.5 (Number Minimization and Maximization Axioms).
The number minimization axioms (or least number principle axioms) for
a set Φ of two-sorted formulas are denoted Φ-MIN and consist of the
formulas


ϕ(y) ⊃ ∃x ≤ y ϕ(x) ∧ ¬∃z < xϕ(z)
where ϕ is a formula in Φ. Similarly the number maximization axioms for
Φ are denoted Φ-MAX and consist of the formulas


ϕ(0) ⊃ ∃x ≤ y ϕ(x) ∧ ¬∃z ≤ y(x < z ∧ ϕ(z))
where ϕ is a formula in Φ.
In the above deﬁnitions, ϕ(x) is permitted to have free variables of both
sorts, in addition to x.
Notice that all axioms of V 0 hold in the standard model N2 (page 79).
In particular, all theorems of V 0 about numbers are true in N. Indeed we
will show that V 0 is a conservative extension of IΔ0 : all theorems of IΔ0
are theorems of V 0 , and all theorems of V 0 over LA are theorems of IΔ0 .
For the ﬁrst direction, note that the above axiomatization of V 0 contains
no explicit induction axioms, so we need to show that it proves the number
induction axioms for the Δ0 formulas. In fact, we will show that it proves
ΣB0 -IND by showing ﬁrst that it proves the X -MIN axiom, where
X -MIN ≡ 0 < |X | ⊃ ∃x < |X |(X (x) ∧ ∀y < x¬X (y)).
Lemma V.1.6. V 0  X -MIN.
Proof. We reason in V 0 : By ΣB0 -COMP there is a set Y such that
|Y | ≤ |X | and for all z < |X |
Y (z) ↔ ∀y ≤ z¬X (y).

(50)

Thus the set Y consists of the numbers smaller than every element in
X . Assuming 0 < |X |, we will show that |Y | is the least member of
X . Intuitively, this is because |Y | is the least number that is larger than

98

V. The Theory V 0 and AC 0

any member of Y . Formally, we need to show: (i) X (|Y |), and (ii)
∀y < |Y |¬X (y). Details are as follows.
First suppose that Y is empty. Then |Y | = 0 by B12 and L2, hence (ii)
holds vacuously by Exercise V.1.1 (a). Also, X (0) holds, since otherwise
Y (0) holds by B7 and B9. Thus we have proved (i).
Now suppose that Y is not empty, i.e., Y (y) holds for some y. Then
y < |Y | by L1, and thus |Y | = 0 by Exercise V.1.1 (a). By B12, |Y | = z +1
for some z and hence (Y (z) ∧ ¬Y (z + 1)) by L1 and L2. Hence by (50)
we have
∀y ≤ z¬X (y) ∧ ∃i ≤ z + 1X (i).
It follows that i = z + 1 in the second conjunct, since if i < z + 1 then
i ≤ z by B11, which contradicts the ﬁrst conjunct. This establishes (i)
and (ii), since i = z + 1 = |Y |.
2
Consider the following instance of ΣB0 -IND:


X -IND ≡ X (0) ∧ ∀y < z(X (y) ⊃ X (y + 1)) ⊃ X (z).
Corollary V.1.7. V 0  X -IND.
Proof. We prove by contradiction. Assume ¬X -IND, then we have for
some z:
X (0) ∧ ¬X (z) ∧ ∀y < z(X (y) ⊃ X (y + 1)).
By ΣB0 -COMP, there is a set Y with |Y | ≤ z + 1 such that
∀y < z + 1(Y (y) ↔ ¬X (y)).
Then Y (z) holds by Exercise V.1.1 (b), so 0 < |Y | by (a) and L1. By
Y -MIN, Y has a least element y0 . Then y0 = 0 because X (0), hence
y0 = x0 + 1 for some x0 , by B12. But then we must have X (x0 ) and
¬X (x0 + 1), which contradicts our assumption.
2
Corollary V.1.8. Let T be an extension of V 0 and Φ be a set of formulas in T . Suppose that T proves the Φ-COMP axiom scheme. Then T
also proves the Φ-IND axiom scheme, the Φ-MIN axiom scheme, and the
Φ-MAX axiom scheme.
Proof. We show that T proves the Φ-IND axiom scheme. This will
show that V 0 proves ΣB0 -IND, and hence extends IΔ0 and proves the
arithmetic properties in Examples III.1.8 and III.1.9. The proof for the
Φ-MIN and Φ-MAX axiom schemes is similar to that for Φ-IND, but
easier since these properties are now available.
Let ϕ(x) ∈ Φ. We need to show that


T  ϕ(0) ∧ ∀y(ϕ(y) ⊃ ϕ(y + 1)) ⊃ ϕ(z).
Reasoning in V 0 , assume
ϕ(0) ∧ ∀y(ϕ(y) ⊃ ϕ(y + 1)).

(51)

V.1. Deﬁnition and Basic Properties of V i

99

By Φ-COMP, there exists X such that |X | ≤ z + 1 and
∀y < z + 1 (X (y) ↔ ϕ(y)).

(52)

By B11, Exercise V.1.1 (c,e) and (51) we conclude from this
X (0) ∧ ∀y < z(X (y) ⊃ X (y + 1)).
Finally X (z) follows from this and X -IND, and so ϕ(z) follows from (52)
and Exercise V.1.1 (b).
2
It follows from the corollary that for all i ≥ 0, V i proves ΣBi -IND,

ΣBi -MIN, and ΣBi -MAX.
0

Theorem V.1.9. V is a conservative extension of IΔ0 .

Proof. The axioms for IΔ0 consist of B1, . . . , B8 and the Δ0 -IND
axioms. Since B1, . . . , B8 are also axioms of V 0 , and we have just shown
that V 0 proves the ΣB0 -IND axioms (which include the Δ0 -IND axioms),
it follows that V 0 extends IΔ0 . To show that V 0 is conservative over IΔ0
(i.e. theorems of V 0 in the vocabulary of IΔ0 are also theorems of IΔ0 ),
we prove the following lemma.
Lemma V.1.10. Any model M for IΔ0 can be expanded to a model M
for V 0 , where the “number” part of M is M.
Note that Theorem V.1.9 follows immediately from the above lemma,
because if ϕ is in the vocabulary of IΔ0 , then the truth of ϕ in M depends
only on the truth of ϕ in M. (See the proof of the Extension by Deﬁnition
Theorem III.3.5.)
2
Proof of Lemma V.1.10. Suppose that M is a model of IΔ0 with universe M = U1 . Recall that IΔ0 proves B1, . . . , B12, so M satisﬁes these
axioms. According to the semantics for L2A (Section IV.2.2), to expand
M to a model M for V 0 we must construct a suitable universe U2 whose
elements are determined by pairs (m, S), where S ⊆ M and m = |S|. In
order to satisfy axioms L1 and L2, if S ∈ U2 is empty, then |S| = 0, and
if S is nonempty, then S must have a largest element s and |S| = s + 1.
Since S ⊆ M and |S| is determined by S, it follows that the extensionality
axiom SE is satisﬁed.
The other requirement for U2 is that the ΣB0 -COMP axioms must be
satisﬁed. We will construct U2 to consist of all bounded subsets of M
deﬁned by Δ0 -formulas with parameters in M . We use the following
conventional notation: If ϕ(x) is a formula and c is an element in M , then
ϕ(c) represents ϕ(x) with a constant symbol (also denoted c) substituted
for x in ϕ, where it is understood that the symbol c is interpreted as the
element c in M . If ϕ(x, y) is a formula and c, d are elements of M , we
use the notation
S(c, ϕ(x, d )) = {e ∈ M |e < c and M satisﬁes ϕ(e, d )}.

V. The Theory V 0 and AC 0

100
Then we deﬁne

U2 = {S(c, ϕ(x, d )) : c, d1 , . . . , dk ∈ M and
ϕ(x, y) is a Δ0 (LA ) formula}. (53)
We must show that every nonempty element S of U2 has a largest
element, so that |S| can be deﬁned to satisfy L1 and L2. The largest
element exists because the diﬀerences between the upper bound c for S and
elements of S have a minimum element, by Δ0 -MIN. Speciﬁcally, if S =
·
S(c, ϕ(x, d )) is nonempty and m is the least z satisfying ϕ(c −
1 −· z, d ),
then deﬁne |S| = ϕ (c, d ) where ϕ (c, d ) = c −· m. Then
ϕ (c, d ) =

sup(S(c, ϕ(x, d )) + 1
0

if S = ∅,
otherwise.

The preceding argument shows that the function ϕ (z, y) is provably total
in IΔ0 .
It remains to show that ΣB0 -COMP holds in M . This means that for
every ΣB0 formula (z, x, Y ) (with all free variables indicated) and for
every vector d of elements of M interpreting x and every vector S of
elements in U2 interpreting Y and for every c ∈ M , the set
T = {e ∈ M : e < c and M |=

(e, d , S)}

(54)

must be in U2 . Suppose that
Si = S(ci , ϕi (u, di ))
for some Δ0 formulas ϕi (x, yi ). Let (z, x, y1 , y2 , . . . , w1 , w2 , . . . ) be the
result of replacing every sub-formula of the form Yi (t) in (z, x, Y ) by
(ϕi (t, yi ) ∧ t < wi ) and every occurrence of |Yi | by ϕi (wi , yi ). (We
may assume that has no occurrence of =2 by replacing every equation
X =2 Z by a ΣB0 formula using the extensionality axiom SE.) Finally let
T = S(c, (z, d , d1 , d2 , . . . , c1 , c2 , . . . )).
Then T satisﬁes (54). Since the functions ϕi are Σ1 -deﬁnable in IΔ0 , by
the Conservative Extension Lemma III.3.10,  can be transformed into
an equivalent Δ0 (LA ) formula. Thus T ∈ U2 .
2
Exercise V.1.11. Suppose that instead of deﬁning U2 according to (53),
we deﬁned U2 to consist of all subsets of M which have a largest element,
together with ∅. Then for each set S ⊂ U1 in U2 we deﬁne |S| in the
obvious way to satisfy axioms L1 and L2. Prove that if M is a nonstandard
model of IΔ0 , then the resulting two-sorted structure (U1 , U2 ) is not a
model of V 0 .
Exercise V.1.12. Suppose that we want to prove that V 0 is conservative
over IΔ0 by considering an anchored LK 2 proof instead of the above
model-theoretic argument. Here we consider a small part of such an

V.2. Two-Sorted Functions

101

argument. Suppose that ϕ is a formula in the vocabulary of IΔ0 and 
is an anchored LK 2 -V 0 proof of −→ ϕ. Suppose (to make things easy)
that no formula in  contains a string quantiﬁer. Show explicitly how to
convert  to an LK-IΔ0 proof  of −→ ϕ.
Since according to Theorem V.1.9 V 0 extends IΔ0 , we will freely use the
results in Chapter III when reasoning in V 0 in the sequel.

V.2. Two-Sorted Functions
Complexity classes of two-sorted relations were discussed in Section
IV.3. Now we associate with each two-sorted complexity class C of relations a two-sorted function class FC. Two-sorted functions are either
number functions or string functions. A number function f(x, Y ) takes
values in N, and a string function F (x, Y ) takes ﬁnite subsets of N as
values.
Deﬁnition V.2.1. A function f or F is polynomially bounded (or pbounded) if there is a polynomial p(x, y) such that f(x, Y ) ≤ p(x, |Y |)
or |F (x, Y )| ≤ p(x, |Y |).
All function complexity classes we consider here contain only p-bounded functions.
In deﬁning the functions associated with a complexity class of relations
the natural relation to use for a number function is its graph. However
this does not work well for string functions. For example the function
F (X ) which gives the prime factorization of X (considered as a binary
number) is not known to be polynomial time computable, but its graph is
a polynomial time relation. It turns out that the right relation to associate
with a string function is its bit graph.
Deﬁnition V.2.2 (Graph, Bit Graph). The graph Gf of a number function f(x, Y ) is deﬁned by
Gf (z, x, Y ) ↔ z = f(x, Y ).
The bit graph BF of a string function F (x, Y ) is deﬁned by
BF (i, x, Y ) ↔ F (x, Y )(i).
Deﬁnition V.2.3 (Function Class). If C is a two-sorted complexity
class of relations, then the corresponding function class FC consists of
all p-bounded number functions whose graphs are in C, together with all
p-bounded string functions whose bit graphs are in C.
In particular, the string functions in FAC 0 are those p-bounded functions whose bit graphs are in AC 0 . The nonuniform version FAC 0 /poly
has a nice circuit characterization like that of AC 0 /poly (see page 75).

102

V. The Theory V 0 and AC 0

Thus a string function F (X ) is in FAC 0 /poly iﬀ there is a polynomial size
bounded depth family Cn  of Boolean circuits (with unbounded fan-in
∧-gates and ∨-gates) such that each Cn has n input bits specifying the
input string X , and the output bits of Cn specify the string F (X ).
The following characterization of FAC 0 follows from the above deﬁnitions and the ΣB0 Representation Theorem (Theorem IV.3.6).
Corollary V.2.4. A string function is in FAC 0 if and only if it is pbounded, and its bit graph is represented by a ΣB0 formula. The same holds
for a number function, with graph replacing bit graph.
An interesting example of a string function in FAC 0 is binary addition.
Note that as in (46) we can treat a ﬁnite subset X ⊂ N as the natural
number
bin(X ) =
X (i)2i
i

where we write 0 for ⊥ and 1 for . We will write X +Y for the string function “binary addition”, so X + Y = bin(X ) + bin(Y ). Let Carry(i, X, Y )
hold iﬀ there is a carry into bit position i when computing X + Y . Then
Carry(i, X, Y ) is represented by the ΣB0 formula given in (47).
The bit graph of X + Y can be deﬁned as follows.
Example V.2.5 (Bit Graph of String Addition). The bit graph of X +Y
is



(X + Y )(i) ↔ i < |X | + |Y | ∧ (X (i) ⊕ Y (i) ⊕ Carry(i, X, Y )) (55)

where p ⊕ q ≡ ((p ∧ ¬q) ∨ (¬p ∧ q)).
In general, the graph GF (x, Y , Z) ≡ (Z = F (x, Y )) of a string function F (x, Y ) can be deﬁned from its bit graph as follows:
GF (x, Y , Z) ↔ ∀i (Z(i) ↔ BF (i, x, Y )).
So if F is polynomially bounded and its bit graph is in AC 0 , then its
graph is also in AC 0 , because


GF (x, Y , Z) ↔ |Z| ≤ t ∧ ∀i < t (Z(i) ↔ BF (i, x, Y ))
(56)
where t is the bound on the length of F .
As we noted earlier (Section IV.1), the relation R× is not in AC 0 , where
R× (X, Y, Z) ↔ bin(X ) · bin(Y ) = bin(Z)
(because PARITY, which is not in AC 0 , is reducible to it). As a result,
the bit graph of (X × Y )(i) is not representable by any ΣB0 formula, where
X × Y = bin(X ) · bin(Y ) is the string function “binary multiplication”.
If a string function F (X ) is polynomially bounded, it is not enough to
say that its graph is an AC 0 relation in order to ensure that F ∈ FAC 0 .
For example, let M be a ﬁxed polynomial-time Turing machine, and deﬁne
F (X ) to be a string coding the computation of M on input X . If the

103

V.2. Two-Sorted Functions

computation is nicely encoded then F (X ) is polynomially bounded and
the graph Y = F (X ) is an AC 0 relation, but if the Turing machine
computes a function not in AC 0 (such as the number of ones in X ) then
F ∈ FAC 0 .
For the same reason that the numerical AC 0 relations in the two-sorted
setting are precisely the LTH relations in the single-sorted setting (see
the proof of the ΣB0 Representation Theorem, IV.3.6), number functions
with no string arguments are AC 0 functions iﬀ they are single-sorted LTH
functions.
The nonuniform version of FAC 0 consists of functions computable by
bounded-depth polynomial-size circuits, and it is clear from this deﬁnition
that the class is closed under composition. It is also clear that nonuniform AC 0 is closed under substitution of (nonuniform) AC 0 functions for
parameters. These are some of the natural properties that also hold for
uniform AC 0 and FAC 0 .
Exercise V.2.6. Show that a number function f(x, X ) is in FAC 0 if and
only if
f(x, X ) = |F (x, X )|
for some string function F (x, X ) in FAC 0 .
Theorem V.2.7. (a) The AC 0 relations are closed under substitution of
AC 0 functions for variables.
(b) The AC 0 functions are closed under composition.
(c) The AC 0 functions are closed under deﬁnition by cases, i.e., if ϕ is an
AC 0 relation, g, h and G, H are functions in FAC 0 , then the functions
f and F deﬁned by
f=

g
h

if ϕ,
otherwise

F =

G
H

if ϕ,
otherwise

are also in FAC 0 .
Proof. We will prove (a) for the case of substituting a string function
for a string variable. The case of substituting a number function for a
number variable is left as an easy exercise. Part (b) follows easily from
part (a). We leave part (c) as an exercise.
Suppose that R(x, X , Y ) is an AC 0 relation and F (x, X ) an AC 0 function. We need to show that the relation Q(x, X ) ≡ R(x, X , F (x, X )) is
also an AC 0 relation, i.e., it is representable by some ΣB0 formula.
By the ΣB0 Representation Theorem (IV.3.6) there is a ΣB0 formula
ϕ(x, X , Y ) that represents R:
R(x, X , Y ) ↔ ϕ(x, X , Y ).

104

V. The Theory V 0 and AC 0

By Corollary V.2.4 there is a ΣB0 formula (i, x, X ) and a number term
t(x, X ) such that
F (x, X )(i) ↔ i < t(x, X ) ∧ (i, x, X ).

(57)

It follows from Exercise V.2.6 that the relation z = |F (x, X )| is represented
by a ΣB0 formula , so
z = |F (x, X )| ↔ (z, x, X ).

(58)

The ΣB0 formula that represents the relation Q(x, X ) is obtained from
ϕ(x, X , Y ) by successively eliminating each occurrence of Y using (57)
and (58) as follows.
First eliminate all atomic formulas of the form Y = Z (or Z = Y )
in ϕ by replacing them with equivalent formulas using the extensionality
axiom SE. Thus
Y = Z ↔ (|Y | = |Z|) ∧ ∀i < |Y |(Y (i) ↔ Z(i)).
Now Y can only occur in the form |Y | or Y (r), for some term r. Any
occurrence of |Y | in ϕ(x, X , Y ) must be in the context of an atomic
formula (x, X , |Y |), which we replace with
∃z ≤ t(x, X ) ((z, x, X ) ∧ (x, X , z)).
Finally we replace each occurrence of Y (r) in ϕ(x, X , Y ) by
r < t(x, X ) ∧ (r, x, X ).
The result is a ΣB0 formula which represents Q(x, X ).

2

Exercise V.2.8. Prove part (a) of Theorem V.2.7 for the case of substitution of number functions for variables. Also prove parts (b) and (c) of
the theorem.

V.3. Parikh’s Theorem for Two-Sorted Logic
Recall (Section III.2) that a term t(x) is a bounding term for a function
symbol f in a single-sorted theory T if
T  ∀x f(x) ≤ t(x).
For a two-sorted theory T whose vocabulary is an extension of L2A , we say
that a number term t(x, X ) is a bounding term for a number function f
in T if
T  ∀x∀X f(x, X ) ≤ t(x, X ).
Also, t(x, X ) is a bounding term for a string function F in T if
T  ∀x∀X |F (x, X )| ≤ t(x, X ).

V.3. Parikh’s Theorem for Two-Sorted Logic

105

Deﬁnition V.3.1. A number function or a string function is polynomially bounded in T if it has a bounding term in the vocabulary L2A .
Exercise V.3.2. Let T be a two-sorted theory over the vocabulary L ⊇
L2A . Suppose that T extends IΔ0 . Show that if the functions of L are
polynomially bounded in T , then for each number term s(x, X ) and
string term T (x, X ) of L, there is an L2A -number term t(x, X ) such that
T  ∀x∀X s(x, X ) ≤ t(x, X ) and T  ∀x∀X |T (x, X )| ≤ t(x, X ).
Note that a bounded formula is one in which every quantiﬁer (both
string and number quantiﬁers) is bounded. Recall the deﬁnition of a
polynomial-bounded single-sorted theory (Deﬁnition III.2.2).
In two-sorted logic, a polynomial-bounded theory is required to extend
V 0 . The formal deﬁnition follows.
Deﬁnition V.3.3 (Polynomial-Bounded Two-Sorted Theory). Let T
be a two-sorted theory over the vocabulary L. Then T is a polynomialbounded theory if (i) it extends V 0 ; (ii) it can be axiomatized by a set of
bounded formulas; and (iii) each function f or F in L is polynomially
bounded in T .
Note that each theory V i , i ≥ 0, is a polynomial-bounded theory.
In fact, all two-sorted theories considered in this book are polynomialbounded.
Theorem V.3.4 (Parikh’s Theorem, Two-Sorted Case). Suppose that T
is a polynomial-bounded theory and ϕ(x, y, X , Y ) is a bounded formula
with all free variables indicated such that
T  ∀x∀X ∃y∃Y ϕ(x, y, X , Y ).

(59)

T  ∀x∀X ∃y ≤ t∃Y ≤ tϕ(x, y, X , Y )

(60)

Then

for some L2A -term t = t(x, X ) containing only the variables (x, X ).
It follows from Exercise V.3.2 that the bounding term t can be taken to
be a term in L2A .
It suﬃces to prove the following simple form of the above theorem.
Lemma V.3.5. Suppose that T is a polynomial-bounded theory, and
ϕ(z, x, X ) is a bounded formula with all free variables indicated such that
T  ∀x∀X ∃zϕ(z, x, X ).
Then
T  ∀x∀X ∃z ≤ t(x, X )ϕ(z, x, X )
for some term t(x, X ) with all variables indicated.

106

V. The Theory V 0 and AC 0

Proof of Parikh’s Theorem from Lemma V.3.5. Deﬁne (omitting x
and X )
(z) ≡ ∃y ≤ z∃Y ≤ zϕ(y, Y ).
From the assumption (59) we conclude that T  ∃z (z), since we can
take
z = y1 + · · · + yk + |Y1 | + · · · + |Y |.
Since ϕ is a bounded formula,
is also a bounded formula. By the
lemma, we conclude that T proves ∃z ≤ t (z), where the variables in t
satisfy Parikh’s Theorem. Thus (60) follows.
2
Proof of Lemma V.3.5. The proof is the same as the proof of Parikh’s
Theorem in the single-sorted logic (page 46), with minor modiﬁcations.
Refer to Section IV.4 for the system LK 2 . Here we consider an anchored
LK 2 -T proof  of ∃zϕ(z, a, α), where T is the set of all term substitution
instances of axioms of T (note that now we have both the substitution of
number terms for number variables and string terms for string variables).
We assume that  is in free variable normal form (see Section IV.4.1).
We convert  to a proof  by converting each sequent S in  into a
sequent S  and providing an associated derivation D(S), where S  and
D(S) are deﬁned by induction on the depth of S in  so that the following
is satisﬁed:
Induction Hypothesis. If S has no occurrence of ∃yϕ, then S  = S. If
S has one or more occurrences of ∃yϕ, then S  is a sequent which is the
same as S except all occurrences of ∃yϕ are replaced by a single occurrence
of ∃y ≤ tϕ, where t is an L2A -number term that depends on S and the
placement of S in . Further every variable in t occurs free in the original
sequent S.
As discussed in Section IV.4.1, if the underlying vocabulary has no string
constant symbol (for example L2A ), then we allow the string constant ∅
to occur in , in order to assume that it is in free variable normal form.
Thus the bounding term t in the endsequent −→ ∃y ≤ tϕ may contain
∅. Since t is an L2A (∅)-term, each occurrence of ∅ is in the context |∅|,
and hence can be replaced by 0 using the axiom E: |∅| = 0.
The Cases I–V are supplemented to consider the four string quantiﬁer
rules, which are treated in the same way as their LK counterparts.
2

V.4. Deﬁnability in V 0
Recall the notion of Φ-deﬁnable single-sorted function (Deﬁnition
III.3.2). For a two-sorted theory T , this notion is deﬁned in the same
way for functions of each sort, and in particular T must be able to prove
existence and uniqueness of function values.

V.4. Deﬁnability in V 0

107

Deﬁnition V.4.1 (Two-Sorted Deﬁnability). Let T be a theory with
vocabulary L ⊇ L2A , and let Φ be a set of L-formulas. A number function
f is Φ-deﬁnable in T if there is a formula ϕ(x, y, X ) in Φ such that
T  ∀x∀X ∃!yϕ(x, y, X )

(61)

y = f(x, X ) ↔ ϕ(x, y, X ).

(62)

and

A string function F is Φ-deﬁnable in T if there is a formula ϕ(x, X , Y ) in
Φ such that
T  ∀x∀X ∃!Yϕ(x, X , Y )

(63)

Y = F (x, X ) ↔ ϕ(x, X , Y ).

(64)

and

Then (62) is a deﬁning axiom for f and (64) is a deﬁning axiom for F ,
and we write T (f) or T (F ) for the theory extending T by adding f or F
and its corresponding deﬁning axiom to T . We say that f or F is deﬁnable
in T if it is Φ-deﬁnable in T for some Φ.
Note that if f (or F ) is in L then it can be trivially deﬁned in any theory
over L by the formula y = f(x, X ) (or Y = F (x, X )).
Theorem V.4.2 (Two-Sorted Extension by Deﬁnition). T (f) and T (F)
(as deﬁned above) are conservative extensions of T .
Proof. This is proved in the same way as its single-sorted version Theorem III.3.5.
2
If Φ is the set of all L2A -formulas, then every arithmetical function
(that is, every function whose graph is represented by an L2A -formula)
is Φ-deﬁnable in V 0 . To see this, suppose that F (x, X ) has deﬁning
axiom (64). Then the graph of F is also deﬁned by the following formula
ϕ  (x, X , Y ):
(∃!Zϕ(x, X , Z) ∧ ϕ(x, X , Y )) ∨ (¬∃!Zϕ(x, X , Z) ∧ Y = ∅).
Then (63) with ϕ  for ϕ is trivially provable in V 0 .
We want to choose a standard class Φ of formulas such that the class of
Φ-deﬁnable functions in a theory T depends nicely on the proving power
of T , so that various complexity classes can be characterized by ﬁxing Φ
and varying T . In single-sorted logic, our choice for Φ was Σ1 , and we
deﬁned the provably total functions of T to be the Σ1 -deﬁnable functions
in T . Here our choice for Φ is Σ11 (recall (Deﬁnition IV.3.2) that a Σ11
formula is a formula of the form ∃X ϕ, where ϕ is a ΣB0 formula). The
notion of a provably total function in two-sorted logic is deﬁned as follows.

108

V. The Theory V 0 and AC 0

Deﬁnition V.4.3 (Provably Total Function). A function (which can be
either a number function or a string function) is said to be provably total
in a theory T iﬀ it is Σ11 -deﬁnable in T .
If T consists of all formulas of L2A which are true in the standard model
N2 , then the functions provably total in T are precisely all total functions
computable on a Turing machine. The idea here is that the existential
string quantiﬁers in a Σ11 formula can be used to code the computation
of a Turing machine computing the function. If T is a polynomially
bounded theory, then both the function values and the computation must
be polynomially bounded. In fact, the following result in a corollary of
Parikh’s Theorem.
Corollary V.4.4. Let T be a polynomial-bounded theory. Then all provably total functions in T are polynomially bounded. A function is provably
total in T iﬀ it is ΣB1 -deﬁnable in T .
We will show that the provably total functions in V 0 are precisely the
functions in FAC 0 , and in the next chapter we will show that the provably
total functions in V 1 are precisely the polynomial time functions. Later
we will give similar characterizations of other complexity classes.
Exercise V.4.5. Show that for any theory T whose vocabulary includes
L2A , the set of provably total functions of T is closed under composition.
In two-sorted logic, for string functions we have the notion of a bitdeﬁnable function in addition to that of a deﬁnable function.
Deﬁnition V.4.6 (Bit-deﬁnable Function). Let Φ be a set of L formulas
where L ⊇ L2A . We say that a string function symbol F (x, Y ) not in L
is Φ-bit-deﬁnable from L if there is a formula ϕ(i, x, Y ) in Φ and an
L2A -number term t(x, Y ) such that the bit graph of F satisﬁes
F (x, Y )(i) ↔ (i < t(x, Y ) ∧ ϕ(i, x, Y )).

(65)

We say that the formula on the RHS of (65) is a bit-deﬁning axiom, or bit
deﬁnition, of F .
The choice of ϕ and t in the above deﬁnition is not uniquely determined
by F . However we will assume that a speciﬁc formula ϕ and a speciﬁc
number term t has been chosen, so we will speak of the bit-deﬁning axiom,
or the bit deﬁnition, of F . Note also that such a F is polynomially bounded
in T , and t is a bounding term for F .
The following proposition follows easily from the above deﬁnition and
Corollary V.2.4.
Proposition V.4.7. A string function is ΣB0 -bit-deﬁnable iﬀ it is in FAC 0 .
Exercise V.4.8. Let T be a theory which extends V 0 and proves the
bit-deﬁning axiom (65) for a string function F , where ϕ is a ΣB0 formula.

V.4. Deﬁnability in V 0

109

Show that there is a ΣB0 formula (z, x, Y ) such that T proves
z = |F (x, Y )| ↔ (z, x, Y ).
It is important to distinguish between a “deﬁnable function” and a
“bit-deﬁnable function”. In particular, if a theory T2 is obtained from a
theory T1 by adding a Φ-bit-deﬁnable function F together with its bitdeﬁning axiom (65), then in general we cannot conclude that T2 is a
conservative extension of T1 . For example, it is easy to show that the
string multiplication function X × Y has a ΣB1 bit deﬁnition. However, as
we noted earlier, this function is not ΣB1 -deﬁnable in V 0 . The theory that
results from adding this function together with its ΣB1 -bit-deﬁnition to V 0
is not a conservative extension of V 0 .
To get deﬁnability, and hence conservativity, it suﬃces to assume that T1
proves a comprehension axiom scheme. The following deﬁnition is useful
here and in Chapter VI.
Deﬁnition V.4.9 (ΣB0 -Closure). Let Φ be a set of formulas over a vocabulary L which extends L2A . Then ΣB0 (Φ) is the closure of Φ under the
operations ¬, ∧, ∨ and bounded number quantiﬁcation. That is, if ϕ and
are formulas in ΣB0 (Φ) and t is an L2A -term not containing x, then the
following formulas are also in ΣB0 (Φ): ¬ϕ, (ϕ ∧ ), (ϕ ∨ ), ∀x ≤ tϕ,
and ∃x ≤ tϕ.
Lemma V.4.10 (Extension by Bit Deﬁnition). Let T be a theory over L
that contains V 0 , and Φ be a set of L-formulas such that Φ ⊇ ΣB0 . Suppose
that T proves the Φ-COMP axiom scheme. Then any polynomially bounded
number function whose graph is Φ-representable, or a polynomially bounded
string function whose bit graph is Φ-representable, is ΣB0 (Φ)-deﬁnable in T .
Proof. Consider the case of a string function. Suppose that F is a
polynomially bounded string function with bit graph in Φ, so there are an
L2A -number term t and a formula ϕ ∈ Φ such that
F (x, Y )(i) ↔ (i < t(x, Y ) ∧ ϕ(i, x, Y )).
As in (56), the graph GF of F can be deﬁned as follows:
GF (x, Y , Z) ≡ |Z| ≤ t ∧ ∀i < t (Z(i) ↔ ϕ(i, x, Y )).

(66)

Now since T proves the Φ-COMP, we have
T  ∀x∀Y ∃Z GF (x, Y , Z).

(67)

Also T proves that such Z is unique, by the extensionality axiom SE in
2-BASIC. Since the formula GF (x, Y , Z) is in ΣB0 (Φ), it follows that F is
ΣB0 (Φ)-deﬁnable in T .
Next consider the case of a number function. Let f be a polynomially
bounded number function whose graph is in Φ, so there are an L2A -number

110

V. The Theory V 0 and AC 0

term t and a formula ϕ ∈ Φ such that
y = f(x, X ) ↔ (y < t(x, X ) ∧ ϕ(y, x, X )).
By Corollary V.1.8, T proves the Φ-MIN axiom scheme. Therefore f is
deﬁnable in T by using the following ΣB0 (Φ) formula for its graph:
Gf (y, x, X ) ≡ (∀z < y¬ϕ(z, x, X )) ∧ (y < t ⊃ ϕ(y, x, X ))

(68)

(i.e., y is the least number < t such that ϕ(y) holds, or t if no such y
exists).
2
0
B
B
B
In this lemma, if we take T = V and Φ = Σ0 , then (since Σ0 (Σ0 ) =
ΣB0 ) we can apply Corollary V.2.4 and Proposition V.4.7 to obtain the
following:
Corollary V.4.11. Every function in FAC 0 is ΣB0 -deﬁnable in V 0 .
This result can be generalized, using the following deﬁnition.
Deﬁnition V.4.12. 3 A string function is ΣB0 -deﬁnable from a collection
L of two-sorted functions and relations if it is p-bounded and its bit graph
is represented by a ΣB0 (L) formula. Similarly, a number function is ΣB0 deﬁnable from L if it is p-bounded and its graph is represented by a ΣB0 (L)
formula.
This “semantic” notion of ΣB0 -deﬁnability should not be confused with
B
Σ0 -deﬁnability in a theory (Deﬁnition V.4.1), which involves provabililty.
The next result connects the two notions.
Corollary V.4.13. Let T be a theory over L that contains V 0 , and
suppose that T proves the ΣB0 (L)-COMP axiom scheme. Then a function
which is ΣB0 -deﬁnable from L is ΣB0 (L)-deﬁnable in T .
In Section V.5 we will prove the Witnessing Theorem for V 0 , which says
that any Σ11 -deﬁnable function of V 0 is in FAC 0 . This will complete our
characterization of FAC 0 by V 0 . (Compare this with Proposition V.4.7,
which characterizes FAC 0 in terms of bit-deﬁnability, independent of any
theory.)
Corollary V.4.14. Suppose that the theory T proves ΣB0 (L)-COMP,
where L is the vocabulary of T . Then the theory resulting from T by adding
the ΣB0 (L)-deﬁning axioms or the ΣB0 (L)-bit-deﬁning axioms for a collection
of number functions and string functions is a conservative extension of T .
The following result shows in particular that if we extend V 0 by a
sequence of ΣB0 deﬁning axioms and bit-deﬁning axioms, the resulting
theory is not only conservative over V 0 , it also proves the ΣB0 (L)-COMP
and ΣB0 (L)-IND axioms, where L is the resulting vocabulary. We state it
generally for ΣBi (L) formulas.
3 This notion is important for our deﬁnition of AC 0 reduction, Deﬁnition IX.1.1.

V.4. Deﬁnability in V 0

111

Lemma V.4.15 (ΣB0 -Transformation). Let T be a polynomial-bounded
theory which extends V 0 , and assume that the vocabulary L of T has the
same predicate symbols as L2A . Suppose that for every number function f
in L, T proves a ΣB0 (L2A ) deﬁning axiom for f, and for every string function
F in L, T proves a ΣB0 (L2A ) bit-deﬁning axiom for F . Then for every i ≥ 0
and every ΣBi (L) formula ϕ + there is a ΣBi (L2A ) formula ϕ such that
T  ϕ + ↔ ϕ.
Proof. We prove the conclusion for the case i = 0. The case i > 0
follows immediately from this case. We may assume by the axiom SE
that ϕ + does not contain =2 . We proceed by induction on the maximum
nesting depth of any function symbol in ϕ + , where in deﬁning nesting
depth we only count functions which are in L but not in L2A . The base
case is nesting depth 0, so ϕ + is already a ΣB0 (L2A ) formula, and there is
nothing to prove.
For the induction step, assume that ϕ + has at least one occurrence of
a function not in L2A . It suﬃces to consider the case in which ϕ + is an
atomic formula. Since by assumption the only predicate symbols in L are
those in L2A , the only predicate symbols we need consider are , =, ≤. First
consider the case ∈, so ϕ + has the form F (t, T )(s). Then by assumption
T proves a bit deﬁnition of the form
F (x, X )(i) ↔ (i < r(x, X ) ∧ (i, x, X ))
where r is an L2A term and

is a ΣB0 (L2A ) formula. Then T proves

ϕ + ↔ (s < r(t, T ) ∧ (s, t, T )).
The RHS has nesting depth at most that of ϕ + and t, T have smaller
nesting depth, and hence we have reduced the induction step to the case
that ϕ + has the form (s) where (x) is an atomic formula over L2A and
each term si has one of the forms f(t, T ), for f not in L2A , or |F (t, T )|. In
either case, using the deﬁning axiom for f or Exercise V.4.8, for each term
si there is a ΣB0 (L2A ) formula i (z, x, X ) and a bounding term ri (x, X ) of
L2A such that T proves
z = si ↔ (z < ri (t, T ) ∧ i (z, t, T )).
Hence (since ϕ + is (s )), T proves

ϕ + ↔ ∃z < r(t, T ) (z) ∧


i (zi , t, T ) .
i

Thus we have reduced the nesting depth of ϕ + , and we can apply the
induction hypothesis.
2
The following result is immediate from the preceding lemma, Deﬁnitions V.4.12 and V.2.3, and the ΣB0 Representation Theorem IV.3.6.

V. The Theory V 0 and AC 0

112

Corollary V.4.16 (FAC 0 Closed under ΣB0 -Deﬁnability). Every function ΣB0 -deﬁnable from a collection of FAC 0 functions is in FAC 0 .
Below we give ΣB0 -bit-deﬁnitions of the string functions ∅ (zero, or
empty string), S(X ) (successor), X + Y and several other useful AC 0
functions: Row, seq, left and right. Each of these functions is ΣB0 -deﬁnable
in V 0 , and the above lemmas and corollaries apply.
Example V.4.17 (∅, S, +). The string constant ∅ has bit deﬁning axiom
∅(z) ↔ z < 0.
Binary successor S(X ) has bit-deﬁning axiom


S(X )(i) ↔ i ≤ |X |∧((X (i)∧∃j < i¬X (j))∨(¬X (i)∧∀j < iX (j))) .
Recall from (55) that binary addition X + Y has the following bit-deﬁning
axiom:


(X + Y )(i) ↔ i < |X | + |Y | ∧ (X (i) ⊕ Y (i) ⊕ Carry(i, X, Y ))
where ⊕ is exclusive OR, and


Carry(i, X, Y ) ≡ ∃k < i X (k)∧Y (k)∧∀j < i(k < j ⊃ (X (j)∨Y (j))) .
Exercise V.4.18. Show that V 0 proves
¬Carry(0, X, Y ) ∧
Carry(i + 1, X, Y ) ↔ MAJ (Carry(i, X, Y ), X (i), Y (i))
where the Boolean function MAJ (P, Q, R) holds iﬀ at least two of P, Q, R
are true. This formula gives a recursive deﬁnition of Carry which is the
binary analog to the school method for computing carries in decimal
addition.
Exercise V.4.19. Let V 0 (∅, S, +) be V 0 extended by ∅, S, + and their
bit-deﬁning axioms. Show that the following are theorems of V 0 (∅, S, +):
(a) X + ∅ = X .
(b) X + S(Y ) = S(X + Y ) Use the previous exercise, and the fact that
in computing the successor of a binary number the lowest order 0
turns to 1, the 1’s to the right turn to 0’s, and the other bits remain
the same. Compare the positions of this lowest order 0 in X and in
X + Y.
(c) X + Y = Y + X (Commutativity).
(d) (X + Y ) + Z = X + (Y + Z) (Associativity).
For Associativity, ﬁrst show in V 0 (+) that
Carry(i, Y, Z) ⊕ Carry(i, X, Y + Z) ↔
Carry(i, X, Y ) ⊕ Carry(i, X + Y, Z).
Derive a stronger statement than this, and prove it by induction on i.

V.4. Deﬁnability in V 0

113

Example V.4.20 (The Pairing Function). We deﬁne the pairing function x, y as the following term of IΔ0 :
x, y =def (x + y)(x + y + 1) + 2y.

(69)

Exercise V.4.21. Show using results in Section III.1 that IΔ0 proves
x, y is a one-one function. That is
IΔ0  x1 , y1  = x2 , y2  ⊃ x1 = x2 ∧ y1 = y2 .

(70)

(First show that the LHS implies x1 + y1 = x2 + y2 .)
In general we can “pair” more than 2 numbers, e.g., deﬁne
x1 , . . . , xk+1  = x1 , . . . , xk , xk+1 .
We will refer to the term x1 , . . . , xk+1  as a tupling function.
For any constant k ∈ N, k ≥ 2, we can use the tupling function to code
a k-dimensional bit array by a single string Z by deﬁning
Notation.
Z(x1 , . . . , xk ) =def Z(x1 , . . . , xk ).

(71)

Example V.4.22 (The Projection Functions). Consider the (partial)
projection functions:
y = left(x) ↔ ∃z ≤ x (x = y, z),
z = right(x) ↔ ∃y ≤ x (x = y, z).
To make these functions total, we deﬁne
left(x) = right(x) = 0

if ¬Pair(x)

where
Pair(x) ≡ ∃y ≤ x∃z ≤ x (x = y, z).
For constants n and k ≤ n, if x codes an n-tuple, then the k-th component
xnk of x can be extracted using left and right, e.g.,
x32 = right(left(x)).
Exercise V.4.23. Use Exercise V.4.21 to show that left(x) and right(x)
are ΣB0 -deﬁnable in IΔ0 . Show that IΔ0 (left,right) proves the following
properties of Pair and the projection functions:
(a) ∀y∀zPair(y, z).
(b) ∀x(Pair(x) ⊃ x = left(x), right(x)).
(c) x = x1 , x2  ⊃ (x1 = left(x) ∧ x2 = right(x)).
Now we can generalize the ΣB0 -comprehension axiom scheme to multiple
dimensions.

V. The Theory V 0 and AC 0

114

Deﬁnition V.4.24 (Multiple Comprehension Axiom). If Φ is a set of
formulas, then the multiple comprehension axiom scheme for Φ, denoted
by Φ-MULTICOMP, is the set of all formulas
∃X ≤ y1 , . . . , yk ∀z1 < y1 . . . ∀zk < yk (X (z1 , . . . , zk ) ↔ ϕ(z1 , . . . , zk ))
(72)
where k ≥ 2 and ϕ(z) is any formula in Φ which may contain other free
variables, but not X .
Lemma V.4.25 (Multiple Comprehension). Suppose that T ⊇ V 0 is a
theory with vocabulary L which proves the ΣB0 (L)-COMP axioms. Then T
proves the ΣB0 (L)-MULTICOMP axioms.
Proof. For the case L = L2A we could work in the conservative extension T (left,right) and apply Lemma V.4.15 to prove this. However for
general L we use another method.
For simplicity we prove the case k = 2. Deﬁne (z) by
(z) ≡ ∃z1 ≤ z∃z2 ≤ z(z = z1 , z2  ∧ ϕ(z1 , z2 )).
Now by ΣB0 -COMP,
T  ∃X ≤ y1 , y2 ∀z < y1 , y2 (X (z) ↔
By Exercise V.4.21, T proves that such X satisﬁes (72).

(z)).
2

Notice that the string X in (72) is not unique, because there are numbers z < y1 , . . . , yk  which are not of the form z1 , . . . , zk  (the pairing
function (69) is not surjective). This, however, is not important, since
we will be using only the truth values of X (z) where z = z1 , . . . , zk  for
zi < yi , 1 ≤ i ≤ k. (A unique such X can be deﬁned as in the proof
above.)
Now we introduce the string function Row(x, Z) (or Z [x] ) in FAC 0 to
represent row x of the binary array Z.
Deﬁnition V.4.26 (Row and V 0 (Row)). The function Row(x, Z) (also
denoted Z [x] ) has the bit-deﬁning axiom
Row(x, Z)(i) ↔ (i < |Z| ∧ Z(x, i)).

(73)

V 0 (Row) is the extension of V 0 obtained from V 0 by adding to it the string
function Row and its ΣB0 -bit-deﬁnition (73).
Note that by Corollary V.4.14, V 0 (Row) is a conservative extension of
V .
The next result follows immediately from Lemma V.4.15.
0

Lemma V.4.27 (Row Elimination). For every ΣB0 (Row) formula ϕ, there
is ΣB0 formula ϕ  such that V 0 (Row)  ϕ ↔ ϕ  . Hence V 0 (Row) proves the
ΣB0 (Row)-COMP axiom scheme.

V.4. Deﬁnability in V 0

115

We can use Row to represent a tuple X1 , . . . , Xk of strings by a single
string Z, where Xi = Z [i] . The following result follows immediately from
the Multiple Comprehension Lemma.
Lemma V.4.28. V 0 (Row) proves
∀X1 . . . ∀Xk ∃Z ≤ t(X1 = Z [1] ∧ · · · ∧ Xk = Z [k] )

(74)

where t = k, |X1 | + · · · + |Xk |.

2

Deﬁnition V.4.29. A single-ΣB1 (L) formula is one of the form ∃X ≤ tϕ,
where ϕ is ΣB0 (L).
Exercise V.4.30. Let T be a polynomial-bounded theory with vocabulary L such that T extends V 0 (Row). Prove that for every ΣB1 (L) formula
ϕ there is a single-ΣB1 (L) formula ϕ  such that T  ϕ ↔ ϕ  .
Now use Lemma V.4.27 to show that the same is true when T is V 0 and
L is L2A .
Just as we use a “two-dimensional” string Z(x, y) to code a sequence
Z [0] , Z [1] , . . . of strings, we use a similar idea to allow Z to code a sequence
y0 , y1 , . . . of numbers. Now yi is the smallest element of Z [i] , or |Z| if
Z [i] is empty. We deﬁne an AC 0 function seq(i, Z) (also denoted (Z)i ) to
extract yi .
Deﬁnition V.4.31 (Coding a Bounded Sequence of Numbers). The
number function seq(x, Z) (also denoted (Z)x ) has the deﬁning axiom:
y = seq(x, Z) ↔ (y < |Z| ∧ Z(x, y) ∧
∀z < y¬Z(x, z)) ∨ (∀z < |Z|¬Z(x, z) ∧ y = |Z|).
It is easy to check that V 0 proves the existence and uniqueness of y
satisfying the RHS of the above formula, and hence seq is ΣB0 -deﬁnable in
V 0 . As in the case of Row, it follows from Lemma V.4.15 that any ΣB0 (seq)
formula is provably equivalent in V 0 (seq) to a ΣB0 (L2A ) formula. (See also
the AC 0 Elimination Lemma V.6.7 for a more general result.)
V.4.1. Δ11 -Deﬁnable Predicates. Recall the notion of a Φ-deﬁnable (or
Φ-representable) predicate symbol, where Φ is a class of formulas (Definition III.3.2). Recall also that we obtain a conservative extension of a
theory T by adding to it a deﬁnable predicate symbol P and its deﬁning
axiom. Below we deﬁne the notions of a “Δ11 (L)-deﬁnable predicate symbol” and a “ΔB1 (L)-deﬁnable predicate symbol”. Note that here Δ11 (L)
and ΔB1 (L) depend on the theory T , in contrast to Deﬁnition III.3.2.
Deﬁnition V.4.32 (Δ11 (L) and ΔB1 (L) Deﬁnable Predicate). Let T be a
theory over the vocabulary L and P a predicate symbol not in L. We say
that P is Δ11 (L)-deﬁnable (or simply Δ11 -deﬁnable) in T if there are Σ11 (L)

V. The Theory V 0 and AC 0

116

formulas ϕ(x, Y ) and

(x, Y ) such that

R(x, Y ) ↔ ϕ(x, Y ),

T  ϕ(x, Y ) ↔ ¬ (x, Y ).

(75)

We say that P is ΔB1 (L)-deﬁnable (or simply ΔB1 -deﬁnable) in T
formulas ϕ and above are ΣB1 formulas.

if the

and

The following exercise can be proved using Parikh’s Theorem.
Exercise V.4.33. Show that if T is a polynomial-bounded theory, then
a predicate is Δ11 -deﬁnable in T iﬀ it is ΔB1 -deﬁnable in T .
Deﬁnition V.4.34 (Characteristic Function). The characteristic function of a relation R(x, X ), denoted by fR (x, X ), is deﬁned as follows:
fR (x, X ) =

1 if R(x, X ),
0 otherwise.

We will show that FAC 0 coincides with the class of provably total functions in V 0 . It follows that AC 0 relations are precisely the Δ11 deﬁnable
relations in V 0 . More generally we have the following theorem.
Theorem V.4.35. If the vocabulary of a theory T includes L2A , and a
complexity class C has the property that for all relations R, R ∈ C iﬀ
fR ∈ FC, and the class of Σ11 -deﬁnable functions in T coincides with FC,
then the class of Δ11 -deﬁnable relations in T coincides with C.
Proof. Assume the hypotheses of the theorem, and suppose that the
relation R(x, X ) is Δ11 -deﬁnable in T . Then there are ΣB0 formulas ϕ and
such that
R(x, X ) ↔ ∃Y ϕ(x, X , Y )
and
T  ∃Y ϕ(x, X , Y ) ↔ ¬∃Y

(x, X , Y ).

(76)

Thus the characteristic function fR (x, X ) of R satisﬁes
y = fR (x, X ) ↔ (y, x, X )

(77)

where
(y, x, X ) ≡ ∃Y ((y = 1 ∧ ϕ(x, X , Y )) ∨ (y = 0 ∧ (x, X , Y ))).
Then T proves ∃!y(y, x, X ), where the existence of y and Y follows
from the ← direction of (76) and the uniqueness of y follows from the
→ direction of (76). Thus fR is Σ11 -deﬁnable in T , so fR is in FC, and
therefore R is in C.
Conversely, suppose that R(x, X ) is in C, so fR is in FC. Then fR is
Σ11 -deﬁnable in T , so there is a Σ11 formula (y, x, X ) such that (77) holds
and
T  ∃!y(y, x, X ).

V.5. The Witnessing Theorem for V 0

117

Then R(x, X ) ↔ ∃y(y = 0 ∧ (y, x, X )) and
T  ∃y(y = 0 ∧ (y, x, X )) ↔ ¬(0, x, X ).
Since ∃y(y = 0 ∧ (y, x, X )) is equivalent to a Σ11 formula, it follows that
2
R is Δ11 -deﬁnable in T .

V.5. The Witnessing Theorem for V 0
Notation. For a theory T and a list L of functions that are
deﬁnable/bit-deﬁnable in T , we denote by T (L) the theory T extended
by the deﬁning/bit-deﬁning axioms for the symbols in L.
Recall that number functions in FAC 0 are ΣB0 -deﬁnable in V 0 , and
string functions in FAC 0 are ΣB0 -bit-deﬁnable in V 0 (see Proposition V.4.7
and Corollary V.4.11). It follows from Corollary V.4.14 that V 0 (L) is a
conservative extension of V 0 , for any collection L of FAC 0 functions.
Our goal now is to prove the following theorem.
Theorem V.5.1 (Witnessing for V 0 ). Suppose that ϕ(x, y, X , Y ) is a ΣB0
formula such that
V 0  ∀x∀X ∃y∃Y ϕ(x, y, X , Y ).
Then there are FAC 0 functions f1 , . . . , fk , F1 , . . . , Fm so that
V 0 (f1 , . . . , fk , F1 , . . . , Fm )  ∀x∀X ϕ(x, f(x, X ), X , F (x, X )).
The functions fi and Fj are called the witnessing functions, for yi and
Yj , respectively.
We will prove the Witnessing Theorem for V 0 in the next section. First,
we list some of its corollaries.
The next corollary follows from the above theorem and Corollary V.4.11.
Corollary V.5.2 (Σ11 -Deﬁnability Theorem for V 0 ). A function is in
FAC 0 iﬀ it is Σ11 -deﬁnable in V 0 iﬀ it is ΣB1 -deﬁnable in V 0 iﬀ it is ΣB0 deﬁnable in V 0 .
Corollary V.5.3. A relation is in AC 0 iﬀ it is Δ11 deﬁnable in V 0 iﬀ it is
ΔB1 deﬁnable in V 0 .
It follows from the ΣB0 -Representation Theorem IV.3.6 that a relation is
in AC 0 iﬀ its characteristic function is in AC 0 . Therefore Corollary V.5.3
follows from the Σ11 -Deﬁnability Theorem for V 0 and Theorem V.4.35.
Alternatively, it can be proved using the Witnessing Theorem for V 0 as
follows.
Proof. Since each AC 0 relation R is represented by a ΣB0 formula , it
is obvious that they are ΔB1 (and hence Δ11 ) deﬁnable in V 0 : In (75) simply
let ϕ be , and be ¬.

V. The Theory V 0 and AC 0

118

On the other hand, suppose that R is a Δ11 -deﬁnable relation of V 0 . In
other words, there are ΣB0 formulas ϕ(x, X , Y ) and (x, X , Y ) so that
R(x, X ) ↔ ∃Y ϕ(x, X , Y )
and
V 0  ∃Y ϕ(x, X , Y ) ↔ ¬∃Y (x, X , Y ).

(78)

In particular,
V 0  ∃Y (ϕ(x, X , Y ) ∨ (x, X , Y )).
By the Witnessing Theorem for V 0 , there are AC 0 functions F1 , . . . , Fk so
that
V 0 (F1 , . . . , Fk )  ∀x∀X (ϕ(x, X , F (x, X )) ∨ (x, X , F (x, X ))). (79)
We claim that V 0 (F1 , . . . , Fk ) proves
∀x∀X (∃Y ϕ(x, X , Y ) ↔ ϕ(x, X , F (x, X ))).
The ⇐ direction is trivial. The other direction follows from (78) and (79).
Consequently ϕ(x, X , F (x, X )) also represents R(x, X ). Here R is
obtained from the relation represented by ϕ(x, X , Y ) by substituting the
AC 0 functions F for Y . By Theorem V.2.7 (a), R is also an AC 0 relation.
2
V.5.1. Independence Follows from the Witnessing Theorem for V 0 . We
can use the Witnessing Theorem to show the unprovability in V 0 of
∃Z ϕ(Z) by showing that no AC 0 function can witness the quantiﬁer
∃Z. Recall that the relation PARITY (X ) is deﬁned by
PARITY (X ) ↔ the set X has an odd number of elements.
Then a well known result in complexity theory states:
Proposition V.5.4. PARITY ∈ AC 0 .
First, it follows that the characteristic function parity(X ) of
PARITY (X ) is not in FAC 0 . Therefore parity is not Σ11 -deﬁnable in V 0 .
In the next chapter we will show that parity is Σ11 -deﬁnable in the theory
V 1 . This will show that V 0 is a proper sub-theory of V 1 .
Now consider the ΣB0 formula ϕparity (X, Y ):
¬Y (0) ∧ ∀i < |X |(Y (i + 1) ↔ (X (i) ⊕ Y (i)))

(80)

where ⊕ is exclusive OR. Thus ϕparity (X, Y ) asserts that for 0 ≤ i < |X |,
bit Y (i + 1) is 1 iﬀ the number of 1’s among bits X (0), . . . , X (i) is odd.
Deﬁne
ϕ(X ) ≡ ∃Y ≤ (|X | + 1) ϕparity (X, Y ).

V.5. The Witnessing Theorem for V 0

119

Then ∀Xϕ(X ) is true in the standard model N2 , but by the above proposition, no function F (X ) satisfying ∀Xϕparity (X, F (X )) can be in FAC 0 .
Hence by the Witnessing Theorem for V 0 ,
V 0  ∀X ∃Y ≤ (|X | + 1) ϕparity (X, Y ).
Note that this independence result does not follow from Parikh’s Theorem.
V.5.2. Proof of the Witnessing Theorem for V 0 . Recall the analogous
statement in single-sorted logic for IΔ0 (i.e., that a Σ1 theorem of IΔ0
can be “witnessed” by a single-sorted LTH function) which is proved in
Theorem III.4.8. There we use the Bounded Deﬁnability Theorem III.3.8
(which follows from Parikh’s Theorem) to show that the graph of any
Σ1 -deﬁnable function of IΔ0 is actually deﬁnable by a Δ0 formula, and
hence an LTH relation.
Unfortunately, a similar method does not work here. We can also use
Parikh’s Theorem to show that the graph of a Σ11 -deﬁnable function of V 0
is representable by a ΣB1 formula. However this does not suﬃce, since there
are string functions whose graphs are in AC 0 (i.e., representable by ΣB0
formulas), but which do not belong to FAC 0 . An example is the counting
function whose graph is given by the ΣB0 formula NUM (x, X, Y ) (227).
Our ﬁrst proof is by the Anchored LK 2 Completeness Theorem IV.4.5.
This proof is important because the same method can be used to prove the
witnessing theorem for V 1 (Theorem VI.4.1). Our second proof method
(see Section V.6.1) is based on the Herbrand Theorem and does not work
for V 1 .
We will prove the following simple form of the theorem, since it implies
the general form.
Lemma V.5.5. Suppose that ϕ(x, X , Y ) is a ΣB0 formula such that
V 0  ∀x∀X ∃Zϕ(x, X , Z).
Then there is an FAC 0 function F so that
V 0 (F )  ∀x∀X ϕ(x, X , F (x, X )).
Proof of Theorem V.5.1 from Lemma V.5.5. The idea is to use the
function Row to encode the tuple y, Y  by a single string variable Z,
as in Lemma V.4.28. Then by the above lemma, Z is witnessed by an AC 0
function F . The witnessing functions for y1 , . . . , yk , Y1 , . . . , Ym will then
be extracted from F using the function Row. Details are as follows.
Assume the hypothesis of the Witnessing Theorem for V 0 , i.e.,
V 0  ∀x∀X ∃y∃Y ϕ(x, y, X , Y )
for a ΣB0 formula ϕ(x, y, X , Y ). Then since V 0 (Row) extends V 0 , we have
also
V 0 (Row)  ∀x∀X ∃y∃Y ϕ(x, y, X , Y ).

V. The Theory V 0 and AC 0

120
Note that

V 0 (Row)  ∀y1 . . . ∀yk ∀Y1 . . . ∀Ym ∃Z

 k

m

|Z [i] | = yi ∧

i=1


Z [k+j] = Yj .

j=1

(See also Lemma V.4.28.) Thus
V 0 (Row)  ∀x∀X ∃Z ϕ(x, |Z [1] |, . . . , |Z [k] |, X , Z [k+1] , . . . , Z [k+m] )
i.e.,
V 0 (Row)  ∀x∀X ∃Z (x, X , Z)
where
(x, X , Z) ≡ ϕ(x, |Z [1] |, . . . , |Z [k] |, X , Z [k+1] , . . . , Z [k+m] )
is a ΣB0 (L2A ∪ {Row}) formula.
Now by Lemma V.4.27, there is a ΣB0 (L2A ) formula


V 0 (Row)  ∀x∀X ∀Z( (x, X , Z) ↔
0



(x, X , Z) so that

(x, X , Z)).

0

As a result, since V (Row) is conservative over V , we also have
V 0  ∀x∀X ∃Z



(x, X , Z).

0

Applying Lemma V.5.5, there is an AC function F so that
V 0 (F )  ∀x∀X



(x, X , F (x, X )).

Therefore
V 0 (Row, F )  ∀x∀X (x, X , F (x, X ))
i.e.,
V 0 (Row, F )  ∀x∀X ϕ(x, |F [1] |, . . . , |F [k] |, X , F [k+1] , . . . , F [k+m] )
where we write F for F (x, X ).
Let fi (x, X ) = |(F (x, X ))[i] | for 1 ≤ i ≤ k and Fj (x, X ) = (F (x,
X ))[k+j] for 1 ≤ j ≤ m and denote {f1 , . . . , fk , F1 , . . . , Fm } by L, we
have
V 0 ({Row, F } ∪ L)  ∀x∀X ϕ(x, f, X , F ).
By Corollary V.4.14, V 0 ({Row, F } ∪ L) is a conservative extension of
0
V (L). Consequently,
V 0 (L)  ∀x∀X ϕ(x, f, X , F ).

2

The rest of this section is devoted to the proof of Lemma V.5.5.
Proof of Lemma V.5.5. The proof method is similar to that of Lemma
V.3.5 (for Parikh’s Theorem). Suppose that ∃Zϕ(a, α, Z) is a theorem of
V 0 . By the Anchored LK 2 Completeness Theorem, there is an anchored
LK 2 -T proof  of
−→ ∃Zϕ(a, α, Z)
where T is the set of all term substitution instances of the axioms for V 0 .
We assume that  is in free variable normal form (see Section IV.4.1).

V.5. The Witnessing Theorem for V 0

121

Note that all instances of the ΣB0 -COMP axioms (48) are Σ11 formulas
(they are in fact ΣB1 formulas). Since the endsequent of  is also a Σ11
formula, by the Subformula Property (Theorem IV.4.6), all formulas in 
are Σ11 formulas, and in fact they contain at most one string quantiﬁer ∃X
in front. In particular, every sequent in  has the form
∃X1 1 (X1 ), . . . , ∃Xm m (Xm ), Γ −→ Δ, ∃Y1

1 (Y1 ), . . . , ∃Yn

n (Yn )

(81)
for m, n ≥ 0, where i and j and all formulas in Γ and Δ are ΣB0 .
We will prove by induction on the depth in  of a sequent S of the form
(81) that there are ΣB0 -bit-deﬁnable string functions F1 , . . . , Fn (i.e., the
witnessing functions) such that there is a collection of ΣB0 -bit-deﬁnable
functions L including F1 , . . . , Fn and an LK 2 -V 0 (L) proof of
S  =def 1 ( 1 ), . . . , m ( m ), Γ −→ Δ,

1 (F1 ), . . . ,

n (Fn )

(82)

where Fi stands for Fi (a, α, ), and a, α is a list of exactly those variables with free occurrences in S. (This list may be diﬀerent for diﬀerent
sequents.) Here 1 , . . . , m are distinct new free variables corresponding
to the bound variables X1 , . . . , Xm , although the latter variables may not
be distinct.
It follows that for the endsequent −→ ∃Zϕ(a, α, Z) of , there is a
ﬁnite collection L of FAC 0 functions, and an F ∈ L so that
V 0 (L)  ϕ(a, α, F (a, α)).
Note that by Corollary V.4.14, V 0 (L) is a conservative extension of V 0 (F ).
Consequently we have
V 0 (F )  ϕ(a, α, F (a, α))
and we are done.
Our inductive proof has several cases, depending on whether S is a V 0
axiom, or which rule is used to generate S. In each case we will introduce
suitable witnessing functions when required, and it is an easy exercise to
check that in each of the functions introduced has a ΣB0 (L2A )-bit-deﬁnition.
To show that the arguments a, α of previously-introduced witnessing
functions continue to include only those variables with free occurrences
in the sequent S, we use the fact that the proof  is in free variable normal
form, and hence no free variable is eliminated by any rule in the proof
except ∀-right and ∃-left. (We made a similar argument concerning the
free variables in the bounding terms t in the proof of Lemma V.3.5).
In general we will show that S  has an LK 2 -V 0 (L) proof not by constructing the proof, but rather by arguing that the formula giving the
semantics of S  (Deﬁnition II.2.16) is provable in V 0 from the bit-deﬁning
axioms of the functions L, and invoking the LK 2 Completeness Theorem.
However in each case the LK 2 -V 0 (L) proof is not hard to ﬁnd.

V. The Theory V 0 and AC 0

122

Speciﬁcally, if we write (82) in the form
S  = A1 , . . . , Ak −→ B1 , . . . , B
then we assert



V 0 (L)  ∀x∀X ∀Y (A1 ∧ · · · ∧ Ak ) ⊃ (B1 ∨ · · · ∨ B ) .

(83)

Case I. S is an axiom of V 0 . If the axiom only involves ΣB0 formulas,
then no witnessing functions are needed. Otherwise S comes from a
ΣB0 -COMP axiom, i.e.,
S =def −→ ∃X ≤ b∀z < b(X (z) ↔

(z, b, a, α)).

Then a function witnessing X has bit-deﬁning axiom
F (b, a, α)(z) ↔ z < b ∧ (z, b, a, α).
Case II. S is obtained by an application of the rule string ∃-right. Then
S is the bottom of the inference
S1
S

=

Λ −→ Π, (T )
Λ −→ Π, ∃X (X )

where the string term T is either a variable  or the constant ∅ introduced
when putting  in free variable normal form. In the former case,  must
have a free occurrence in S, and we may witness the new quantiﬁer ∃X by
the function F with bit-deﬁning axiom
F (a, , α, )(z) ↔ z < || ∧ (z)
In the latter case T is ∅, and we deﬁne
F (a, α, )(z) ↔ z < 0.
Case III. S is obtained by an application of the rule string ∃-left. Then
S is the bottom of the inference
S1
S

=

(), Λ −→ Π
∃X(X ), Λ −→ Π

Note that  cannot occur in S, by the restriction for this rule, but S 
has a new variable  available corresponding to ∃X (see (82)). No new
witnessing function is required. Each witnessing function Fj (a, , α, )
for the top sequent is replaced by the witnessing function
Fj (a, α,



, ) = Fj (a,



, α, )

for S  .
Case IV. S is obtained by an application of the rule number ∃-right or
number ∀-left. No new witnessing functions are required.

V.5. The Witnessing Theorem for V 0

123

Case V. S follows from an application of rule number ∃-left or number
∀-right. We consider number ∃-left, since number ∀-right is similar. Then
S is the bottom sequent in the inference
S1
S

=

b ≤ t ∧ (b), Λ −→ Π
∃x ≤ t(x), Λ −→ Π

No new witnessing function is needed, but the free variable b is eliminated
as an argument to the existing witnessing functions, and it must be given
a value. We give it a value which satisﬁes the new existential quantiﬁer, if
one exists. Thus deﬁne the FAC 0 number function
g(a, α) = min b ≤ t (b).
For each witnessing function Fj (b, a, α, ) for the top sequent deﬁne the
corresponding witnessing function for the bottom sequent by
Fj (a, α, ) = Fj (g(a, α), a, α, ).
Case VI. S is obtained by the cut rule. Then S is the bottom of the
inference
S2 Λ −→ Π,
S1
, Λ −→ Π
=
S
Λ −→ Π
B
Assume ﬁrst that is Σ0 . For i = 1, 2, let F1i (a, α), . . . , Fni (a, α) be the
witnessing functions for Π in Si . Then we deﬁne witnessing functions
F1 , . . . , Fn for these formulas in the conclusion S  by the bit-deﬁning
axioms
Fj (a, α)(z) ↔ ((¬ ∧ Fj1 (a, α)(z)) ∨ ( ∧ Fj2 (a, α)(z))).
Now assume that

is not ΣB0 , so

has the form

≡ ∃X(X )

(84)

where (X ) is ΣB0 . Let G(a, α) be the witnessing function for ∃X in S1 and
let be the variable in S2 corresponding to X . Let F11 (a, α), . . . , Fn1 (a, α)
be the other witnessing functions for Π in S1 , and F12 (a, α, ), . . . , Fn2 (a, α,
) be the witnessing functions for Π in S2 . The corresponding witnessing
function Fj in S  has deﬁning axiom (replace . . . by a, α)
Fj (. . . )(z) ↔
(¬(G(. . . )) ∧ Fj1 (. . . )(z)) ∨ ((G(. . . )) ∧ Fj2 (. . . , G(. . . ))(z)).

(85)

Exercise V.5.6. Show correctness of this deﬁnition of F in the special
case where the cut formula has the form (84), and Π has only one Σ11
formula, by arguing that V 0 (L) can prove the semantic translation (83)
of S  from the semantic translations of S1 and S2 .

V. The Theory V 0 and AC 0

124

Case VII. S is obtained from an instance of the rule ∧-left or ∨-right.
These are both handled in the same manner. Consider ∧-right.
S1

S2
S

=

Λ −→ Π, A

Λ −→ Π, B

Λ → Π, (A ∧ B)

Here, as in (81),
Λ =def ∃X1 1 (X1 ), . . . , ∃Xm m (Xm ), Γ
and

Π =def Δ, ∃Y1

1 (Y1 ), . . . , ∃Yn

n (Yn )

for m, n ≥ 0, where i and j and all formulas in Γ and Δ are ΣB0 . Also,
A and B are ΣB0 formulas.
Let Fj1 (a, α) and Fj2 (a, α) witness Yj in S1 and S2 , respectively. Then
we deﬁne the witness Fj (a, α) for Yj in S  to be Fj1 (a, α) or Fj2 (a, α),
depending on whether Fj1 (a, α) works as a witness. In particular (replace
. . . by a, α):


Fj (. . . )(z) ↔ ( j (Fj (. . . ))∧Fj1 (. . . )(z))∨(¬ j (Fj (. . . ))∧Fj2 (. . . )(z)) .
Case VIII. S is obtained by any of the other rules. Weakening is easy.
There is nothing to do for exchange and ¬ introduction. The contraction
rules can be derived from cut and exchanges.
2
Exercise V.5.7. Show that in the Cases V, VI, and VII above, the new
functions introduced have ΣB0 (L2A )-bit-deﬁnitions.
0

V.6. V : Universal Conservative Extension of V 0
Recall that a universal formula is a formula in prenex form in which all
quantiﬁers are universal, and a universal theory is a theory which can be
axiomatized by universal formulas. Recall also the universal single-sorted
theory IΔ0 introduced in Section III.3.2.
0
The universal theory V extends IΔ0 , and is deﬁned in the same way as
0
IΔ0 . Here we show that V is a conservative extension of V 0 , and that
this gives us an alternative proof of the Witnessing Theorem for V 0 by
0
applying the Herbrand Theorem IV.4.8 for V .
The idea is to introduce number functions with universal deﬁning axioms, and string functions with universal bit-deﬁning axioms, which are
provably total in V 0 . Thus we obtain a conservative extension of V 0 .
Furthermore, the new functions are deﬁned in such a way that the axioms
of V 0 with existential quantiﬁers (namely ΣB0 -COMP and B12, SE) can
be proved from other axioms, and hence can be deduced from our set of
0
universal axioms for V .

0

V.6. V : Universal Conservative Extension of V 0

125

We use the following notation. For any formula ϕ(z, x, X ) and L2A -term
t(x, X ), let Fϕ(z),t (x, X ) be the string function with bit deﬁnition


Fϕ(z),t (x, X )(z) ↔ z < t(x, X ) ∧ ϕ(z, x, X ) .

(86)

Also, let fϕ(z),t (x, X ) be the number function deﬁned as in (28) to be the
least y < t such that ϕ(y, x, X ) holds, or t if no such y exists. Then
fϕ(z),t has deﬁning axiom (we write f for fϕ(z),t (x, X ) and also omit the
arguments x, X from ϕ and t)
f ≤ t ∧ (f < t ⊃ ϕ(f)) ∧ (v < f ⊃ ¬ϕ(v)).

(87)

As in Section III.3.2 we can use the functions fϕ(z),t to eliminate bounded
number quantiﬁers from a formula, since the above deﬁning axiom implies
∃z ≤ tϕ(z) ↔ ϕ(fϕ(z),t (x, X )).
Recall that the predecessor function pd has the deﬁning axioms:
B12 . pd(0) = 0,

B12 . x = 0 ⊃ pd(x) + 1 = x.

(88)

(B12 and B12 are called respectively D1 and D2 in Section III.3.2.)
In two-sorted logic, the extensionality axiom SE contains an implicit
existential quantiﬁer ∃i < |X |. Therefore we introduce the function fSE
with the deﬁning axiom (87), where ϕ(z, X, Y ) ≡ X (z) ↔ Y (z), and
t(X, Y ) = |X |. Intuitively, fSE (X, Y ) is the smallest number < |X | that
distinguishes X and Y , and |X | if no such number exists.
fSE (X, Y ) ≤ |X | ∧ fSE (X, Y ) < |X | ⊃ ¬(X (fSE (X, Y )) ↔
Y (fSE (X, Y ))) ∧ z < fSE (X, Y ) ⊃ (X (z) ↔ Y (z)).

(89)

Let SE  be the following axiom
(|X | = |Y | ∧ fSE (X, Y ) = |X |) ⊃ X = Y.

(90)

The vocabulary LFAC 0 is deﬁned below. It contains a function symbol
for every AC 0 function. Note that it extends LΔ0 (Deﬁnition III.3.16).
Deﬁnition V.6.1. LFAC 0 is the smallest set that satisﬁes
1) LFAC 0 includes L2A ∪ {pd, fSE }.
2) For each open formula ϕ(z, x, X ) over LFAC 0 and term t = t(x, X )
of L2A there is a string function Fϕ(z),t and a number function fϕ(z),t
in LFAC 0 .
0

Deﬁnition V.6.2. V is the theory over LFAC 0 with the following set
of axioms: B1–B11, L1, L2 (Figure 2), B12 and B12 (88), (89), SE
(90), and (86) for each function Fϕ(z),t and (87) for each function fϕ(z),t
of LFAC 0 .

V. The Theory V 0 and AC 0

126
0

0

Thus V extends IΔ0 . Also, the axioms for V do not include any com0
prehension axiom. However, we will show that V proves the ΣB0 -COMP
0

axiom scheme, and hence V extends V 0 .
Recall that an open formula is a formula without quantiﬁer. The following lemma can be proved by structural induction on ϕ in the same way
as Lemma III.3.19.
Lemma V.6.3. For every ΣB0 (LFAC 0 ) formula ϕ there is an open LFAC 0 0
formula ϕ + such that V  ϕ ↔ ϕ + .
0

Lemma V.6.4. V proves the ΣB0 (LFAC 0 )-COMP, ΣB0 (LFAC 0 )-IND, and
B
Σ0 (LFAC 0 )-MIN axiom schemes.
Proof. For comprehension, we need to show, for each ΣB0 (LFAC 0 ) formula ϕ(z, x, X ),
0

V  ∃Z ≤ y∀z < y(Z(z) ↔ ϕ(z, x, X )).
By Lemma V.6.3 we may assume that ϕ is open. Thus we can take
Z = Fϕ,y (x, X ) and apply (86). For induction and minimization we use
Corollary V.1.8.
2
0

Theorem V.6.5. The theory V is a conservative extension of V 0 .
0

0

Proof. To show that V extends V 0 , we need to verify that V proves
B12, SE and ΣB0 -COMP. First, B12 follows from B12 . We prove SE in
0

V as follows. Assume that
|X | = |Y | ∧ ∀z < |X |(X (z) ↔ Y (z)).
Then from (89) we have fSE (X, Y ) = |X |. Hence by (90) we obtain
X = Y.
0
That V proves ΣB0 -COMP follows from Lemma V.6.4.
0

Now we show that V is conservative over V 0 . Let
pd, fSE , . . .

(91)

be an enumeration of LFAC 0 such that the n-th function is deﬁned or bitdeﬁned by an open formula using only the ﬁrst (n − 1) functions. Let
Ln denote the union of L2A and the set of the ﬁrst n functions in the
enumeration, and V 0 (Ln ) denote V 0 together with the deﬁning axioms or
bit-deﬁning axioms for the functions of Ln (n ≥ 0). Then

0
V =
V 0 (Ln ).
n≥0

First we prove:
Claim. For n ≥ 1, V 0 (Ln ) satisﬁes the hypothesis of Lemma V.4.15.

0

V.6. V : Universal Conservative Extension of V 0

127

From Lemma V.4.15 and the claim we have
V 0 (Ln )  ΣB0 (Ln )-COMP.
Therefore by Corollary V.4.14 V 0(Ln+1 ) is conservative over V 0 (Ln ). Then
0
by Compactness Theorem, it follows that V is also conservative over V 0 .
(See also Corollary III.3.6.)
It remains to prove the claim.
First note that V 0 (Ln ) extends V 0 for all n ≥ 1. Also LFAC 0 has the
same predicates as L2A . We will prove by induction on n that each string
function in Ln has a ΣB0 (L2A )-bit-deﬁning axiom in V 0 (Ln ), and each
number function in Ln has a ΣB0 (L2A )-deﬁning axiom in V 0 (Ln ), and thus
establishing the claim.
For the base case, n = 1, by B12 and B12 pd has a ΣB0 (L2A )-deﬁning
axiom in V 0 , therefore V 0 (L1 ) (which is V 0 (pd)) satisﬁes the hypothesis
of Lemma V.4.15.
For the induction step we need to show that the (n + 1)-st function fn+1
or Fn+1 in (91) has a ΣB0 (L2A )-deﬁning axiom or a ΣB0 (L2A )-bit-deﬁning
axiom in V 0 (Ln+1 ). By deﬁnition, the function fn+1 /Fn+1 already has
an open deﬁning/bit-deﬁning axiom in the vocabulary Ln . From the
induction hypothesis, V 0 (Ln ) satisﬁes the hypothesis of Lemma V.4.15.
Consequently the deﬁning/bit-deﬁning axiom for fn+1 /Fn+1 is provably
equivalent in V 0 (Ln ) to a ΣB0 (L2A ) formula. Hence V 0 (Ln+1 ) proves that
fn+1 /Fn+1 has a ΣB0 (L2A ) deﬁning/bit-deﬁning axiom, and this completes
the proof of the claim.
2
Inspection of the above proof shows that each number function of
LFAC 0 has a ΣB0 (L2A )-deﬁning axiom, and each string function of LFAC 0
has a ΣB0 (L2A )-bit-deﬁning axiom.
Corollary V.6.6. The LFAC 0 functions are precisely the functions of
FAC 0 .
Proof. By the above remark and the ΣB0 -Representation Theorem
IV.3.6, the LFAC 0 functions are in FAC 0 . The other inclusion follows
from the ΣB0 -Representation Theorem IV.3.6 and Lemma V.6.3.
2
The next lemma follows from Lemma V.4.15 and the claim in the above
proof of Theorem V.6.5. It generalizes the Row Elimination Lemma V.4.27.
Lemma V.6.7 (FAC 0 Elimination). Suppose that L ⊆ LFAC 0 . Then for
every i ≥ 0 and every ΣBi (L) formula ϕ + there is a ΣBi (L2A ) formula ϕ so
that V 0 (L)  ϕ + ↔ ϕ.
V.6.1. Alternative Proof of the Witnessing Theorem for V 0 . Here we
0
show how to apply the Herbrand Theorem to V to obtain a simple proof
of Theorem V.5.1. For notational simplicity, we consider the case of a
single existential string quantiﬁer, and prove Lemma V.5.5.

V. The Theory V 0 and AC 0

128

Suppose that ϕ(x, X , Z) is a ΣB0 formula such that
V 0  ∀x∀X ∃Zϕ(x, X , Z).
0

By Lemma V.6.3 there is an open formula ϕ  over LFAC 0 such that V 
0
ϕ ↔ ϕ  . Since V extends V 0 , we have
0

V  ∀x∀X ∃Zϕ  (x, X , Z).
0

Now V is a universal theory, so by the Herbrand Theorem IV.4.8, there
0
are terms T1 (x, X ), . . . , Tn (x, X ) of V such that


0
V  ∀x∀X ϕ  (x, X , T1 (x, X )) ∨ · · · ∨ ϕ  (x, X , Tn (x, X )) .
Deﬁne F (x, X ) by cases as follows:
⎧
T1 (x, X )
if ϕ  (x, X , T1 (x, X )),
⎪
⎪
⎪
⎨
..
.
F (x, X ) =
⎪
⎪
(x, X ) if ϕ  (x, X , Tn−1 (x, X )),
T
⎪
⎩ n−1
Tn (x, X )
otherwise.
It is easy to see that F (x, X ) has a bit deﬁnition (86), and hence is a
function in LFAC 0 , and
0

V  ∀x∀X ϕ  (x, X , F (x, X )).
0

0

Now V  ϕ ↔ ϕ  , and also the proof of Theorem V.6.5 shows that V
is conservative over V 0 (F ) (the extension of V 0 resulting by adding the
deﬁning axioms for F ). Hence
V 0 (F )  ∀x∀X ϕ(x, X , F (x, X ))
as required.
2
The above proof shows that adding true ΣB0 axioms to a theory does not
increase the set of provably total functions in the theory. For example,
let TrueΣB0 be the set of all ΣB0 formulas which are true in the standard
model N2 . Let V 0 (TrueΣB0 ) be the result of adding TrueΣB0 as axioms
0

to V 0 , and let V (TrueΣB0 ) be the result of adding TrueΣB0 as axioms to
0
0
V . Then V (TrueΣB0 ) is a conservative extension of V 0 (TrueΣB0 ), and the
above proof goes through to show that the same class FAC 0 of functions
serve to witness the Σ11 theorems of V 0 (TrueΣB0 ). Thus we have shown
Corollary V.6.8. The provably total functions in V 0 (TrueΣB0 ) are precisely the functions in FAC 0 .

V.7. Finite Axiomatizability

129

V.7. Finite Axiomatizability
Theorem V.7.1. V 0 is ﬁnitely axiomatizable.
Proof. It suﬃces to show that all ΣB0 -COMP axioms follow from
ﬁnitely many theorems of V 0 . Let 2-BASIC + (or simply B + ) denote
the 2-BASIC axioms (Fig. 2) along with the ﬁnitely many theorems of
IΔ0 (and hence of V 0 ) given in Examples III.1.8 and III.1.9 asserting that
+, ·, ≤ satisfy the properties of a commutative discretely-ordered semiring.
We show more generally that both ΣB0 -COMP and the multiple comprehension axioms (72) for all ΣB0 formulas follow from B + and ﬁnitely
many such comprehension instances. We use the notation ϕ[a, Q](x) to
indicate that the ΣB0 formula ϕ can contain the free variables a, Q in addition to x = x1 , . . . , xk . Then for k ≥ 1, COMPϕ (a, Q, b) denotes the
comprehension formula
∃Y ≤ b1 , . . . , bk ∀x1 < b1 . . . ∀xk < bk (Y (x) ↔ ϕ(x)).

(92)

We will show that COMPϕ for the following 12 formulas ϕ will suﬃce.
ϕ1 (x1 , x2 )
≡ x 1 = x2 ,
ϕ2 (x1 , x2 , x3 )
≡ x3 = x1 ,
ϕ3 (x1 , x2 , x3 )
≡ x3 = x2 ,
ϕ4 [Q1 , Q2 ](x1 , x2 ) ≡ ∃y ≤ x1 (Q1 (x1 , y) ∧ Q2 (y, x2 )),
ϕ5 [a](x, y)
≡ y = a,
ϕ6 [Q1 , Q2 ](x, y) ≡ ∃z1 ≤ y∃z2 ≤ y(Q1 (x, z1 ) ∧ Q2 (x, z2 ) ∧ y = z1 + z2 ),
ϕ7 [Q1 , Q2 ](x, y) ≡ ∃z1 ≤ y∃z2 ≤ y(Q1 (x, z1 ) ∧ Q2 (x, z2 ) ∧ y = z1 · z2 ),
ϕ8 [Q1 , Q2 , c](x) ≡ ∃y1 ≤ c∃y2 ≤ c(Q1 (x, y1 ) ∧ Q2 (x, y2 ) ∧ y1 ≤ y2 ),
ϕ9 [X, Q, c](x)
≡ ∃y ≤ c(Q(x, y) ∧ X (y)),
ϕ10 [Q](x)
≡ ¬Q(x),
ϕ11 [Q1 , Q2 ](x)
≡ Q1 (x) ∧ Q2 (x),
ϕ12 [Q, c](x)
≡ ∀y ≤ cQ(x, y).
In the following lemmas, we abbreviate COMPϕi (. . . ) by Ci .
Lemma V.7.2. For each k ≥ 1 and 1 ≤ i ≤ k let
ik (x1 , . . . , xk , y) ≡ y = xi .

Then B , C1 , C2 , C3 , C4  COMP ik .
+

Proof. We proceed by induction on k. For k = 1 we have 1,1 ↔
ϕ1 (x1 , y) and for k = 2 we have 2,1 ↔ ϕ2 (x1 , x2 , y) and 2,2 ↔
ϕ3 (x1 , x2 , y). For k > 2, recall x1 , . . . , xk  = x1 , . . . , xk−1 , xk . Hence
B + , C3  COMP kk .
For 1 ≤ i < k use C4 with Q1 deﬁned by C2 and Q2 deﬁned by COMP i,k−1 .
2

V. The Theory V 0 and AC 0

130

Lemma V.7.3. Let x = x1 , · · · , xk , k ≥ 1, be a list of variables and let
t(x) be a term which in addition to possibly involving variables from x may
involve other variables a, Q. Let t [a, Q](x, y) ≡ y = t(x). Then
B + , C1 , . . . , C7  COMP t (a, Q, b, d ).
Proof. By using algebraic theorems in B + we may suppose that t(x) is a
sum of monomials in x1 , . . . , xk , where the coeﬃcients are terms involving
a, Q. The case t ≡ u, where u does not involve any xi is obtained from
C5 with a ← u. The cases t ≡ xi are obtained from Lemma V.7.2. We
then build monomials using C7 repeatedly, and build the general case by
repeated use of C6 .
2
Lemma V.7.4. Let t1 (x), t2 (x) be terms with variables among x, a, Q.
Suppose
≡ t1 (x) ≤ t2 (x),
1 [a, Q](x)
2 [a, Q, X ](x) ≡ X (t1 (x)).
Then B + , C1 , . . . , C9  COMP i , for i = 1, 2.
Proof. COMP 1 (a, Q, b) follows from COMPϕ8 (Q1 , Q2 , c, b) with for
i = 1, 2, Qi deﬁned from COMP ti in Lemma V.7.3 with d ← t1 (b) +
t2 (b) + 1, so
∀x < b∀y < (t1 (b) + t2 (b) + 1) (Qi (x, y) ↔ y = ti (x)).
In COMPϕ8 we take c ← t1 (b) + t2 (b) and b ← b1 , . . . , bk .
For COMP 2 (a, Q, X, b) we use COMPϕ9 (X, P, c, b) with c ← t1 (b)
and b ← b1 , . . . , bk  and P deﬁned from Lemma V.7.3 similarly to Q1
above.
2
Now we can complete the proof of the theorem. Lemma V.7.4 takes care
of the case when ϕ is an atomic formula, since equations t1 (x) = t2 (x) can
be initially replaced by t1 (x) ≤ t2 (x) ∧ t2 (x) ≤ t1 (x). Then by repeated
applications of COMPϕ10 and COMPϕ11 we handle the case in which ϕ is
quantiﬁer-free.
Now suppose ϕ(x) ≡ ∀y ≤ t(x) (x, y). We assume as an induction
hypothesis that we can deﬁne Q satisfying


∀x < b∀y < t(b) + 1 Q(x, y) ↔ (y ≤ t(x) ⊃ (x, y)) .
Then COMPϕ (b) follows from COMPϕ12 (Q, c, b) with c ← t(b) and
b ← b1 , . . . , bk .
2

V.8. Notes
p

The system V 0 we introduce in this chapter is essentially Σ0 -comp in
0
[112], and IΣ1,b
0 (without #) in [72]. Zambella [112] used R for FAC and

V.8. Notes

131

called it the class of rudimentary functions. However there is danger here
of confusion with Smullyan’s rudimentary relations [103].
The set 2-BASIC is similar to the axioms for Zambella’s theory Θ in
[112], and forms the two-sorted analog of Buss’s single-sorted axioms
BASIC [20]. It is slightly diﬀerent from that which are presented in [43]
and [42].
The statement and proof of Theorem V.5.1 (witnessing) are inspired by
[20], although our treatment here is simpliﬁed because we only witness
formulas in which all string quantiﬁers are in front.
0
The universal theory V is taken from [42].
Theorem V.7.1 (ﬁnite axiomatizability) is taken from Section 7 of [43].

Chapter VI

THE THEORY V 1 AND POLYNOMIAL TIME

In this chapter we show that the theory V 1 (the two-sorted version of
Buss’s theory S21 ) characterizes P in the same way that V 0 characterizes
AC 0 . This is stated in the Σ11 -Deﬁnability Theorem VI.2.2 for V 1 : A
function is Σ11 -deﬁnable (equivalently ΣB1 -deﬁnable) in V 1 if and only if it
is in FP. The “only if ” direction follows from the Witnessing Theorem
for V 1 .
The theory of algorithms can be viewed, to a large extent, as the study
of polynomial time functions. All polytime algorithms can be described
in V 1 , and experience has shown that proofs of their important properties
can usually be formalized in V 1 . (See Example VI.4.3, prime recognition,
for an apparent exception.) Razborov [96] has shown how to formalize
lower bound proofs for Boolean complexity in V 1 . Standard theorems
from graph theory, including Kuratowski’s Theorem, Hall’s Theorem, and
Menger’s Theorem can be formalized in V 1 .
In Chapter VIII we will introduce the (apparently) weaker theories
TV 0 and VPV for polynomial time, and prove that they have the same
ΣB1 -theorems (and hence the same Σ11 -theorems) as V 1 .

VI.1. Induction Schemes in V i
Recall (Deﬁnition V.1.3) that V i is axiomatized by 2-BASIC and ΣBi COMP, where ΣBi -COMP consists of all formulas of the form
∃X ≤ y∀z < y(X (z) ↔ ϕ(z))

(93)

where ϕ(z) is a ΣBi formula, and X does not occur free in ϕ(z).
The next result follows from Corollary V.1.8.
Corollary VI.1.1. For i ≥ 0, V i proves the ΣBi -IND, ΣBi -MIN, and
B
Σi -MAX axiom schemes.
It turns out that V i proves these schemes for a wider class of formulas
than just ΣBi . To show this, we start with a partial generalization of the
Multiple Comprehension Lemma V.4.25. Recall the projection functions
left and right (Example V.4.22).
133

134

VI. The Theory V 1 and Polynomial Time

Lemma VI.1.2 (Multiple Comprehension Revisited). Let T be a theory
which extends V 0 and has vocabulary L, and suppose that either L = L2A or
L includes the projection functions left and right. For each i ≥ 0, if T proves
the ΣBi (L)-COMP axioms, then T proves the multiple comprehension axiom
(72):
∃X ≤ y1 , . . . , yk ∀z1 < y1 . . . ∀zk < yk (X (z1 , . . . , zk ) ↔ ϕ(z1 , . . . , zk ))
(94)
for any k ≥ 2 and any ϕ ∈ ΣBi (L). In particular, for all i ≥ 0, V i proves
ΣBi -MULTICOMP.
Proof. The method used to prove the earlier version, Lemma V.4.25,
does not work here, because for i ≥ 1 the ΣBi (L)-formulas are not closed
under bounded number quantiﬁcation.
For notational simplicity we prove the case k = 2. First we consider
the case that L includes left and right. Assuming that ϕ(z1 , z2 ) is in ΣBi (L)
and T proves the ΣBi (L)-COMP axioms, it follows that T proves
∃X ≤ y1 , y2 ∀z < y1 , y2 (X (z) ↔ ϕ(left(z), right(z))).
Now (94) follows by the properties of left,right (Exercise V.4.23) and the
notation (71) stating that X (z1 , z2 ) ≡ X (z1 , z2 ).
For the case L = L2A , we work in the conservative extension T (left, right)
of T . By the FAC 0 Elimination Lemma V.6.7, if T proves the ΣBi -COMP
axioms, it follows that T (left, right) proves the ΣBi (left, right)-COMP axioms and hence also (94) by the previous case. Hence also T proves (94)
by conservativity.
2
B
The next result refers to the Σ0 -closure of a set of formulas (Deﬁnition V.4.9).
Theorem VI.1.3. Let T be a theory over a vocabulary L which extends
V 0 and proves the multiple comprehension axioms (94) for every k ≥ 1 and
every ϕ in some class Φ of L-formulas. Then T proves the ΣB0 (Φ)-COMP
axioms.
The following result is an immediate consequence of this theorem,
Lemma VI.1.2, and Corollary V.1.8, since every ΠBi formula is equivalent to a negated ΣBi formula.
Corollary VI.1.4. For i ≥ 0 let Φi be ΣB0 (ΣBi ∪ ΠBi ). Then V i proves
the Φi -COMP, Φi -IND, Φi -MIN, and Φi -MAX axiom schemes.
Proof of Theorem VI.1.3. We prove the stronger assertion that T
proves the multiple comprehension axioms (94) for ϕ ∈ ΣB0 (Φ), by structural induction on ϕ relative to Φ. We use the fact that T extends V 0 and
hence by Lemma VI.1.2 proves the multiple comprehension axioms for
ΣB0 -formulas.
The base case, ϕ ∈ Φ, holds by hypothesis. For the induction step,
consider the case that ϕ has the form ¬ . By the induction hypothesis T

VI.2. Characterizing P by V 1

135

proves
∃Y ≤ y∀z < y(Y (z) ↔
and by Lemma VI.1.2, T proves

(z))

∃X ≤ y∀z < y(X (z) ↔ ¬Y (z)).
Thus T proves (94).
The cases ∧ and ∨ are similar. Finally we consider the case that ϕ(z)
has the form ∀x ≤ t (x, z). By the induction hypothesis T proves
∃Y ≤ t + 1, y∀x ≤ t∀z < y(Y (x, z) ↔

(x, z)).

0

By Lemma V.4.25 V proves
∃X ≤ y∀z < y(X (z) ↔ ∀x ≤ tY (x, z)).
Now (94) follows from these two formulas.

2

VI.2. Characterizing P by V 1
The class (two-sorted) P consists of relations computable in polynomial
time by a deterministic Turing machine (i.e., polytime relations), and FP
is the class of functions computable in polynomial time by a deterministic
Turing machine (i.e., polytime functions). Alternatively (Deﬁnition V.2.3)
FP is the class of the polynomially bounded number functions whose
graphs are in P, and the polynomially bounded string functions whose bit
graphs are in P. (See also Appendix A.1.)
Recall that a number input to the accepting machine is represented as
a unary string, and a set input is represented as a binary string (page 81).
(Thus a purely numerical function f(x) is in FP iﬀ it is computed in time
2O(n) , where n is the length of the binary notation for its arguments.)
The following proposition follows easily from the deﬁnitions involved.
Proposition VI.2.1. (a) A number function f(x, X ) is in FP iﬀ there
is a string function F (x, X ) in FP so that f(x, X ) = |F (x, X )|.
(b) A relation is in P iﬀ its characteristic function is in FP.
We will prove that the theory V 1 characterizes P in the same way that
0
V characterizes AC 0 :
Theorem VI.2.2 (Σ11 -Deﬁnability for V 1 ). A function is Σ11 -deﬁnable in
1
V iﬀ it is in FP.
The “if ” direction is proved in Section VI.2.1. The “only-if ” direction follows immediately from the Witnessing Theorem for V 1 (Theorem VI.4.1).
Note that V 1 is a polynomial-bounded theory (Deﬁnition V.3.3). The
following corollary follows from the Σ11 -Deﬁnability Theorem for V 1
above, and Parikh’s Theorem (see Corollary V.4.4).
Corollary VI.2.3. A function is in FP iﬀ it is ΣB1 -deﬁnable in V 1 .

136

VI. The Theory V 1 and Polynomial Time

The next corollary follows from the results above and Theorem V.4.35.
Corollary VI.2.4. A relation is in P iﬀ it is is Δ11 -deﬁnable in V 1 iﬀ it is

ΔB1 -deﬁnable in V 1 .

Recall (Theorem IV.3.7) that the ΣB1 formulas represent precisely the
NP relations, and hence by Deﬁnition V.4.32 a relation is ΔB1 deﬁnable in
a theory T iﬀ T proves that the relation is in both NP and co-NP. Thus
the above corollary says that a relation is in P iﬀ V 1 proves that it is in
NP ∩ co-NP.
Corollary VI.2.5. V 1 is a proper extension of V 0 .
Proof. There are relations (such as PARITY (X ), page 118) which are
in P but not in AC 0 .
2
Exercise VI.2.6 (parity(X ) in V 1 ). Recall the formula ϕparity (X, Y )
((80) on page 118). Show that the function parity(X ), which is the
characteristic function of PARITY (page 118), is Σ11 -deﬁnable in V 1 by
showing that
V 1  ∀X ∃!Yϕparity (X, Y ).
Exercise VI.2.7 (String Multiplication in V 1 ).
multiplication function X × Y where

Consider the string

X × Y = Z ↔ bin(Z) = bin(X ) · bin(Y )
and bin(X ) is the integer value of the binary string X (see (46) on page
85). Consider the the Σ11 deﬁning axiom for X × Y in V 1 that is based
on the “school” algorithm for multiplying two integers written in binary
notation. First, we construct the table X ⊗ Y that has |Y | rows and whose
ith row is either 0, if Y (i) = 0 (i.e., ¬Y (i)), or a copy of X shifted left by
i bits, if Y (i) = 1. Thus, X ⊗ Y can be deﬁned by (see Deﬁnition V.4.26
for row notation)
X ⊗ Y = Z ↔ |Z| ≤ |Y |, |X | + |Y | ∧


∀i < |Y |∀z < i + |X | Z [i] (z) ↔ (Y (i) ∧ ∃u ≤ z (u + i = z ∧ X (u))) .
(a) Let Z = X ⊗ Y . Show that V 0 proves the existence and uniqueness
of Z.
(b) Show that V 1 proves the existence and uniqueness of W , where
|W | ≤ 1 + |Y |, |X | + |Y | ∧ |W [0] | = 0 ∧
∀i < |Y |(W [i+1] = W [i] + Z [i] ).
(Hint: Use ΣB1 -IND. For the bound on |W |, show that |W [i] | ≤
|X | + i.)
(c) Deﬁne X × Y in terms of X ⊗ Y . Conclude that the string multiplication function is provably total in V 1 .

VI.2. Characterizing P by V 1

137

(d) Recall string functions ∅, S and X + Y from Example V.4.17. Show
that the following are theorems of V 1 (∅, S, +, ×):
(i) X × ∅ = ∅.
(ii) X × S(Y ) = (X × Y ) + X .
Now we argue that the subtheory IOPEN of Peano Arithmetic (Definition III.1.7) can be interpreted in V 1 by interpreting each number x
by the unique string X such that bin(X ) = x. Then + and × in IOPEN
are interpreted by Example V.4.17 and Exercise VI.2.7 respectively, 0 is
interpreted by ∅, and 1 by the string constant 1 = {0}. It is easy to give
a ΣB0 formula deﬁning the relation X ≤ Y to interpret ≤. Then one can
check that V 0  S(X ) = X + 1, and with the help of Exercises V.4.19
and VI.2.7 it is not hard to show that V 1 (∅, 1, +, ×) proves the string
interpretations of axioms B1, . . . , B8 for PA.
It remains to show that V 1 (∅, 1, +, ×) proves the string interpretations
of the induction axiom scheme (10) (on page 41) for open formulas ϕ(x).
In fact this will follow from our discussion in Section VIII.3 (see Corollary VIII.3.20 and Theorem VIII.2.11).
Consequently V 1 proves the string interpretations of the formulas given
in Example III.1.8 (commutativity and associativity of +, × etc). In fact
it is not hard to show that V 1 also proves the formulas (involving +, ×, ≤)
given in Example III.1.9, even though some of the proofs given there
involve induction on Σb1 -formulas rather than on just open formulas.
Exercise VI.2.8 (String Division and Remainder in V 1 ). Consider the
string division function X ÷Y = X/Y  and the string remainder function
Rem(X, Y ) = X − Y × (X ÷ Y ). These functions can be Σ11 -deﬁned in
V 1 by the following steps. Suppose that Y ≤ X , and let z be such that
z + |Y | = |X |.
(a) Give a ΣB0 -bit-deﬁnition for the table U , where the row U [i] of U is
Y shifted left by i bits, for 0 ≤ i ≤ z.
(b) Prove in V 1 the existence and uniqueness of a table W such that

W [z] = X ∧ ∀i < z (W [i+1] < U [i+1] ⊃ W [i] = W [i+1] ) ∧

(U [i+1] ≤ W [i+1] ⊃ W [i] + U [i+1] = W [i+1] ) .
(c) Deﬁne X ÷ Y and Rem(X, Y ) using W .
(d) Show in V 1 (+, ×, ÷, Rem) that
X = (Y × (X ÷ Y )) + Rem(X, Y ).
VI.2.1. The “If ” Direction of Theorem VI.2.2. We will give two proofs
of the fact that every polynomial time function is Σ11 -deﬁnable in V 1 . The
ﬁrst is based directly on Turing machine computations, and the second
is based on Cobham’s characterization of FP. We give the second proof
in more detail, since it provides the basis for the universal theory VPV
described in Chapter VIII.

138

VI. The Theory V 1 and Polynomial Time

The key idea for the ﬁrst proof is that the computation of a polytime
Turing machine M on a given input x, X can be encoded as a string of
conﬁgurations (see Deﬁnition V.4.26 for notation)
Z = Z [0] , Z [1] , . . . , Z [m] 
whose length is bounded by some polynomial in x, |X |, and whose existence we need to prove in V 1 . The output of M can then be extracted from
Z easily. The deﬁning axiom for the polytime function computed by M is
the formula that states the existence of such Z.
Exercise VI.2.9. Describe a method of coding Turing machine conﬁgurations by strings, and show that for each Turing machine M working
on input x, X there are ΣB0 -deﬁnable string functions in V 0 : InitM (x, X ),
NextM (Z) and OutM (Z) such that
• InitM (x, X ) is the initial conﬁguration of M on input (x, X );
• Z  = NextM (Z) if Z and Z  code two consecutive conﬁgurations of
M, or Z  = Z if Z codes a ﬁnal conﬁguration of M, or Z  = ∅ if Z
does not code a conﬁguration of M.
• OutM (Z) is the tape contents of a conﬁguration Z of M, or ∅ if Z
does not code a conﬁguration of M.
Below we will use all three functions in the above exercise, as well as the
string function Row(z, Y ) (Deﬁnition V.4.26). Because these functions are
ΣB0 -deﬁnable in V 0 , it follows from the FAC 0 Elimination Lemma V.6.7
that any ΣB0 (L2A ∪ {Init, Next, Out, Row}) formula can be transformed
into a provably equivalent ΣB0 (L2A ) formula. Formally we will work in the
conservative extension of V 1 consisting of V 1 together with the deﬁning
axioms for these functions, although we will continue to refer to this
theory as simply V 1 . Thus each ΣB0 (resp. ΣB1 ) formula below with the
new functions is provably equivalent to a ΣB0 (resp. ΣB1 ) formula in the
vocabulary of V 1 .
First proof of the ⇐= direction of Theorem VI.2.2. Consider the
case of string functions. (The case of number functions is similar.) Suppose that F (x, X ) is a polytime function. Let M be a Turing machine
which computes F (x, X ) in time polynomial of x, |X |, and let t(x, |X |)
be a bound on the running time of M on input x, X . We may assume
that M halts with F (x, X ) equal to the contents of its tape, so that
OutM (Z) = F (x, X ) if Z codes the ﬁnal conﬁguration. Then
Y = F (x, X ) ↔ ∃Z ≤ t, t(ϕM (x, X , Z) ∧ Y = OutM (Z [t] ))
where ϕM (x, X , Z) is the formula
Z [0] = InitM (x, X ) ∧ ∀z < t (Z [z+1] = NextM (Z [z] )).

(95)

VI.2. Characterizing P by V 1

139

We will show that the RHS of (95) is a deﬁning axiom for F in V 1 , i.e.,
V 1  ∀x∀X ∃!Y ∃Z ≤ t, t(ϕM (x, X , Z) ∧ Y = OutM (Z [t] )).
For the uniqueness of Y , it suﬃces to verify that if Z1 and Z2 are two
strings satisfying
|Zk | ≤ t, t ∧ ϕM (x, X , Zk )
(for k = 1, 2), then for all z,
[z]
[z]
z ≤ t ⊃ Z1 = Z2 .

(96)

This follows in V 1 using ΣB0 -IND on the formula (96) with induction on z.
For the existence of Y , we need to show that V 1 proves
∀x∀X ∃Z ≤ t, t ϕM (x, X , Z).
This formula can be proved in V 1 by using number induction axiom
(Corollary VI.1.1) on b for the ΣB1 formula
∃W ≤ b, t(W [0] = InitM (x, X ) ∧ ∀z < bW [z+1] = NextM (W [z] )).

2

Exercise VI.2.10. Carry out details of the induction step in the proof
of the above formula.
An alternative proof for the above direction of Theorem VI.2.2 can be
obtained by using Cobham’s characterization of FP. To explain this, we
need the notion of limited recursion. First we introduce the AC 0 string
function Cut(x, X ), which is the initial segment of X and contains all
elements of X that are < x. It has the ΣB0 -bit-deﬁning axiom
Cut(x, X )(z) ↔ z < x ∧ X (z).

(97)

Notation. We will sometimes write X <x for Cut(x, X ).
Deﬁnition VI.2.11 (Limited Recursion). A string function F (y, x, X )
is deﬁned by limited recursion from G(x, X ) and H (y, x, X , Z) iﬀ
F (0, x, X ) = G(x, X ),
F (y + 1, x, X ) = (H (y, x, X , F (y, x, X )))

(98)
<t(y,x,X )

(99)

for some L2A -term t representing a polynomial in y, x, |X |.
For two-sorted function classes, we can also deﬁne the notion of limited
recursion for a number function. However here we can just appeal to
Proposition VI.2.1 (a) when we have to deal with number functions. A
version of Cobham’s characterization of FP is as follows.
Theorem VI.2.12 (Cobham’s Characterization of FP). A string function is in FP iﬀ it can be obtained from AC 0 functions by ﬁnitely many
applications of composition and limited recursion.

140

VI. The Theory V 1 and Polynomial Time

Proof sketch. The ⇐= direction follows from the fact that AC 0 functions are in FP, and that applying the operations composition and limited
recursion to functions in FP results in functions in FP.
For the =⇒ direction, the function F computed by a polytime Turing
machine M can be deﬁned from the AC 0 functions InitM , NextM and
OutM by limited recursion and composition. In more detail, we can deﬁne
a string function Conf M (y, x, X ) to be the string coding the conﬁguration
of M on input (x, X ) at time y. Then Conf M satisﬁes the recursion
Conf M (0, x, X ) = InitM (x, X ),
Conf M (y + 1, x, X ) = NextM (Conf M (y, x, X )).
To turn this recursion into one ﬁtting Deﬁnition VI.2.11 we apply
Cut(t(y, x, X ), . . . )
to the RHS of the second equation, for a suitable L2A -term t bounding the
run time of M. Then
F (x, X ) = OutM (Conf M (t(x, X ), x, X )).

(100)

2

VI.2.2. Application of Cobham’s Theorem.
Second proof of the ⇐= direction of Theorem VI.2.2. We use Cobham’s characterization of FP to show that the polytime string functions are
Σ11 -deﬁnable in V 1 . It follows from Proposition VI.2.1 that the polytime
number functions are also Σ11 -deﬁnable in V 1 .
We proceed by induction on the number of applications of composition
and limited recursion needed to obtain F from AC 0 functions. For the
base case, the AC 0 functions are Σ11 -deﬁnable in V 0 (Corollary V.5.2),
hence also in V 1 . For the induction step, we need to show that the
Σ11 -deﬁnable functions of V 1 are closed under composition and limited
recursion. The case of composition is easily seen to hold for any theory T
(see exercise V.4.5). Hence it suﬃces to prove the case of limited recursion.
Suppose that G(x, X ) and H (y, x, X , Z) are Σ11 -deﬁnable functions in
1
V , and F (y, x, X ) is deﬁned by limited recursion from G and H as in (98)
and (99) for some polynomial p. Then we can Σ11 -deﬁne F by coding the
sequence of values F (0), F (1), . . . , F (y) as the rows W [0] , W [1] , . . . , W [y]
of a single array W . Thus (omitting x, X ):

Y = F (y) ↔ ∃W W [0] = G() ∧

(∀z < y W [z+1] = (H (z, W [z] ))<t(z) ) ∧ Y = W [y] .
The RHS is not immediately equivalent to a Σ11 formula when the equations
involving G and H are replaced by Σ11 formulas using the deﬁning axioms
for G and H . This is because of the number quantiﬁer ∀z < y of the middle
conjunct, which is mixed in between the existential string quantiﬁers. We
obtain a Σ11 -deﬁning axiom for F from the RHS as follows:

VI.2. Characterizing P by V 1

141

By assumption, G and H have Σ11 -deﬁning axioms. Therefore there are

ΣB0 formulas ϕG and ϕH so that
W = G() ↔ ∃U ϕG (U , W ),

W = H (y, Z) ↔ ∃V ϕH (y, Z, V , W )

and
V 1  ∃!W ∃U ϕG (U , W ),

(101)

V  ∀y∀Z∃!W ∃V ϕH (y, Z, V , W ).

(102)

1

The Σ11 -deﬁning axiom for F is obtained by using arrays V for which V [z]
(row z in the arrays V ) codes the values of V needed to satisfy (102) when
evaluating H (z, W [z] ).

Y = F (y) ↔ ∃W ∃U ∃V ϕG (U , W [0] ) ∧

(∀z < yϕH (z, W [z] , V [z] , (W [z+1] )<t(z) )) ∧ Y = W [y] . (103)
Since the terms such as (W [z+1] )<t(z) are easily seen to be ΣB0 -bit-deﬁnable,
it follows from Lemma V.6.7 that this deﬁning axiom can be replaced by
an equivalent Σ11 -formula (see the discussion following Exercise VI.2.9).
It is easy to see that V 1 proves the uniqueness of Y by proving that if
W1 and W2 satisfy (103), then for z ≤ y we have W1[z] = W2[z] . This is
by number induction on z ≤ y, and follows from the uniqueness of W in
(101) and (102).
Now we show that V 1 proves the existence of Y satisfying the RHS of
(103). We start by noting that all of the initial string quantiﬁers can be
bounded. This follows from Parikh’s Theorem, using (101) and (102). Let
(y) be the ΣB1 -formula obtained from this bounded form of the RHS of
(103), with the ﬁnal conjunct Y = W [y] deleted. Thus (y) asserts the
existence of an array
W = (W [0] , W [1] , . . . , W [y] )
whose rows are the successive values
F (0), F (1), . . . , F (y).
We show that V 1 proves (y) by induction on y. The base case follows from (101): If W  satisﬁes the existential quantiﬁer ∃W in (101),
then W satisfying (y) can be deﬁned using multiple comprehension
(Lemma VI.1.2):
W (0, i) ↔ W  (i).
For the induction step, the new values of W and V for y + 1 are obtained
by pasting together the previous values for y, together with values from
(102) with (y, Z) in ϕH replaced by (y, W [y] ). The pasting is again deﬁned
using multiple comprehension.

142

VI. The Theory V 1 and Polynomial Time

Hence V 1  (y). From this it follows that V 1 proves the existence
of Y satisfying the RHS of (103): just set Y = W [y] . Hence F (y) is
Σ11 -deﬁnable in V 1 .
2

VI.3. The Replacement Axiom Scheme
Recall that the classes ΣBi and ΠBi consist of bounded formulas in which
all string quantiﬁers occur in front. We now deﬁne more general classes
which allow mixing bounded number quantiﬁers with bounded string
quantiﬁers.
Deﬁnition VI.3.1 (gΣBi (L) and gΠBi (L)). For a vocabulary L extending L2A , deﬁne
gΣB0 (L) = gΠB0 (L) = ΣB0 (L).
For i ≥ 0, gΣBi+1 (L) is the closure of gΠBi (L) under ∧, ∨, ∀x ≤ t, ∃x ≤ t
and ∃X ≤ t. Similarly, gΠBi+1 (L) is the closure of gΣBi (L) under ∧, ∨,
∀x ≤ t, ∃x ≤ t and ∀X ≤ t.
We usually write gΣBi for gΣBi (L2A ) and gΠBi for gΠBi (L2A ).
It is easy to see that
ΣB0 (L) ⊂ gΣB1 (L) ⊂ gΣB2 (L) ⊂ · · · ,
ΣB0 (L) ⊂ gΠB1 (L) ⊂ gΠB2 (L) ⊂ · · · .
Although for i ≥ 1 the syntactic classes gΣBi (L) and gΠBi (L) do not
allow negations in front of string quantiﬁers, note that a negated gΣBi (L)
formula is logically equivalent to a gΠBi (L) formula, and vice versa. Hence
every formula in ΣB0 (ΣBi (L) ∪ ΠBi (L)) is equivalent to one in gΣBi+1 (L) and
one in gΠBi+1 (L)
For any formula ϕ + in gΣBi there is a formula ϕ in ΣBi so that in the
standard model N2 we have ϕ + ↔ ϕ. In particular, when ϕ + is a gΣB1
formula of the form
∀x ≤ t∃X ≤ t (x, X )
where is a ΣB0 formula, then we can collect the values of X for x =
0, 1, . . . , t into a single array Y whose rows Y [0] , Y [1] , . . . , Y [t] are these
successive values of X . Thus we can take ϕ to be
∃Y ≤ t, t∀x ≤ t(|Y [x] | ≤ t ∧ (x, Y [x] )).
In this case ϕ ⊃ ϕ + is logically valid, and ϕ + ⊃ ϕ is true in the standard
model N2 , but may not be valid. In this section we are concerned with the
provability of formulas of the type ϕ + ⊃ ϕ in our theories. Consider the
following axiom scheme.

VI.3. The Replacement Axiom Scheme

143

Deﬁnition VI.3.2 (Replacement Axiom). For a set Φ of formulas over
the vocabulary L, the replacement axiom scheme for Φ, denoted by ΦREPL, is the set of all formulas (over L ∪ {Row}):
(∀x ≤ b∃X ≤ cϕ(x, X )) ⊃
∃Z ≤ b, c∀x ≤ b(|Z [x] | ≤ c ∧ ϕ(x, Z [x] )) (104)
where ϕ is in Φ.
Note that in (104) the LHS is a logical consequence of the RHS. Also
(104) is true in the expansion of the standard model N2 , for any formula ϕ.
The function Row occurs on the RHS of (104), but by the Row Elimination Lemma V.4.27 (or more generally the FAC 0 Elimination Lemma
V.6.7), any ΣB0 (Row) formula is equivalent to a ΣB0 (L2A ) formula. So in the
1
context of the theories with underlying vocabulary L2A (such as V i , or V
2
below), we deﬁne (104) to be the equivalent LA formula which is obtained
by transforming every atomic sub-formula containing Row into a ΣB0 (L2A )
formula.
Notation. When we say that a theory T with vocabulary L proves a
REPL axiom scheme (e.g., ΣB0 (L)-REPL), then either L2A ∪ {Row} ⊆ L,
or L = L2A and (104) is as above.
Recall that a single-ΣB1 formula has the form ∃X ≤ t (X ), where is
a ΣB0 formula.
Lemma VI.3.3. Suppose that T is a polynomial–bounded theory which
proves the ΣB0 (L)-REPL axiom scheme, where L is the vocabulary of T (so
either L = L2A , or L2A ∪ {Row} ⊆ L). Then for each gΣB1 (L) formula ϕ
there is a single-ΣB1 (L) formula ϕ  so that T  ϕ ↔ ϕ  .
Proof. We prove by structural induction on the formula ϕ. For the
base case, if ϕ is a ΣB0 (L) formula, then we can simply take ϕ  ≡ ϕ.
For the induction step, consider the interesting case where ϕ has the
form ∀x ≤ s(x), where  is a gΣB1 (L) formula but not a ΣB0 (L) formula.
By the induction hypothesis, (x) is equivalent in T to a single-ΣB1 (L)
formula ∃X ≤ t (x, X ), where is a ΣB0 (L) formula. In other words,
T  ϕ ↔ ∀x ≤ s∃X ≤ t (x, X ).
Now T proves ϕ is equivalent to a single-ΣB1 (L) formula by ΣB0 (L)-REPL.
The other cases for the induction step follow easily with the help of exercise V.4.30, which shows that a preﬁx of several bounded string quantiﬁers
can be collapsed into a single one.
2
In the next lemma we generalize the previous lemma. Part (b) follows
easily from (a), and (a) can be proved by induction on i. The base case is
proved in Lemma VI.3.3. The induction step is similar to the base case.

144

VI. The Theory V 1 and Polynomial Time

Lemma VI.3.4. Let T be a polynomial–bounded theory with vocabulary
L which proves the ΠBi (L)-REPL axiom scheme, for some i ≥ 0 (so either
L = L2A , or L2A ∪ {Row} ⊆ L). Then
(a) For each gΣBi+1 (L) formula ϕ there is a ΣBi+1 (L) formula ϕ  so that
T  ϕ ↔ ϕ .
(b) For each gΠBi+1 (L) formula ϕ there is a ΠBi+1 (L) formula ϕ  so that
T  ϕ ↔ ϕ .
Exercise VI.3.5. Prove the above lemma.
Exercise VI.3.6. Let T , L and i be as in Lemma VI.3.4 above. Show
that T proves the ΣBi+1 (L)-REPL axiom scheme.
The next lemma shows that V 1 proves the ΣB1 -REPL axiom scheme. It is
important to note that the analogous statement does not hold for V 0 : we
will prove later (see Section VIII.6) that V 0 does not prove the ΣB0 -REPL
axiom scheme. (It follows from Exercise VI.3.6 that over V 0 ΣB1 -REPL
follows from ΣB0 -REPL, i.e., the two axioms schemes are equivalent over
V 0 .) Also, we will introduce the universal theory VPV which characterizes
P in the same way that V 1 characterizes P, and we will show that it is
unlikely that VPV proves ΣB1 -REPL.
Lemma VI.3.7. Let T be an extension of V 0 , where the vocabulary L of T
is either L2A or L2A ∪ {Row} ⊆ L). Suppose that T proves the ΣBi+1 (L)-IND
axiom scheme, for some i ≥ 0. Then T also proves the ΠBi (L)-REPL axiom
scheme.
Proof. Let ϕ be a ΠBi (L) formula. We will show that T proves (104).
Intuitively, the RHS of (104) is the formula which states the existence of
an array Z having b rows, whose x-th row Z [x] satisﬁes ϕ(x, Z [x] ). We
will prove by number induction the existence of the initial segments of Z,
and hence derive the existence of Z.
Formally we need to make sure that the RHS of (104) is equivalent to
a ΣBi+1 (L) formula. First consider the case where i = 0, so ϕ is a ΣB0 (L)
formula. Let
(z) ≡ ∃Z ≤ z, c∀x ≤ z(|Z [x] | ≤ c ∧ ϕ(x, Z [x] )).
Then (z) is a ΣB1 (L) formula and the RHS of (104) is just (b). Our
task is to show in T that (z) holds for z ≤ b, assuming the LHS of
(104). This is proved in T by induction on z ≤ b. For the base case,
(0) follows from the LHS of (104) by putting x = 0. The induction
step follows from the induction hypothesis and the LHS of (104), using
ΣB0 -COMP.
For the case where i ≥ 1, note that when ϕ is a ΠBi (L) formula, the
RHS of (104) is not really a ΣBi+1 (L) formula. But it is equivalent (in T )
to:
∃Z ≤ b, c∀Y ≤ b (|Z [|Y |] | ≤ c ∧ ϕ(x, Z [|Y |] ))

VI.3. The Replacement Axiom Scheme

145

which is equivalent to a ΣBi+1 (L) formula. Let be the equivalent ΣBi+1 (L)
formula, then we can use the same arguments as for the case i = 0.
2
From Exercise VI.3.6, Lemma VI.3.7, Corollary VI.1.1, Corollary
VI.1.4, and Lemma VI.3.3 we have:
Corollary VI.3.8. For i ≥ 1, the theory V i proves the gΣBi -REPL
axiom scheme. For each gΣBi (resp. gΠBi ) formula ϕ, there is a single-ΣBi
(resp. single-ΠBi ) formula ϕ  such that V i  ϕ ↔ ϕ  . Also V i proves
Φi -COMP, Φi -IND, Φi -MIN and Φi -MAX, where Φi = ΣB0 (gΣBi ∪ gΠBi ).
VI.3.1. Extending V 1 by Polytime Functions. By the Extension by Deﬁnition Theorem III.3.5, if we extend V 1 by a collection L of its Σ11 -deﬁnable
functions (i.e., polytime functions), Δ11 -deﬁnable predicates (i.e., polytime
predicates), and their deﬁning axioms, then we obtain a conservative extension V 1 (L) of V 1 . Here we want to show further that V 1 (L) proves
the ΣB1 (L)-COMP axiom scheme. This is similar to the situation for V 0 ,
where it follows from Corollary V.4.14 and Lemma V.4.15 that V 0 (L) is
conservative over V 0 , and it proves the ΣB0 (L)-COMP axiom scheme for
a collection L of AC 0 functions. Note that for the case of V 0 , the AC 0
string functions are ΣB0 -bit-deﬁnable in V 0 .
Here it suﬃces to show that any ΣB1 (L) formula is provably equivalent
in V 1 (L) to a ΣB1 (L2A ) formula. We will prove this by structural induction
on the ΣB1 (L) formula. For the induction step, we use Corollary VI.3.8
above. More generally, we prove:
Lemma VI.3.9 (ΣB1 -Transformation). Let T be a polynomial-bounded
theory over the vocabulary L ⊇ L2A ∪ {Row}. Suppose that T proves
ΣB0 (L)-REPL. Let T  be the extension of T which is obtained by adding to
T a Σ11 (L)-deﬁnable function or a Δ11 (L)-deﬁnable predicate, and its deﬁning
axiom, and L be the vocabulary of T  . Then
(a) T  is conservative over T , and T  is polynomial-bounded ;
(b) For any ΣB1 (L ) formula ϕ + , there is a ΣB1 (L) formula ϕ so that
T   ϕ + ↔ ϕ;
(c) For any ΣB0 (L ) formula ϕ + , there are a ΣB1 (L) formula ϕ1 and a
ΠB1 (L) formula ϕ2 so that T   ϕ + ↔ ϕ1 , and T  ϕ1 ↔ ϕ2 ;
(d) T  proves the ΣB1 (L )-REPL axiom scheme.
Indeed, by Exercise V.4.30, the formulas ϕ and ϕ1 can be taken to be
single-ΣB1 (L) formulas, and ϕ2 can be taken to be a single-ΠB1 (L) formula.
Proof. For (a) the conservativity of T  over T follows from the Extension by Deﬁnition Theorem III.3.5. Also, T  is polynomial-bounded because T is, and the Σ11 -deﬁnable functions of T are polynomially bounded
(Corollary V.4.4).
Part (b) follows from (c), and (d) follows from (c) and Exercise VI.3.6
(for the case i = 0). We prove (c) for the case of extending T by a

146

VI. The Theory V 1 and Polynomial Time

Σ11 -deﬁnable string function. The case of adding a Σ11 -deﬁnable number
function or a Δ11 -deﬁnable predicate is similar, and is left as an exercise.
Let F be the Σ11 (L)-deﬁnable function in T . Since T is a polynomialbounded theory, F is polynomially bounded in T , and is ΣB1 (L)-deﬁnable
in T (Corollary V.4.4). So there is a ΣB1 (L) formula ϕF (x, X , Y ) such that
Y = F (x, X ) ↔ ϕF (x, X , Y )

(105)

T  ∀x∀X ∃!Y ≤ tϕF (x, X , Y ).

(106)

and

By Lemma VI.3.3, it suﬃces to prove a simpler statement, i.e., that
there exist a gΣB1 (L) formula ϕ1 and a gΠB1 (L) formula ϕ2 such that
T   ϕ + ↔ ϕ1 and T  ϕ1 ↔ ϕ2 . We prove this by induction on the
nesting depth of F in ϕ + . For the base case, F does not occur in ϕ + , and
there is nothing to prove. For the induction step, ﬁrst we prove:
Claim. Suppose that for each atomic sub-formula of ϕ + , there are
a gΣB1 (L) formula 1 and a gΠB1 (L) formula 2 so that T   + ↔ 1
and T  1 ↔ 2 . Then there are a gΣB1 (L) formula ϕ1 and a gΠB1 (L)
formula ϕ2 so that T   ϕ + ↔ ϕ1 and T  ϕ1 ↔ ϕ2 .
We prove the claim by structural induction on ϕ + . The base case
holds trivially. The induction step is immediate from deﬁnition of gΣB1 (L)
formulas and De Morgan’s laws.
Now we return to the proof of the induction step for (c). By the claim,
it suﬃces to consider the atomic formulas over L . We can reduce the
nesting depth of F as follows. The maximum nesting depth of F is the
depth of F in (diﬀerent) terms of the form F (s, T ), where s, T are terms
with less nesting depth of F . We will show how to eliminate one such
term from ϕ + . In the general case all such terms can be eliminated using
the same method. Write ϕ + as ϕ + (F (s, T )). Then using (105) and (106)
it is easy to see that (writing t for t(s , T )):
T   ϕ + (F (s , T )) ↔ ∃Y ≤ t(ϕF (s, T , Y ) ∧ ϕ + (Y ))
and
T   ∃Y ≤ t(ϕF (s, T , Y ) ∧ ϕ + (Y )) ↔ ∀Y ≤ t(ϕF (s, T , Y ) ⊃ ϕ + (Y )).
The last line has the form T   ϕ1 ↔ ϕ2 , where ϕ1 is equivalent to a
ΣB1 (L ) formula and ϕ2 is equivalent to a ΠB1 (L ) formula. Further ϕ1
and ϕ2 have less nesting depth of F than ϕ + (F (s , T )). By applying the
induction hypothesis to the atomic sub-formulas, we obtain a gΣB1 (L)
formula ϕ1 and a gΠB1 (L) formula ϕ2 that satisfy the induction step. 2
Exercise VI.3.10. Prove Lemma VI.3.9 (c) for the cases of extending
T by a Σ11 -deﬁnable number function and a Δ11 -deﬁnable predicate.

VI.4. The Witnessing Theorem for V 1

147

Corollary VI.3.11. Suppose that T0 is a polynomial-bounded theory
with vocabulary L0 ⊇ L2A ∪ {Row}, and that T0 proves the ΣB0 (L0 )-REPL
axiom scheme. Let T0 ⊂ T1 ⊂ T2 ⊂ · · · be a sequence of extensions of T0
where each Ti has vocabulary Li and each Ti+1 is obtained from Ti by adding
the deﬁning axiom for a Σ11 (Li )-deﬁnable function or a Δ11 (Li )-deﬁnable
predicate. Let

T =
Ti .
i≥0

Then T is a polynomial-bounded theory which is conservative over T0 and
proves the ΣB1 (L)-REPL axiom scheme, where L is the vocabulary of T .
Furthermore, each function in L is Σ11 (L0 )-deﬁnable in T0 , and each predicate
in L is Δ11 (L0 )-deﬁnable in T0 . Finally each ΣB1 (L) formula is provably
equivalent in T to a ΣB1 (L0 ) formula.
The corollary is proved using Lemma VI.3.9 by proving by induction on
i that the analogous statement holds for each theory Ti . The conservativity
of T follows from the conservativity of each Ti by compactness.
The corollary can be applied to the case in which T0 = V 1 , since by
Corollary VI.3.8, V 1 proves ΣB1 -REPL, and we may assume that T1 is
V 1 (Row). We will use Corollary VI.3.11 for T0 = V 1 (Row) in Subsection VI.4.2 when we prove the Witnessing Theorem for V 1 .

VI.4. The Witnessing Theorem for V 1
To prove the =⇒ direction of Theorem VI.2.2, i.e., every Σ11 -deﬁnable
function in V 1 is a polytime function, we prove the Witnessing Theorem
for V 1 below. Recall that by the ⇐= direction, each polytime function has
a Σ11 -deﬁning axiom in V 1 .
Theorem VI.4.1 (Witnessing Theorem for V 1 ). Suppose that ϕ(x, y,
X , Y ) is a ΣB0 formula, and that
V 1  ∀x∀X ∃y∃Y ϕ(x, y, X , Y ).
Then there are polytime functions f1 , . . . , fk , F1 , . . . , Fm so that
V 1 (f1 , . . . , fk , F1 , . . . , Fm )  ∀x∀X ϕ(x, f(x, X ), X , F (x, X )).
A more general witnessing statement follows from this theorem and
Corollary VI.3.11 and Lemma VI.3.3.
Corollary VI.4.2. Let T be a theory with vocabulary L which results
from V 1 by a sequence of extensions by Σ11 -deﬁnable functions and Δ11 deﬁnable predicates. If
T  ∀x∀X ∃Yϕ(x, X , Y )

148

VI. The Theory V 1 and Polynomial Time

where ϕ is in gΣB1 (L) then there is a polytime function F such that
T (F )  ∀x∀X ϕ(x, X , F (x, X )).
Example VI.4.3 (Prime Recognition). Any polynomial time prime recognition algorithm (such as the one by Agrawal et al [2]) gives a predicate
Prime(X ) which according to Corollary VI.2.4 is ΔB1 deﬁnable in V 1 . It
follows by the Witnessing Theorem that if V 1 proves the correctness of
the algorithm, then binary integers can be factored in polynomial time.
Here correctness means


Prime(X ) ↔ 2 ≤ |X | ∧ ∀Y ∀Z(Y × Z = X ⊃ (X = Y ∨ X = Z)) .
(Recall that Y × Z is Σ11 deﬁnable in V 1 , by Exercise VI.2.7). In fact, the
right-to-left direction of this correctness statement implies


∀X ∃Y ∃Z (Y × Z = X ∧ X = Y ∧ X = Z) ∨ Prime(X ) ∨ |X | < 2 .
Thus if V 1 (Prime, ×) proves correctness then polynomial time witnessing
functions for Y and Z would provide proper factors for each nonprime
X with |X | ≥ 2.
Exercise VI.4.4 (Prime Factorization). Show that V 1 proves that every
binary integer X greater than 1 can be represented as a product of primes.
Use the fact that V 1 proves the ΣB1 -MAX axioms (Corollary V.1.8), where
we are trying to maximize k such that
 for some string Y = Z1 , . . . , Zk 
with each Zi a binary number ≥ 2, Zi = X . Explain why it does not
follow from the Witnessing Theorem for V 1 that binary integers can be
factored into primes in polynomial time.
As in the proof of the Witnessing Theorem for V 0 (Subsection V.5.2),
the Witnessing Theorem for V 1 follows from the following special case.
Lemma VI.4.5. Suppose that ϕ(x, X , Y ) is a ΣB0 formula such that
V 1  ∀x∀X ∃Yϕ(x, X , Y ).
Then there is a polytime function F so that
V 1 (F )  ∀x∀X ϕ(x, X , F (x, X )).
Our ﬁrst attempt to prove the lemma would be to consider an anchored
LK 2 -V 1 proof  of ∃Y ≤ t ϕ(x, X , Y ), and proceed as in the proof of
Lemma V.5.5. In this case, however, a ΣB1 -COMP axiom
∃X ≤ y∀z < y(X (z) ↔ ϕ(z))

(107)

is not in general provably equivalent to a ΣB1 formula, because of the clause
ϕ(z) ⊃ X (z). So the LK 2 -V 1 proof  could contain formulas which are
not Σ11 . To get around this diﬃculty, we begin by showing that V 1 can be
axiomatized by ΣB1 -IND and ΣB0 -COMP instead of ΣB1 -COMP. Consider
 1:
the theory V

VI.4. The Witnessing Theorem for V 1

149

 1 has vocabulary L2 and has the axDeﬁnition VI.4.6. The theory V
A
0
B
ioms of V and the Σ1 -IND axiom scheme.
 1 can be axiomatized by V 0 and the single-ΣB -IND
By Exercise V.4.30, V
1
axiom scheme.
 1 proves the ΣB -REPL axioms.
Lemma VI.4.7. V
1
Proof. Corollary VI.3.8 states this for V 1 , and the only properties of V 1
used in the proof are that V 1 extends V 0 and proves the ΣB1 -IND axioms.
 1.
2
Hence the same proof works for V
1
1

Theorem VI.4.8. The theories V and V are the same.
Proof. By Corollary VI.1.1, V 1 proves the ΣB1 -IND axiom scheme.
 1 ⊆ V 1 . It remains to prove the other direction.
Therefore V
As noted earlier, (107) is not in general equivalent to a ΣB1 formula,
so we cannot use ΣB1 -IND directly on (107) to prove the existence of X .
We introduce the number function numones(y, X ), which is the number
of elements of X that are < y. Recall that seq(u, Z) = (Z)u is the AC 0
function used for coding a ﬁnite sequence of numbers (Deﬁnition V.4.31).
The function numones has the deﬁning axiom:
numones(y, X ) = z ↔


z ≤ y ∧ ∃Z ≤ 1 + y, y (Z)0 = 0 ∧ (Z)y = z ∧ ∀u < y((X (u) ⊃

(Z)u+1 = (Z)u + 1) ∧ (¬X (u) ⊃ (Z)u+1 = (Z)u )) . (108)

Here Z codes a sequence of (y+1) numbers so that (Z)u = numones(u, X ),
for u ≤ y.
Exercise VI.4.9. (a) Show that (108) is a ΣB1 deﬁnition of numones in
 1 , i.e., show that V
 1  ∀y∀X ∃!zϕnumones (y, z, X ), where ϕnumones (y,
V
z, X ) is the RHS of (108).
 1 (numones).
(b) Show that the following is a theorem of V


∃x < y X (x) ∧ ¬Y (x) ∧ ∀u < y (u = x ⊃ (X (u) ↔ Y (u))) ⊃
numones(y, X ) = numones(y, Y ) + 1.
Although (107) may not be ΣB1 , the result of replacing ↔ by ⊃ is ΣB1 .
Motivated by this, we deﬁne
(y, Y ) ≡ ∀z < y(Y (z) ⊃ ϕ(z)).
Let X be the set satisfying the existential quantiﬁer in (107). Then (y, Y )
asserts Y ⊆ X .
Now consider the formula


(w, y) ≡ ∃Y ≤ y (y, Y ) ∧ w = numones(y, Y ) .
For any w and Y that satisfy (w, y), we have w ≤ numones(y, X ),
and Y = X iﬀ Y satisﬁes (w0 , y), where w0 is the maximal value for

150

VI. The Theory V 1 and Polynomial Time

w. To formalize this argument, we need the ΣB1 -MAX axioms, which by
Deﬁnition V.1.5 have the form


ϕ(0) ⊃ ∃x ≤ y ϕ(x) ∧ ¬∃z ≤ y(x < z ∧ ϕ(z))
where ϕ(x) is ΣB1 . These are provable in V 1 by Corollary VI.1.1.
 1 proves the ΣB -MAX axioms. Hint:
Exercise VI.4.10. Show that V
1
B

Apply Σ1 -IND to the formula ϕ (x) given by


∃z ≤ y x ≤ z ∧ ϕ(z) .
 1 , it follows from Lemmas VI.3.8
Since numones is Σ11 -deﬁnable in V
1
 1 and proves that

and VI.3.9 that V (numones) is a conservative over V
B
B
every Σ1 (numones)-formula is equivalent to some Σ1 -formula. Hence by
 1 (numones) proves the ΣB -MAX(numones) axioms.
Exercise VI.4.10, V
1
 1 , we
Now apply ΣB1 -MAX for the case ϕ(w) is (w, y). Arguing in V
have (0, y) (take Y to be the empty set), and hence there is a maximum
w0 ≤ y satisfying (w0 , y). We argued above that the set Y corresponding
to w0 is the set X satisfying (107), and this argument can be formalized
 1 using Exercise VI.4.9.
2
in V
2 1
1

VI.4.1. The Sequent System LK -V . We now convert V into an
 1 , which is deﬁned essentially as in Deﬁequivalent sequent system LK 2 -V
1

nition IV.4.2 (for Φ = V ), but now we replace the ΣB -IND axiom scheme
1

by the ΣB1 -IND inference rule. Recall that for LK 2 , terms do not contain
any bound variables x, y, z, . . . , X, Y, Z, . . . , and formulas do not contain
free occurrence of any bound variable, or bound occurrence of any free
variable.
Deﬁnition VI.4.11 (The IND Rule). For a set Φ of formulas, the ΦIND rule consists of the inferences of the form
Γ, A(b) −→ A(b + 1), Δ
(109)
Γ, A(0) −→ A(t), Δ
where A is a formula in Φ.
Restriction. The variable b is called an eigenvariable and does not occur
in the bottom sequent.
Notation. In general, we refer to an LK 2 proof where the IND rule is
allowed as an LK 2 +IND proof.
In this chapter we are mainly interested in this rule for the case where
Φ is ΣB1 .
 1 ). The rules of LK 2 -V
 1 consist of the rules
Deﬁnition VI.4.12 (LK 2 -V
2
B
of LK (Section IV.4), together with the single-Σ1 -IND rule (109). The
 1 are sequents of the form −→ A, where A
non-logical axioms of LK 2 -V

VI.4. The Witnessing Theorem for V 1

151

is any term substitution instance of a ΣB0 -COMP axiom or a 2-BASIC
axiom (Figure 2) or an LK 2 equality axiom (Deﬁnition IV.4.1).
 1 are the same as those of LK 2 -V 0 .
Thus the axioms of LK 2 -V
 1 proof generalizes the notion of an
The notion of an anchored LK 2 -V
2
anchored LK proof (Deﬁnition IV.4.4) to include the rule ΣB1 -IND above.
 1 are closed under substitution of terms
Note that the axioms of LK 2 -V
for free variables. More generally, we have:
Deﬁnition VI.4.13 (Anchored LK 2 Proof with the IND Rule). An
LK 2 proof  where the rule Φ-IND is allowed, for some set Φ of formulas,
is said to be anchored provided that every cut formula in  occurs also
either as a formula in the non-logical axioms of , or as one of the formulas
A(0), A(t) in an instance of the rule Φ-IND (109).
The following exercise is to show the soundness of LK 2 +IND in general.
 1 is sound, in the sense that the sequents provable in
It follows that LK 2 -V
2 1
 1.
LK -V are also provable in V
Exercise VI.4.14 (Soundness of LK 2 +IND). Let Ψ and Φ be sets of
formulas. Show that if A has an LK 2 -Ψ proof, where the Φ-IND rule is
allowed, then A is a theorem of the theory axiomatized by Ψ ∪ Φ-IND.
To prove the Witnessing Theorem for V 1 , we ﬁrst prove that every the 1 proof. This is stated more generally
 1 has an anchored LK 2 -V
orem of V
as follows.
Theorem VI.4.15 (Anchored Completeness for LK 2 +IND). Let Ψ
and Φ be two sets of formulas over a vocabulary L, and suppose that Ψ
includes formulas which are the semantic equivalents of the equality axioms
(Deﬁnition IV.4.1). Suppose that T is the theory which is axiomatized by
the set of axioms Ψ ∪ Φ-IND. Let Ψ and Φ be the closures of Ψ and
Φ respectively under substitution of terms for free variables. Then for any
theorem A of T there is an anchored LK 2 -Ψ proof of −→ A where instances
of the Φ -IND rule are allowed.
 1 (and hence to V 1 , by Theorem VI.4.8) take T = V
 1,
To apply this to V
B
B
Φ = Σ1 and Ψ = 2-BASIC ∪ Σ0 -COMP.
1
Corollary VI.4.16. Every theorem of V 1 has an anchored LK 2 -V
proof.
Proof of Theorem VI.4.15. We refer to an anchored LK 2 +IND proof
of the type stated above simply as an anchored LK 2 -Ψ proof, with the
understanding that the Φ -IND rule is allowed. We will show that if a
sequent Γ −→ Δ is a theorem of T (in the sense that its semantic formula
given in Deﬁnition II.2.16 is a theorem of T ), then there is an anchored
LK 2 -Ψ proof of Γ −→ Δ.

152

VI. The Theory V 1 and Polynomial Time

Recall the proof of the Completeness Lemma II.2.24 and the Anchored
LK Completeness Theorem II.2.28 (outlined in Exercise II.2.29). Our
proof here is by the same method, i.e., for a sequent Γ −→ Δ purportedly
provable in T , we try to ﬁnd an anchored LK 2 -Ψ proof of Γ −→ Δ. Our
procedure guarantees that in the case where no such proof is found, then
we will be able to deﬁne a structure that satisﬁes T but does not satisfy
Γ −→ Δ. Thus we can conclude that Γ −→ Δ is not provable in T .
We begin by listing all formulas, variables, and terms. In two-sorted
logic, there are two sorts of terms: number terms and string terms. So we
enumerate all quadruples Ai , cj , tk , T , where Ai is an L-formula, cj is
a free variable, tk is an L-number term, and T is an L-string term. (The
term tk contains only free variables a, b, . . . , α, , . . . .) The enumeration
is such that each quadruple Ai , cj , tk , T  occurs inﬁnitely many times.
The proof  is constructed in stages. Initially  consists of just the
sequent Γ −→ Δ. At each stage we expand  by applying the IND rule
and the rules of LK 2 in reverse. We follow the 3 steps listed in the proof
of the Completeness Lemma, with necessary modiﬁcations. The idea is
that if this proof-building procedure does not terminate, then the term
model M derived from it satisﬁes T but not Γ −→ Δ. In particular, in this
case the procedure produces an inﬁnite sequence of sequents Γn −→ Δn
(starting with Γ −→ Δ), and M is deﬁned in such a way that it satisﬁes
every formula in the antecedents Γn , and falsiﬁes every formula in the
succedents Δn .
We modify the notion of an active sequent as follows.
Notation. In the process of constructing , a sequent is said to be
active if it is active as deﬁned on page 27, and it cannot be derived from
−→ B for some B in Ψ using only the exchange and weakening rules.
We use one quadruple Ai , cj , tk , T  of our enumeration in each stage.
Here are the details for the next stage in general.
Let Ai , cj , tk , T  be the next quadruple in our enumeration. Call Ai
the active formula for this stage.
Step 1. If Ai is in Ψ , then expand  at every active sequent Γ −→ Δ
as follows:
−→ Ai
==
======== (weakening)

Γ −→ Δ , Ai
Ai , Γ −→ Δ
(cut)
Γ −→ Δ




Step 2a. If Ai ∈ Φ and cj has one or more free occurrences in Ai , then
we incorporate an application of the IND rule for Ai . Let b be a new
free variable that does not occur in the proof so far, and let A(b) be the
result of substituting b for cj in Ai . For each active sequent Γ −→ Δ we

VI.4. The Witnessing Theorem for V 1

153

expand  as follows:
A(tj ), Γ −→ Δ
Γ , A(b) −→ A(b + 1), Δ
=======
=
=
=
=
=
=
=
=
=
=
A(tj ), Γ , A(0) −→ Δ
Γ , A(0) −→ A(tj ), Δ
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
================
Γ −→ Δ , A(0)
Γ , A(0) −→ Δ
==================
=====================
Γ −→ Δ
Here the top-right inference is by the Φ-IND rule, and the three double
lines are for the weakening, cut and exchange rules (with cut formulas
A(0), A(tj )).
Step 2b. Proceed as in the Step 2 in the proof of the Anchored LK
Completeness Lemma II.2.24. Here we use the string term Tk in our
enumeration for the string quantiﬁers, in addition to the number term tj
which is for the number quantiﬁers, just as in the mentioned proof.
Step 3. If there is no active sequent remaining in , then exit from the
algorithm. Otherwise continue to the next stage.
It is easy to verify that if the above procedure terminates, then the
resulting proof  is an anchored LK 2 -Ψ proof of Γ −→ Δ. It remains
to show that if the procedure does not halt, then the sequent Γ −→ Δ is
not a logical consequence of T . This is similar as for the Completeness
Lemma II.2.24, and is left as an exercise.
2
Exercise VI.4.17. Complete the proof of the Anchored Completeness
Lemma for LK 2 +IND above by constructing, in the case where the procedure does not terminate, a term model M (see Deﬁnition II.2.26) that
satisﬁes T but not the sequent Γ −→ Δ. The two equality relations =1
and =2 are not necessarily interpreted as true equality in the term model,
but by our assumption on Ψ the equality axioms of Deﬁnition IV.4.1 are
satisﬁed, so the equivalence classes of terms form a true model. Also
note that the occurrences of A(0) in the antecedent of the construction
for Step 2a disappear from the sequents above them, so the term model
must be deﬁned in such a way that A(0) is not necessarily satisﬁed. Show
nevertheless that the Φ-IND axioms are satisﬁed.
Eﬀectively we have shown that any LK 2 proof with axioms from T can
be transformed into an anchored LK 2 +IND proof with axioms only from
Ψ . The advantage of the latter type of LK proofs is that the cut formulas
are now essentially from Φ∪Ψ , instead of the instances of Φ-IND∪Ψ. In
 1 proofs, the cut formulas are restricted to ΣB formulas
the case of LK 2 -V
1
(indeed, single-ΣB1 formulas), while normally, an LK 2 proof with axiom
 1 (Deﬁnition II.2.21) contains cut formulas which are in general
from V
 1 proofs is important for our proof of the
not ΣB1 . This property of LK 2 -V
1
Witnessing Theorem for V that we present in the next section.
Proposition VI.4.18 (Subformula Property of LK 2 +IND). Suppose
that Ψ and Φ are sets of formulas, both of which are closed under substitution

154

VI. The Theory V 1 and Polynomial Time

of terms for free variables. Suppose that  is an anchored LK 2 -Ψ proof of
S, where the Φ-IND rule is allowed. Then every formula in every sequent of
 is a sub-formula of a formula in S or in Ψ ∪ Φ.
VI.4.2. Proof of the Witnessing Theorem for V 1 . Now we prove the
Witnessing Theorem for V 1 , using the same method as for the proof of
the Witnessing Theorem for V 0 (Subsection V.5.2). Here it suﬃces to
prove Lemma VI.4.5.
Suppose that ∃Zϕ(a, α, Z) is a Σ11 theorem of V 1 , where ϕ is a ΣB0
 1 Completeness Theorem VI.4.15,
formula. Then by the Anchored LK 2 -V
2 1
there is an anchored LK -V proof  of ∃Zϕ(a, α, Z). We may assume
that  is in free variable normal form, where now Deﬁnition II.2.20 is
modiﬁed to allow applications of the ΣB1 -IND rule to eliminate a variable
from a sequent (in addition to ∀-right and ∃-left). By the Subformula
 1 (Proposition VI.4.18), the formulas in  are Σ1 forProperty of LK 2 -V
1
mulas, and in fact they are ΣB0 formulas or single-Σ11 formulas. As a result,
every sequent in  has the form (81):
∃X1 1 (X1 ), . . . , ∃Xm m (Xm ), Γ −→ Δ, ∃Y1

1 (Y1 ), . . . , ∃Yn

n (Yn )

(110)
for m, n ≥ 0, where i and j and all formulas in Γ and Δ are ΣB0 .
We will prove by induction on the depth in  of a sequent S of the form
(110) that there is a ﬁnite collection of polytime functions
L = {F1 , . . . , Fn , . . . }
so that V 1 (L) proves the (semantic equivalent of the) sequent
S  =def 1 ( 1 ), . . . , m ( m ), Γ −→ Δ,

1 (F1 ), . . . ,

n (Fn )

(111)

i.e., there is an LK 2 -V 1 (L) proof of S  . Here Fi stands for Fi (a, α, ), and
a, α is a list of exactly those variables with free occurrences in S. (This list
may be diﬀerent for diﬀerent sequents.) Also 1 , . . . , m are distinct new
free variables corresponding to the bound variables X1 , . . . , Xm , although
the latter variables may not be distinct.
We proceed as in the proof of the Witnessing Theorem for V 0 in Sec 1 (i.e.,
tion V.5.2 by considering the cases where S is an axiom of LK 2 -V
2 1
0
an axiom of V ), or S is generated using inference rules of LK -V . The
case of the non-logical axioms or the introduction rules for ¬, ∧, ∨ and
bounded number quantiﬁers are dealt with just as in Cases I–VIII in the
proof for V 0 . Here we will consider the only new case, i.e., the case of
the ΣB1 -IND rule. This is the one that causes the introduction of non-AC 0
witnessing functions.

VI.4. The Witnessing Theorem for V 1

155

Case IX. S is obtained by an application of the ΣB1 -IND rule. Then S
is the bottom sequent of
S1
S

=

Λ, ∃X ≤ r(b) (b, X ) −→ ∃X ≤ r(b + 1) (b + 1, X ), Π
Λ, ∃X ≤ r(0) (0, X ) −→ ∃X ≤ r(t) (t, X ), Π

where b does not occur in S, and is ΣB0 .
By the induction hypothesis for the top sequent S1 , there is a ﬁnite
collection L of polytime functions, and a polytime function G(b, ) ∈ L
(suppressing arguments for the other variables present) such that V 1 (L)
proves the sequent S1 , which is
Λ , | | ≤ r(b) ∧ (b, ) −→ |G(b, )| ≤ r(b + 1) ∧
(b + 1, G(b, )), Π . (112)
Note that by the variable restriction, b and do not occur in Λ , and can
only occur in Π as arguments to witnessing functions Fi (b, ).
We deﬁne the witness function Ĝ (t, ) for the formula ∃X ≤ r(t) (t, X )
in the succedent of S by limited recursion (Deﬁnition VI.2.11) as follows:
Ĝ(0, ) = ,

(113)
<r(z+1)

Ĝ (z + 1, ) = (G(z, Ĝ (z, )))

.

(114)

Since G is a polytime function, by Cobham’s Theorem VI.2.12, Ĝ is also
a polytime function.
Let F11 (b, ), . . . , Fm1 (b, ) ∈ L be the witnessing functions in Π . Consider the sequent
Λ , |Ĝ (b, )| ≤ r(b) ∧ (b, Ĝ(b, )) −→
|Ĝ (b + 1, )| ≤ r(b + 1) ∧ (b + 1, Ĝ(b + 1, )), Π

(115)

which is obtained from (112) by substituting Ĝ(b, ) for , and writing
Ĝ(b + 1, ) for G(b, Ĝ(b, )) (using (114)). In particular, Π is obtained
from Π by replacing each witnessing function Fi1 (b, ) for S1 by Fi2 (b, ),
where
Fi2 (b, ) = Fi1 (b, Ĝ(b, ))

(1 ≤ i ≤ m).

Let L = L ∪ {Ĝ, F12 , . . . , Fm2 }. Then since (112) is a theorem of LK 2 V 1 (L), (115) is a theorem of LK 2 -V 1 (L ). Note that (115) is of the form
Λ , (b, ) −→ (b + 1, ), Π
where
(b, ) ≡ |Ĝ(b, )| ≤ r(b) ∧ (b, Ĝ(b, )).
Here  is a ΣB0 (L ) formula.

(116)

VI. The Theory V 1 and Polynomial Time

156

Notice that in Π , b occurs (only) as an argument to Fi2 . So we cannot
apply the IND rule to (116). Moreover, b should not occur in our desired
sequent S  . We remove b from Π by introducing the number function h:
h( ) = min y < t ¬(y + 1, )
i.e., h has the ΣB0 (L )-deﬁning axiom
h( ) = y ↔ y ≤ t ∧ (y = t ∨ ¬(y + 1, )) ∧ ∀z < y(z + 1, ).
(117)
Then h is a polytime function, and can be deﬁned from (b, ) using
limited recursion. Deﬁne for each i, 1 ≤ i ≤ m,
Fi ( ) = Fi2 (h( ), ).
Then Fi is a polytime function. Let Π be Π with each witnessing
function Fi2 (b, ) replaced by Fi ( ). Also deﬁne (by composition):
G ∗ ( ) = Ĝ(t, ).
Now deﬁne S  to be the sequent:
S  = Λ , | | ≤ r(0) ∧ (0, ) −→ |G ∗ ( )| ≤ r(t) ∧ (t, G ∗ ( )), Π .
(118)
Then S  is of the form (111). It remains to show that S  is provable in
LK 2 -V 1 (L ), where L is L together with the new functions in S  , i.e.,
L = L ∪ {h, F1 , . . . , Fm , G ∗ }.
First, by (113) the sequent (118) is equivalent to
Λ , (0, ) −→ (t, ), Π .

(119)

Then by replacing b in (116) with h( ), LK 2 -V 1 (L ) proves
Λ , (h( ), ) −→ (h( ) + 1, ), Π .

(120)

Next, by the deﬁnition of h (117), LK 2 -V 1 (L ) proves the sequents
(0, ) −→ (h( ), )

(h( ) + 1, ) −→ (t, ).

and

From this and (120), it follows that LK -V 1 (L ) proves (119), and hence
(118).
2
2

VI.5. Notes
Our theory V 1 is essentially Zambella’s Theory Σp1 -comp in [112], and
is a variation of the theory V11 in [72], which in turn is deﬁned in the style
of Buss’s second-order theories [20]. It is a two-sorted version of Buss’s
S21 . Our ΣB1 formulas correspond to strict Σb1 formulas, but this does not
really matter, as shown in Section VI.3.
The Σ11 Deﬁnability Theorem for V 1 is essentially due to Buss [20] who
proved it for his ﬁrst-order theory S21 . Exercise VI.4.4 (V 1 proves the

VI.5. Notes

157

prime factorization theorem) is due to Jeřábek [60]. The interesting part
 1 proves the ΣB -COMP axioms, is essentially
of Theorem VI.4.8, that V
1
Theorem 1 in [23].

Chapter VII

PROPOSITIONAL TRANSLATIONS

In Section II.1 we presented Gentzen’s Propositional Calculus PK and
showed that PK is sound and complete; i.e. a propositional formula is
valid iﬀ it is provable in PK. In this chapter we introduce the general
notion of propositional proof system (or simply proof system) and study its
complexity. We are particularly interested in which families of tautologies
have polynomial length proofs. In the (apparently unlikely) event that
there is a polynomial p(n) such that for every n, every tautology of length n
has a proof in the system of length at most p(n), then we say that the system
is polynomially bounded. The question of existence (or nonexistence)
of a polynomially bounded proof system is equivalent to the important
complexity theory question of whether NP = co-NP.
Here our main interest is the relationship between bounded arithmetic
and propositional proof systems. There is an extensive literature on the
complexity of proof systems (see for example [72] and [13]) which we will
barely touch.
One of our goals is to associate a proof system with each of our theories,
such as V 0, V 1 , . . . . In this chapter we associate the proof system constantdepth Frege (AC 0 -Frege) with V 0 and the system extended Frege (eFrege)
with V 1 . Each ΣB0 theorem in the theory can be translated into a family of
tautologies which have polynomial size proofs in the corresponding proof
system (the propositional translation), showing that the proof system is
suﬃciently powerful. On the other hand, in Chapter X we show that
the soundness of a proof system is provable in the associated theory (the
Reﬂection Principle), showing that the proof system is not too powerful.
In order to associate proof systems with other theories, and in order to
translate ΣB1 , ΣB2 , . . . theorems of our theories (and not just ΣB0 theorems),
we need to generalize the propositional calculus to the quantiﬁed propositional calculus (QPC). This we do in Section VII.3, and introduce the
QPC proof system G and its subsystems G0 , G1 , . . . and G0 , G1 , . . . . We
show that for i ≥ 1 each bounded theorem of V i can be translated into a
family of valid QPC formulas with polynomial size Gi proofs. In Chapter VIII we introduce the hierarchy of theories TV i and in Chapter X we
show a similar relation between TV i and Gi . This and other results justify
159

160

VII. Propositional Translations

saying that Gi is a kind of nonuniform version of V i when considering
ΣBi -theorems, but not for theorems in general. Similarly for Gi and TV i .

VII.1. Propositional Proof Systems
Recall (Section II.1) that a propositional formula is built from the logical constants ⊥,  (for False, True), the propositional variables (or atoms)
p1 , p2 , . . . , connectives ¬, ∨, ∧ and parentheses (, ). Also, a tautology is
a valid propositional formula (Deﬁnition II.1.1). We assume that tautologies are coded as binary strings (or more properly ﬁnite subsets of N)
using some eﬃcient encoding.
Deﬁnition VII.1.1. TAUT is the set of (strings coding) propositional
tautologies.
A propositional proof system is a formal system for proving tautologies.
An example is the system PK introduced in Section II.1, where a formal
proof of a formula A is a tree of sequents, where the root is −→ A, the
leaves are axioms, and the sequent at each internal node follows from its
parent sequent(s) by a rule of inference. The soundness and completeness
theorems state that TAUT is exactly the set of formulas with formal PK
proofs. Below we give a very general deﬁnition of proof system, and then
explain how to make PK ﬁt this deﬁnition.
Deﬁnition VII.1.2 (Propositional Proof System).
A propositional
proof system (or simply a proof system) is a polytime, surjective (onto)
function
F : {0, 1}∗ −→ TAUT.
If F (X ) = A, then we say that X is a proof of A in the system F .
The length of A is denoted |A|, and the length (or size) of the proof X
is denoted |X |. A proof system F is said to be polynomially bounded if
there is a polynomial p(n) such that for all tautologies A, there is a proof
X of A in F such that |X | ≤ p(|A|).
Informally, a proof system F is polynomially bounded if every tautology
has a short proof in F .
Example VII.1.3. PK can be treated as a proof system in the sense of
Deﬁnition VII.1.2, because the function

A
if X codes a PK proof of −→ A,
PK(X ) =
 (True) otherwise
is a polytime function.
It is not known whether PK is polynomially bounded. In fact, the
existence of a polynomially bounded proof system is equivalent to the
assertion that NP = co-NP.

VII.1. Propositional Proof Systems

161

Theorem VII.1.4. There exists a polynomially bounded proof system iﬀ
NP = co-NP.
Proof. Since TAUT is co-NP-complete, we have NP = co-NP iﬀ
TAUT ∈ NP.
(=⇒) Suppose that F is a polynomially bounded proof system. Then
by deﬁnition, there is a polynomial p(n) such that
A ∈ TAUT ⇔ ∃X ≤ p(|A|)F (X ) = A.
This shows that TAUT ∈ NP: The witness for the membership of A in
TAUT is the proof X .
(⇐=) If TAUT ∈ NP, then there is a polytime relation R(Y, A), and a
polynomial p(n) such that
A ∈ TAUT ⇔ ∃Y ≤ p(|A|)R(Y, A).
Deﬁne the proof system F by

A if X codes a pair Y, A, and R(Y, A),
F (X ) =
 otherwise.
Clearly F is a polynomially bounded proof system.
2
The general feeling among complexity theorists is that NP = co-NP, so
the above theorem suggests that no proof system is polynomially bounded.
In fact some weak proof systems, including resolution and bounded depth
Frege systems (which is introduced below) have been proved to be not
polynomially bounded. However it seems to be very diﬃcult to prove this
for the system PK. The system PK is p-equivalent (deﬁned below) to a
large class of proof systems, called Frege systems, which includes many
standard proof systems described in logic text books. This adds interest
to the problem of showing that PK is not polynomially bounded.
Also because PK is p-equivalent to the Frege proof systems, we will
continue to work with PK, and will not deﬁne the Frege proof systems.
Below we introduce bPK (bounded depth PK) and ePK (extended PK).
They belong respectively to the families call bounded depth Frege and
extended Frege.
Deﬁnition VII.1.5. A proof system F1 is said to p-simulate a proof
system F2 if there is a polytime function G such that F2 (X ) = F1 (G(X )),
for all X . Two proof systems F1 and F2 are said to be p-equivalent if F1
p-simulates F2 , and vice versa.
Thus F1 p-simulates F2 if any given F2 -proof X of a tautology A can be
transformed (by a polytime function G) into an F1 -proof G(X ) of A.
Exercise VII.1.6. (a) Show that the relation on proof systems “F1
p-simulates F2 ” is transitive and reﬂexive.
(b) Show that if F1 p-simulates F2 , and F2 is polynomially bounded,
then F1 is also polynomially bounded.

162

VII. Propositional Translations

VII.1.1. Treelike vs Daglike Proof Systems. Proofs in the system PK
are trees. This tree structure is potentially ineﬃcient, since each sequent in
the proof can be used only once as a hypothesis for a rule, and if it needs to
be used again in another part of the proof, then it must be rederived. This
motivates allowing the proof structure to be a dag (directed acyclic graph),
since this allows each sequent to be used repeatedly to derive others.
Deﬁnition VII.1.7 (Treelike vs Daglike). A proof system is treelike if
the structure of each proof is required to be a tree. The system is daglike
if a proof is allowed to have the more general structure of a dag.
In general a proof, whether treelike or daglike, can be represented as
a sequence of “lines”, where each line is the contents of some node in
the proof. Each line is either an axiom or it follows from an earlier line
or earlier lines in the proof (its parent or parents), and the line might be
annotated to indicate this information. The proof is a tree if each sequent
is a parent of at most one line.
The notions treelike and daglike can be used as adjectives to indicate
diﬀerent version of a proof system. For example, treelike PK is the same
as PK, but daglike PK has the same axioms and rules as PK, but allows
a proof to take the form of a dag.
The next result shows that for PK the distinction is not important. (But
it is important for the system G1 deﬁned later in this chapter.)
Theorem VII.1.8 (Krajı́ček[68]). Treelike PK p-simulates daglike PK.
Proof. Recall that to each sequent S = A1 , . . . , Ak −→ B1 , . . . , B we
associate the formula AS which gives the meaning of S:
AS ≡ ¬A1 ∨ · · · ∨ ¬Ak ∨ B1 ∨ · · · ∨ B .

(121)

Here it is not important how we parenthesize AS (see Lemma VII.1.15).
Also, there is a treelike PK derivation, whose size is bounded by a polynomial in the size of S, of S from the sequent −→ AS .
Suppose that  = S1 , . . . , Sn is a daglike PK proof. We show:
Claim. The sequence
−→ AS1 ; −→ (AS1 ∧ AS2 ); . . . ; −→ (AS1 ∧ · · · ∧ ASn ); −→ ASn
can be augmented to a treelike PK proof whose size is bounded by a
polynomial in the length of .
Again it is not important how the conjunctions AS1 ∧ · · · ∧ ASk are
parenthesized. The claim follows easily from the exercise below.
2
Exercise VII.1.9. (a) Show that the following sequents have polynomial size cut-free treelike PK proofs:
(i) −→ AS , where S is any axiom of PK.
(ii) A ∧ B −→ B, for any PK formulas A, B.
(iii) A ∧ B −→ A ∧ B ∧ B, for any PK formulas A, B.

VII.1. Propositional Proof Systems

163

(b) Suppose that S is derived from S1 (and S2 ) by an inference rule of
PK. Show that the following sequents have polynomial size cut-free
treelike PK proofs, for any formula A:
(i) A ∧ AS1 −→ A ∧ AS .
(ii) A ∧ AS1 ∧ AS2 −→ A ∧ AS .
The next result will be useful later in the chapter.
Lemma VII.1.10 (PK  -Replacement). Let A(p) and B be propositional
formulas, and let A(B) be the result of substituting B for p in A(p). Then
for all propositional formulas B1 , B2 , the sequent
(B1 ↔ B2 ) −→ (A(B1 ) ↔ A(B2 ))
has a cut-free treelike PK proof of size bounded by a polynomial in its
endsequent.
Exercise VII.1.11. Prove the lemma by giving (using structural induction on A(p)) cut-free treelike PK proofs of size polynomial in the size of
the endsequents for the following sequents:
A(B1 ), B1 ↔ B2 −→ A(B2 ),

A(B2 ), B1 ↔ B2 −→ A(B1 ).

VII.1.2. The Pigeonhole Principle and Bounded Depth PK. To show
that a proof system F is not polynomially bounded, it suﬃces to exhibit
a family of tautologies that requires F -proofs of super-polynomial size.
Similarly, to show that a proof system F2 does not p-simulate a proof
system F1 , it suﬃces to show the existence of a family of tautologies
that has polynomial size F1 -proofs, but requires super-polynomial size
F2 -proofs.
There is an important family of tautologies that formalizes the Pigeonhole Principle, which states that if n + 1 pigeons are placed in n holes, then
two pigeons will wind up in the same hole. The principle is formulated
using the atoms
pi,j

(for 0 ≤ i ≤ n, 0 ≤ j < n)

where pi,j is intended to mean that pigeon i gets placed in hole j. First,
the negation of the principle is expressed as an unsatisﬁable propositional
formula ¬PHPn+1
n , which is the conjunction of the following clauses:
(pi,0 ∨ · · · ∨ pi,n−1 ),
(¬pi,j ∨ ¬pk,j ),

0 ≤ i ≤ n,

(122)

0 ≤ i < k ≤ n, 0 ≤ j < n.

(123)

Here, (122) says that the pigeon i is placed in some hole, and (123) says
that two pigeons i and k are not placed in the same hole.
The Pigeonhole Principle itself is equivalent to the negation of
¬PHP n+1
n , which by applying De Morgan’s laws, can be expressed as
follows.

164

VII. Propositional Translations

n+1
is
Deﬁnition VII.1.12 (PHPn+1
n ). The propositional formula PHP n
deﬁned to be




pi,j ⊃
(pi,j ∧ pk,j ).
(124)
0≤i≤n 0≤j<n

0≤i<k≤n,0≤j<n

: n ≥ 1}.
Deﬁne PHP = {PHPn+1
n
Thus for each n ≥ 1, PHPn+1
is a tautology.
n
In 1985 Armen Haken proved an exponential lower bound on the length
of any Resolution refutation of ¬PHPn+1
n , one of the early important
results in propositional proof complexity. On the other hand, in 1987
Buss presented polynomial size Frege proofs of PHPn+1
n . (Buss’s proofs
are based on the fact that there are propositional formulas Ak (p1 , . . . , pn )
of size polynomial in n which express the condition that at least k of
p1 , . . . , pn are true.) It follows that Resolution does not p-simulate Frege.
(While it is easy to show that Frege p-simulates Resolution.)
In fact the family PHP does not have polynomial size proofs in a
stronger proof system called bounded depth Frege (also known as AC 0 Frege). We will deﬁne bPK, a representative from these systems. First, we
formally deﬁne the depth of a formula. Here we think of the connectives
∧, ∨ as having arbitrary fan-in.
Deﬁnition VII.1.13 (Depth of a Formula). The depth of a formula A
is the maximal number of times the connective changes in any path in the
tree form of A.
So in particular, the formula (p1 ∨ · · · ∨ pn ) has depth 1, for any n, no
matter how the parentheses are inserted. The depth of each clause (122)
is 2, and the depth of the conjunction ¬PHP n+1
is 3.
n
Deﬁnition VII.1.14 (Bounded Depth PK). For each constant d ∈ N
we deﬁne a d -PK proof to be a PK proof in which the cut formulas have
depth at most d . We deﬁne a bounded depth PK system (or just bPK) to
be any system d -PK for d ∈ N.
Sometimes the deﬁnition for a d -PK proof is taken to be that all formulas in the proof have depth ≤ d . Our deﬁnition given above is more
general: For proving a formula of depth ≤ d , the two deﬁnitions are the
same, but here we allow d -PK proofs of any formula (not just formulas
of depth ≤ d ). Indeed, since any tautology has a PK proof without using
the cut rule (the PK Completeness Theorem II.1.8), it follows that d -PK
is complete, for any d ≥ 0.
In general, we are not interested in the exact length of bounded depth
PK proofs, but only interested in the length up to the application of a
polynomial. Because of this and the next lemma, we will ignore how
parentheses are placed in a disjunction (A1 ∨ · · · ∨ An ).

VII.2. Translating V 0 to bPK

165

Lemma VII.1.15. If A is some parenthesization of (B1 ∨ · · · ∨ Bn ), and A
is another such parenthesization, then there is a cut-free treelike PK proof
of the sequent A −→ A consisting of O(n 2 ) sequents, where each sequent
has length at most that of the sequent A −→ A .
For example, we may have
A ≡ (B1 ∨ (B2 ∨ (B3 ∨ B4 ))).

A ≡ (B1 ∨ (B2 ∨ B3 )) ∨ B4 ),

Proof. By repeated use of the rule ∨-left, it is easy to see that there is
such a d -PK proof of the sequent
A −→ B1 , . . . , Bn .
Now repeated use of ∨-right (with exchanges) gives the desired d -PK
proof.
2
does not have polynomial size
In 1988 Ajtai proved that PHP n+1
n
bounded depth Frege proofs. (In fact he proved the result for a weaker
version of PHP which asserts that there is no bijection mapping (n + 1)
pigeons to n holes, see Section IX.4.3.) This was strengthened by two
groups a few years later to prove the following exponential lower bound,
which remains one of the strongest lower bound results in propositional
proof complexity.
Theorem VII.1.16 (Bounded Depth Lower Bound [11]). For every d ∈
N, every d -PK proof of PHP n+1
must have size at least
n
2n

d

where  = 1/6.
In view of Buss’s upper bound for PHP n+1
n , we have
Corollary VII.1.17. No bounded depth Frege system p-simulates any
Frege system.
The lower bound results in propositional proof complexity can be used
to obtain independence results in the theories of bounded arithmetic. We
will explain this in the next sections.

VII.2. Translating V 0 to bPK
In this section we give evidence that the propositional proof system bPK
is a kind of nonuniform version of the ΣB0 -fragment of V 0 (in Chapter X
we give more evidence). Intuitively a V 0 proof of a ΣB0 formula is able to
use concepts from the complexity class AC 0 . Recall from Subsection IV.1
that a language in nonuniform AC 0 is speciﬁed by polynomial size family
of bounded depth formulas. Thus the lines in a polynomial size family of
bPK proofs express nonuniform AC 0 concepts.

166

VII. Propositional Translations

VII.2.1. Translating ΣB0 Formulas. We begin by showing how to translate each ΣB0 formula ϕ(x, X ) into a polynomial size bounded depth family
#ϕ(x, X )# = {ϕ(x, X )[m; n] : m, n ∈ N}
of propositional calculus formulas, and then we show how to translate a
V 0 proof of a ΣB0 formula into a polynomial size family of bPK proofs.
Later we will show how to translate in general a bounded two-sorted
formula into a polynomial size family of quantiﬁed propositional calculus.
Here, the depth of each formula in the family #ϕ(x, X )# is bounded by a
constant which depends only on ϕ.
We ﬁrst explain the translation for a ΣB0 formula ϕ(X ) which has a single
free (string) variable X . We introduce propositional variables p0X , p1X , . . . ,
where piX is intended to mean X (i). The translation has the property that
for each n ∈ N, ϕ(X )[n] is valid iﬀ the formula ∀X (|X | = n ⊃ ϕ(X )) is
true in the standard model, where n is the n-th numeral. More generally,
there is a one-one correspondence between truth assignments satisfying
ϕ(X )[n] and strings X that satisﬁes ϕ(X ) and |X | = n.
Notation. We use val(t) for the numerical value of a term t, where t
may have numerical constants substituted for variables.
We deﬁne ϕ(X )[n] inductively as follows. For the base case, ϕ(X ) is an
atomic formula. Consider the following possibilities.
• If ϕ(X ) is X = X , then ϕ(X )[n] =def .
• If ϕ(X ) is  or ⊥, then ϕ(X )[n] =def ϕ(X ).
• If ϕ(X ) is t(|X |) = u(|X |), then

 if val(t(n)) = val(u(n)),
ϕ(X )[n] =def
⊥ otherwise.
• Similarly if ϕ(X ) is t(|X |) ≤ (|X |).
• If ϕ(X ) is X (t(|X |)), then we set j = val(t(n)). Let
ϕ(X )[0] =def ⊥
and for n ≥ 1:

⎧
X
⎪
⎨pj
ϕ(X )[n] =def 
⎪
⎩
⊥

if j < n − 1,
if j = n − 1,
if j > n − 1.

For the induction step, ϕ(X ) is built from smaller formulas using a
propositional connective ∧, ∨, ¬, or a bounded number quantiﬁer. For
∧, ∨, ¬ we make the obvious deﬁnitions: If both (X )[n] and (X )[n] are

VII.2. Translating V 0 to bPK

167

not the logical constants ⊥ or , then


(X ) ∧ (X ) [n] =def ( (X )[n] ∧ (X )[n]),


(X ) ∨ (X ) [n] =def ( (X )[n] ∨ (X )[n]),


¬ (X ) [n] =def ¬ (X )[n].
Otherwise, if either (X )[n] or (X )[n] is a logical constant ⊥ or , then
we simplify the above deﬁnitions in the obvious way. For example,
⎧
⎪
⎨(X )[n] if (X )[n] is ,


(X ) ∧ (X ) [n] =def
(X )[n] if (X )[n] is ,
⎪
⎩
⊥
if either (X )[n] or (X )[n] is ⊥ .
For the case of bounded number quantiﬁers, ϕ(X ) is ∃y ≤ t(|X |)
X ) or ∀y ≤ t(|X |) (y, X ). We deﬁne


m


(y, X ) [n] =def
(i , X )[n],



m

(y, X ) [n] =def

∃y ≤ t(|X |)

(y,

i=0

∀y ≤ t(|X |)

(i , X )[n]

i=0

where m = val(t(n)), and recall that i is the i-th numeral. Also, if any
of the (i , X )[n] is translated into  or ⊥, we simplify ϕ(X )[n] just as
above.
Recall that s < t stands for s ≤ t ∧ s = t. For val(t(n)) ≥ 1 we have


∃y < t(|X |)

m−1


(y, X ) [n] ↔
(i , X )[n],

∀y < t(|X |)


(y, X ) [n] ↔

i=0



m−1

(i , X )[n].
i=0

In addition,
(∃y < 0

(y, X ))[n] ↔ ⊥,

(∀y < 0

(y, X ))[n] ↔ .

Recall that x, y is the pairing function, and we write X (x, y) for
X (x, y). We formulate the Pigeonhole Principle using a ΣB0 (L2A ) formula
PHP(y, X ) below. Here y stands for the number of holes, and X is
intended to be a 2-dimensional Boolean array, with X (i, j) holds iﬀ pigeon
i gets placed in hole j (for 0 ≤ i ≤ y, 0 ≤ j < y).
Example VII.2.1 (Formulation of PHP in Two-Sorted Logic).
PHP(y, X ) ≡ ∀i ≤ y∃j < yX (i, j) ⊃
∃i ≤ y∃k ≤ y∃j < y(i < k ∧ X (i, j) ∧ X (k, j)).

(125)

168

VII. Propositional Translations

Then for all 1 ≤ n ∈ N, PHP(n, X )[1 + n, n − 1] is just PHP n+1
n
(Deﬁnition VII.1.12).
In general, we can deﬁne the translation of a ΣB0 (L2A ) formula ϕ(x, X )
(i.e., with multiple free variables of both sorts). Then for each string
variable Xk we associate a list of propositional variables p0Xk , p1Xk , . . . , and
we give each free number variable a numerical value. Thus the family
ϕ(x, X )[m; n] is deﬁned so that it is valid iﬀ the formula
∀x∀X , (

|Xk | = nk ) ⊃ ϕ(m, X )

is true in the standard model N2 . Here for the base case we have to handle
an additional case, i.e., where ϕ(x, X ) ≡ Xi = Xk , where i = k. We
reduce this case to other cases by considering ϕ to be its equivalence given
by the LHS of the axiom SE (Figure 2):
|Xi | = |Xk | ∧ ∀x < |Xi |(Xi (x) ↔ Xk (x)).
Lemma VII.2.2. For every ΣB0 (L2A ) formula ϕ(x, X ), there is a constant
d ∈ N and a polynomial p(m, n) such that for all m, n ∈ N, the propositional
formula ϕ(x, X )[m; n] has depth at most d and size at most p(m, n).
Proof. The proof is by structural induction on ϕ, and is straightforward.
2
Now we come to the main result of this section:
Theorem VII.2.3 (V 0 Translation). Suppose that ϕ(x, X ) is a ΣB0 formula such that V 0  ∀x∀X ϕ(x, X ). Then the propositional family
#ϕ(x, X )# has polynomial size bounded depth PK proofs. That is, there
are a constant d and a polynomial p(m, n) such that for all 1 ≤ m, n ∈ N,
ϕ(x, X )[m; n] has a d -PK proof of size at most p(m, n). Further there is
an algorithm which ﬁnds a d -PK proof of ϕ(x, X )[m; n] in time bounded by
a polynomial in (m, n).
(See Theorem VII.5.6 for a generalization of this result which applies
to all bounded theorems of V 0 .)
In view of the Bounded Depth Lower Bound Theorem VII.1.16 above,
we have:
Corollary VII.2.4 (Independence of PHP from V 0 ). The true ∀ΣB0
sentence
∀y∀X PHP(y, X )
(see Example VII.2.1) is not a theorem of V 0 .
To prove the V 0 Translation Theorem, the idea is to translate each
sequent in an LK 2 proof of ϕ(a, α) into a bPK sequent which has a short
proof. The issue here is that an LK 2 -V 0 proof may contain ΣB1 formulas
(i.e., the ΣB0 -COMP axioms), whose translation we have not discussed.
 0 which plays the same role for V 0 as V
 1 does
We introduce the theory V
1
0
 and the associated sequent
for V . In the next subsection we deﬁne V

VII.2. Translating V 0 to bPK

169

 0 (an analogue of LK 2 -V
 1 ), and use these to prove the V 0
system LK 2 -V
Translation Theorem.
 0 and LK 2 -V
 0.
VII.2.2. V
 0 has vocabulary L2 and is axiomaDeﬁnition VII.2.5. The theory V
A
tized by 2-BASIC and the ΣB0 -IND axiom scheme.
 0 is the same as V 0 , except the ΣB -COMP axioms are replaced
Thus V
0
B
by the Σ0 -IND axioms. By Corollary V.1.8, V 0 proves the ΣB0 -IND axiom
 0 ⊆ V 0.
scheme, hence V

 0 , because
Unlike the V 1 , V 1 case, unfortunately V 0 is not the same as V
0
B
 does not prove the Σ -COMP axioms. To see this, expand the standard
V
0
(single-sorted) model N to a L2A structure M by letting the string universe
 0,
be {∅}, where |∅| = 0. Then it is easy to see that M is a model of V
0
but not of V . Nevertheless, we can prove a weaker statement.
Deﬁnition VII.2.6 (Φ-Conservative Extension). Let Φ be a set of formulas in the vocabulary L. Suppose that T is a theory over L, and T  is an
extension of T (the vocabulary of T  may contain function or predicate
symbols not in L). Then we say that T  is a Φ-conservative extension of T
if for every formula ϕ ∈ Φ, if T   ϕ then T  ϕ.
So if Φ is the set of all L formulas, then T  is Φ-conservative over T
 0 and V 0 , we
precisely when it is conservative over T . For the case of V
B
can take Φ to be Σ0 .
 0.
Lemma VII.2.7. V 0 is ΣB -conservative over of V
0

By our deﬁnition of semantics (Sections IV.2.2 and II.2.2), this is the
 0 , where ∀ΣB is the
same as saying that V 0 is ∀ΣB0 -conservative over V
0
universal closure of ΣB0 (Deﬁnition II.2.22).
 0 ⊆ V 0 (by Corollary V.1.8). The proof
Proof. We noted earlier that V
B
0
 0 is like the proof that V 0
that every Σ0 theorem of V is also provable in V
is conservative over IΔ0 (Theorem V.1.9). We use the following lemma,
which is proved in the same way as Lemma V.1.10 (any model of IΔ0 can
be expanded to a model of V 0 ). In the present case, U2 is deﬁned as before
in (53), except that now the formula ϕ is allowed parameters from U2 .
 0 can be extended to
Lemma VII.2.8. Every model M = U1 , U2  for V



0

a model M = U1 , U2  of V , where U1 = U1 and U2 ⊆ U2 .
It follows that if ϕ(x, X ) is a ΣB0 formula with all free variables indicated,
and a are any elements in U1 and α are any elements in U2 , then
M |= ϕ(a, α)

iﬀ

M |= ϕ(a, α).

 0 for a set
(The proof actually shows that V 0 is Φ-conservative over V
B
Φ larger than Σ0 , i.e., Φ contains formulas with unbounded number

170

VII. Propositional Translations

quantiﬁers and without string quantiﬁers. But we do not need this fact
here.)
2
2 0
2 1
The sequent system LK -V is analogous to LK -V :
 0 ). The rules of LK 2 -V
 0 consist of the rules
Deﬁnition VII.2.9 (LK 2 -V
2
B
of LK (Section IV.4), together with the Σ0 -IND rule (Deﬁnition VI.4.11).
 0 are sequents of the form −→ A, where
The non-logical axioms of LK 2 -V
A is any term substitution instance of a 2-BASIC axiom (Figure 2) or an
LK 2 equality axiom (Deﬁnition IV.4.1).
 0 proof from Deﬁnition VI.4.13,
Recall the notion of an anchored LK 2 -V
and the Anchored Completeness Lemma for LK 2 +IND VI.4.15. We are
now ready to prove the V 0 Translation Theorem.
VII.2.3. Proof of the Translation Theorem for V 0 . By assumption,
ϕ(a, α) is a ΣB0 theorem of V 0 . By the Anchored Completeness Lemma
 0 proof  of ϕ(a, α).
for LK 2 +IND VI.4.15, there is an anchored LK 2 -V
We may assume that  is in free variable normal form, where (as in Subsection VI.4.2) we modify Deﬁnition II.2.20 to allow the rule ΣB0 -IND to
eliminate a variable. By the Subformula Property of LK 2 +IND (Proposition VI.4.18), every formula in every sequent of  is ΣB0 . So every sequent
S in  has the form
1 (b,

), . . . ,

k (b,

) −→ 1 (b, ), . . . ,  (b, )

where i , j are ΣB0 formulas, and (b, ) are all the free variables in S
(which may be diﬀerent for diﬀerent sequents). The translation S[m; n]
is obtained from the translations i (b, )[m; n] and j (b, )[m; n] as follows. First, if any i (b, )[m; n] is ⊥, or any j (b, )[m; n] is , then
S[m; n] is the axiom
−→ .

(126)

Otherwise, S[m; n] has the form
S[m; n] =def . . . ,

i (b,

)[m; n], . . . −→ . . . , j (b, )[m; n], . . .

where the antecedent consists of all i (b, )[m; n] that are not , and the
succedent consists of all j (b, )[m; n] that are not ⊥.
We will prove by induction on the number of lines above this sequent
in  that there are a constant d and a polynomial p depending on , such
that the propositional sequent S[m; n] has a d -PK proof of size at most
p(m, n), for all m, n ∈ N. It is straightforward to verify that the proof can
be obtained in time polynomial in m, n.
 0 . Thus S is of
For the base case, S is a non-logical axiom of LK 2 -V
the form −→ , where  is a term substitution instance of the 2-BASIC
axioms, or S is an instance of the Equality axioms (Deﬁnition IV.4.1).
First, any string variable X can occur in an instance of B1–B12 only in the

VII.2. Translating V 0 to bPK

171

context of a number term |X |. Since these axioms are true in the standard
model N2 , they translate into the propositional constant . Therefore if
 is an instance of B1–B12, then −→  translates into the axiom (126) of
PK.
Instances of L1 and L2 translate into (126). Consider, for example, an
instance of L1:
(b, , ) ≡ (t) ⊃ t < ||
where b, denote all (free) variables occurring in the L2A -number term
t = t(b, ||, | |). By deﬁnition, in order to get (b, , )[m; n, n], ﬁrst we
obtain the formulas
⎧ 
⎪
⎨pi ⊃  if i < n − 1,
 ⊃  if i = n − 1,
⎪
⎩
⊥ ⊃ ⊥ if i > n − 1
where i = val(t(m, n, n)). Simplifying these formulas results in
(b, , )[m; n, n] =def .
By deﬁnition, any instance of the axiom SE translates into a formula
of the form A ⊃ A, where A is the translation of the LHS of SE. This
tautology has a short cut-free derivation PK.
Similar (and simple) arguments show that if S is an instance of any of
the Equality Axioms, then its S[m; n, n] has a short d -PK proof, for some
small constant d . (This constant accounts for the fact that we translate
X = Y using the LHS of SE, which translates into a propositional formula
of depth 3.)
 0 . Since all
For the induction step, we consider the rules of LK 2 -V
B
formulas in  are Σ0 , the string quantiﬁer rules are never applied. If
S is obtained from S1 (and S2 ) by one of the introduction rules for the
connectives ∧, ∨ and ¬ and the translation(s) of the auxiliary formula(s)
are not simpliﬁed to Boolean constants then we can apply the same rules
to get the PK proof of S[m; n] from the PK proof(s) of S1 [m; n] (and
S2 [m; n]). Otherwise, if an auxiliary formula is translated into  or ⊥
then it can be seen that S[m; n] is the same as S1 [m; n] (or S2 [m; n]). No
new cut is needed for this step.
For the case of the cut rule, the cut formula (b, ) is ΣB0 , and since  is in
free variable normal form, no variable is eliminated by the rule. Consider
the interesting case where the translation of (b, ) is not a constant 
or ⊥. The corresponding PK proof also uses the cut rule, where the cut
formula is a propositional translation (b, )[m; n] of this formula, which
according Lemma VII.2.2 has bounded depth d independent of m, n.

172

VII. Propositional Translations

Consider the case of the number ∀-right. Suppose that the inference is
S1

=

Λ −→ Π, c ≤ t(b, | |) ⊃ (b, c, )

S
Λ −→ Π, ∀x ≤ t(b, | |) (b, x, )
where c does not occur in S. By the induction hypothesis, there are a constant d ∈ N and a polynomial p(m, i, n) so that for each m, i, n, there is a
d -PK proof [m, i; n] of size ≤ p(m, i, n) of the sequent S1 [m, i; n]. Note
that if for some i ≤ r, (b, c, )[m, i; n] is ⊥ then ∀x ≤ t(b, | |) (b, x, )
translates into ⊥ and hence S[m; n] = S1 [m, i; n] and we are done. Moreover, if all (b, c, )[m, i; n] (for i ≤ r) are  then S[m; n] is the axiom
−→  and we are also done.
Now, if some (b, c, )[m, i; n] is  then it will be deleted from the
translation of ∀x ≤ t(b, | |) (b, x, ), and the sequent S1 [m, i; n] is the
axiom −→  and it will not be used in the following derivation. So
suppose that for all i ≤ r, (b, c, )[m, i; n] is neither  nor ⊥. Then for
i ≤ r, S1 [m, i; n] is
Λ[m; n] −→ Π[m; n], (b, c, )[m, i; n].
The sequent S translates into
r

S[m; n] =def Λ[m; n] −→ Π[m; n],

(b, i, )[m; n].
i=0

Thus S[m; n] is obtained from S1 [m, i; n] (for i = 0, 1, . . . , r) by the
∧-right rule. No new instance of the cut rule is needed. This proof of
S[m; n] has size slightly more than the sum of the (m +1) proofs [m, i; n],
and m is a polynomial in m, n. Hence the resulting proof is bounded in
size by a polynomial in m, n.
The case ∃-left is similar, and the cases ∀-left, ∃-right are straightforward. These are left as an exercise.
Exercise VII.2.10. Take care of the other number quantiﬁer cases.
Finally we consider the case that S is obtained by the ΣB0 -IND rule:
S1

=

Λ, (c) −→

(c + 1), Π

Λ, (0) −→ (t), Π
S
where c does not occur in S, and we have suppressed all free variables
except c (here t is of the form t(b, | |)). By the induction hypothesis,
there are polynomial size d -PK proofs [m, i; n] of the propositional
sequents
S1 [m, i; n] =def Λ[m; n], (c)[m, i; n] −→

(c + 1)[m, i; n], Π[m; n]

for some constant d ∈ N. Let r = val(t(m, n)). The sequent S translates
into
S[m; n] =def Λ[m; n], (0)[m; n] −→

(r)[m; n], Π[m; n].

VII.3. Quantiﬁed Propositional Calculus

173

Now if r = 0 then S[m; n] is derived from the following axiom of PK
simply by weakening:
(0)[m; n] −→

(0)[m; n].

For r > 0, we combine these proofs [m, i; n] for i = 0, 1, . . . , r − 1
by using repeated cuts, with cut formulas (i)[m; n], 1 ≤ i ≤ r − 1.
By Lemma VII.2.2, these formulas have depth bounded by a constant
depending only on . Also, given that each [m, i; n] has a polynomial
bounded size, the proof [m; n] is easily shown to be bounded in size by
some polynomial in m, n. This completes the proof of the Translation
2
Theorem for V 0 .
Note that the ΣB0 -IND axioms are ΣB0 . So in fact we could have deﬁned
 0 to include the ΣB -IND axiom scheme instead of the ΣB -IND rule.
LK 2 -V
0
0
Here we can use the following version of the ΣB0 -IND axiom:
(ϕ(0) ∧ ∀x < t(ϕ(x) ⊃ ϕ(x + 1))) ⊃ ∀z ≤ tϕ(z)

(127)

where t is any term not involving x or z, and ϕ is a ΣB0 formula which may
contain other free variables.
In this way, the case of the ΣB0 -IND rule in the induction step of the
proof above is replaced by two cases: One for the base case where the
axiom is an ΣB0 -IND axiom, and one for the induction step, in the case of
the cut rule where the cut formula is an instance of the ΣB0 -IND axioms.
The latter is dealt with just as any other instance of the cut rule. Handling
the former is left as an exercise.
Exercise VII.2.11. Show directly (without using Theorem VII.2.3) that
the translation of (127) above has polynomial size d -PK proofs, where d
depends only on ϕ.

VII.3. Quantiﬁed Propositional Calculus
Quantiﬁed Propositional Calculus (QPC) is an extension of the Propositional Calculus (Section II.1) which allows quantiﬁers over propositional
variables. In this section we will discuss the sequent system G which
extends Gentzen’s system PK by the introduction rules for the propositional quantiﬁers. There are subsystems of G that relate to the ﬁrst-order
theories in the same way that bPK relates to V 0 . Here we will show this
relationship between V 1 and the subsystem G1 of G.
Formally, QPC formulas (or simply formulas) are built from
• propositional constants , ⊥,
• free variables p, q, r, . . . ,
• bound variables x, y, z, . . . ,
• connectives ∧, ∨, ¬,
• quantiﬁers ∃, ∀,

174

VII. Propositional Translations

• parentheses (, )
according to the following rules:
(a) , ⊥, and p are atomic formulas, for any free variable p;
(b) if ϕ and are formulas, so are (ϕ ∧ ), (ϕ ∨ ), ¬ϕ;
(c) if ϕ(p) is a formula, then ∀xϕ(x) and ∃xϕ(x) are formulas, for any
free variable p and bound variable x.
A QPC sentence (or just sentence) is a QPC formula with no occurrence
of a free variable.
Example VII.3.1. The following is a QPC formula:


∀x∃y (¬y ∨ (¬x ∧ p)) ∧ (y ∨ x ∨ ¬p) .

(128)

A truth assignment is an assignment of truth values True, False to the
free variables. The truth value of a QPC formula is deﬁned inductively,
much as in the case of the Propositional Calculus. Here in the induction
step, for the case of the quantiﬁers we use the equivalences
∀xϕ(x) ↔ (ϕ(⊥) ∧ ϕ())

and

∃xϕ(x) ↔ (ϕ(⊥) ∨ ϕ()).

A QPC formula is valid if it is true under all assignments. The notions
of satisﬁability and logical consequence (Deﬁnition II.1.1) generalize to
QPC in the obvious way. So, for example, the formula (128) is valid
(choose y ↔ (¬x ∧ p)).
It is a standard result in complexity theory that the problem of determining validity of a formula of QPC is PSPACE complete (see Appendix
A.1). Furthermore, it is natural to deﬁne a language L ⊆ {0, 1}∗ to be
in nonuniform PSPACE if there is a polynomial size family ϕn (p) of
QPC formulas such that ϕn (p1 , . . . , pn ) deﬁnes the strings of length n in
L. (Actually this deﬁnes the class PSPACE/poly, which is PSPACE with
polynomial advice.) For this and other reasons, G (deﬁned below) is a
natural choice for a QPC proof system corresponding to the complexity
class PSPACE. However if the number of quantiﬁer alternations in a
QPC formula is limited by some constant k, then the validity problem for
such formulas is in the polynomial hierarchy.
Deﬁnition VII.3.2 (Σqi and Πqi ). Σq0 = Πq0 is the class of quantiﬁer-free
formulas of QPC. For i ≥ 0, Σqi+1 and Πqi+1 are the smallest classes of QPC
formulas satisfying
1) Σqi ∪ Πqi ⊆ Σqi+1 ∩ Πqi+1 ;
2) Σqi+1 is closed under ∨ and ∧ and existential quantiﬁcation;
3) Πqi+1 is closed under ∨ and ∧ and universal quantiﬁcation;
4) if A ∈ Σqi+1 then ¬A ∈ Πqi+1 ;
5) if A ∈ Πqi+1 then ¬A ∈ Σqi+1 .
Thus
Σq0 = Πq0 ⊂ · · · ⊂ Σqi ∩ Πqi ⊂ Σqi ∪ Πqi ⊂ Σqi+1 ∩ Πqi+1 ⊂ · · · .

VII.3. Quantiﬁed Propositional Calculus

175

For i ≥ 0 every formula in Σqi+1 has a prenex form with at most i alternations of quantiﬁers, with the outermost quantiﬁer being ∃. Similarly for
Πqi+1 with the outermost quantiﬁer being ∀. Checking the validity of a Σqi
(resp. Πqi ) sentence is Σpi -complete (resp. Πpi -complete), for i ≥ 1. For
i = 0, this problem is NC 1 -complete.
VII.3.1. QPC Proof Systems. We generalize Deﬁnition VII.1.2 in the
obvious way to deﬁne the notion of QPC proof system where now F maps
{0, 1}∗ onto the set of valid QPC formulas. Since the validity problem for
QPC formulas is complete for PSPACE, the following result is proved in
the same way as Theorem VII.1.4.
Theorem VII.3.3. There exists a polynomially bounded QPC proof system iﬀ NP = PSPACE.
The assertion NP = PSPACE is considerably more implausible than
NP = co-NP, but still the existence of a polynomially bounded QPC proof
system is open.
The notions p-simulate and p-equivalent from Deﬁnition VII.1.5 apply
in the obvious way to QPC proof systems.
VII.3.2. The System G. The QPC proof system G is a sequent system
which includes the axioms and rules for PK, where now formulas are
interpreted to be QPC formulas. It also has the following four quantiﬁer
introduction rules:
∀ introduction rules:
∀-left:

A(B), Γ −→ Δ
∀xA(x), Γ −→ Δ

∀-right:

Γ −→ Δ, A(p)
Γ −→ Δ, ∀xA(x)

∃ introduction rules:
∃-left:

A(p), Γ −→ Δ
∃xA(x), Γ −→ Δ

∃-right:

Γ −→ Δ, A(B)
Γ −→ Δ, ∃xA(x)

Restriction. In the rules ∀-right and ∃-left, p is a free variable called an
eigenvariable that must not occur in the bottom sequent. For the rules ∀left and ∃-right, A(B) is the result of substituting B for all free occurrences
of x in A(x). The formula B is called the target formula and may be any
quantiﬁer-free formula (with no bound variables).
The new formulas ∃xA(x) and ∀xA(x) are called principal formulas,
and the corresponding formulas in the top sequents (A(B) or A(p)) are
called auxiliary formulas.
Proofs in G are dags of sequents, which generalizes the treelike structure
of LK proofs (see Subsection VII.1.1). We denote by G  the system G
restricted to treelike proofs. We will show that G and G  are p-equivalent
(Theorem VII.4.3).
The notion of free variable normal form (Deﬁnition II.2.20) readily extends to G proofs. In fact every treelike G proof can be easily transformed

176

VII. Propositional Translations

to one in free variable normal form by renaming variables and substituting
the constant ⊥ for some variables.
Theorem VII.3.4 (Soundness and Completeness of G). A sequent of G
is valid iﬀ it has a G proof. In fact, valid sequents have cut-free G proofs.
Proof. Soundness is easy: Provable sequents of G are valid because
the axioms of G are valid, and the rules preserve validity.
For completeness, we ﬁrst point out that a valid quantiﬁer-free sequent
of QPC has a cut-free G proof, by the PK Completeness Theorem II.1.8.
In general, we prove the result by induction on the maximum quantiﬁer
depth of the formulas in the sequent (and then induction on the number of formulas in the sequent of maximum quantiﬁer depth). We have
just proved the base case, where the sequent is quantiﬁer-free. For the
induction step, the interesting cases are where the sequent is of the form
∀xA(x), Γ −→ Δ

or

Γ −→ Δ, ∃xA(x).

These two cases are dual. So consider the sequent
∀xA(x), Γ −→ Δ.

(129)

We can reduce the quantiﬁer depth in ∀xA(x) by showing that (129) is
valid iﬀ the sequent
A(), A(⊥), Γ −→ Δ
is valid.

(130)
2

Exercise VII.3.5. Carry out the details in the induction step in the
above proof of the completeness of G.
The proof above shows that actually G remains complete when the target
formulas B in ∀-left and ∃-right are restricted to be in the set {, ⊥}. In
fact, the restricted system is p-equivalent to G. This can be shown with
the help of the following exercise.
Exercise VII.3.6. Show that the following sequents has cut-free G
proofs of size O(|A(B)|2 ), where A and B are any QPC formulas.
(a) B, A(B) −→ A().
(b) A(B) −→ A(⊥), B.
(c) B, A() −→ A(B).
(d) A(⊥) −→ A(B), B.
(Hint: Prove by structural induction on A for (a) and (c) simultaneously.
Similarly for (b) and (d).)
Exercise VII.3.7 (Morioka [80]). Let KPG be the modiﬁcation of G
resulting from relaxing the condition that the target formula B in the
rules ∀-left and ∃-right must be quantiﬁer-free (so B is allowed to be any
QPC formula). Show that G p-simulates KPG. Show that the same holds

VII.3. Quantiﬁed Propositional Calculus

177

even if G is restricted so that the target formulas B in the rules ∀-left and
∃-right are restricted to be in the set {, ⊥}. Use Exercise VII.3.6.
The original system G deﬁned in [73] is actually KPG as deﬁned in the
above exercise. Thus the original G and our G are p-equivalent.
The proof of completeness in Theorem VII.3.4 could yield proofs of
doubly exponential size. For example if the formula ∀xA(x) in (129)
begins with k universal quantiﬁers, then eliminating them all using (130)
would yield 2k copies of A, and the resulting valid sequent could require a
proof exponential in its length. We now prove a singly-exponential upper
bound for G proofs which allow cuts on atomic formulas.
We say that an occurrence of a symbol in a formula is positive (resp.
negative) if it is in the scope of an even (resp. odd) number of ¬’s.
Deﬁnition VII.3.8 (Sequent Length). An occurrence of a connective
c in a sequent Γ −→ Δ is general if c is ∧ or ∀ and occurs positively
in Δ or negatively in Γ, or if c is ∨ or ∃ and c occurs negatively in Δ
or positively in Γ. A restricted occurrence is deﬁned similarly, except Δ
and Γ are interchanged. For a sequent S, |S|g (resp. |S|r ) denotes the
number of occurrences in S of general connectives (resp. ¬’s and restricted
connectives). Also |S| denotes the total number of occurrences of symbols
in S, counting variables p, q, r, . . . , x, y, z, . . . as one symbol each.
Theorem VII.3.9. If S is a valid sequent in the language of G with n
distinct free variables, then S has a treelike G proof with O(|S|r 2|S|g +n )
sequents (not counting weakenings and exchanges) in which all cut formulas
are atomic and each sequent in the proof has length O(|S|). If S is quantiﬁerfree, or if all quantiﬁer occurrences in S are general, then the proof is cut-free
and the bound is improved to O(|S|r 2|S|g ).
Proof. Notation. We say that a free variable p is determined in a
sequent A1 , . . . , Ak −→ B1 , . . . B if one of the formulas Ai or Bj is the
atomic formula p. A sequent is determined if all of its free variables are
determined.
Note that if all free variables of a sequent are determined, then there is
at most one truth assignment to these free variables which fails to satisfy
the sequent.
Lemma VII.3.10. If S is a valid sequent with all of its free variables
determined, then S has a treelike G proof with O(|S|r 2|S|g ) sequents (not
counting weakenings and exchanges) in which all cut formulas are atomic
and each sequent in the proof has length O(|S|). If S is quantiﬁer-free or if
all quantiﬁer occurrences in S are general, then the same bound applies even
if not all free variables in S are determined, and further the proof is treelike
and cut-free.
The second sentence of Theorem VII.3.9 follows immediately from the
lemma. We now prove the ﬁrst sentence of the theorem from the lemma.

178

VII. Propositional Translations

Let F be the set of free variables in S. For each of the 2n subsets K of F
let SK be the sequent resulting from S by appending a list of the variables
in K to the antecedent and the variables in F − K to the consequent. For
example if S = Γ −→ Δ and F = {p1 , p2 , p3 } and K = {p2 }, then SK is
p2 , Γ −→ Δ, p1 , p3 .
Each SK is valid and determined, and hence by the lemma has a proof
with O(|S|r 2|S|g ) sequents. Then S can be derived by combining these 2n
proofs with 2n−1 atomic cuts.
2
Proof of Lemma VII.3.10. We use induction on the total number of
connectives ∧, ∨, ¬, ∀, ∃ in S. The base case is immediate, since any valid
sequent with no such connectives is a subsequent of an axiom.
For the induction step, we have a case for each of the connectives
∧, ∨, ¬, ∀, ∃. We consider a formula A occurring in the consequent: The
argument for the antecedent is dual. If A is of the form ¬B then S has
the form Γ −→ Δ, ¬B. Let S  be the sequent B, Γ −→ Δ. Then S  is valid
(and determined if S is) and |S  |r = |S|r − 1, so the induction hypothesis
applies and S can be derived from S  by the rule ¬-right. The case in
which A has the form B ∨ C is similar, using the rule ∨-right.
If S has the form Γ −→ Δ, (B ∧ C ), then Γ −→ Δ, B and Γ −→ Δ, C
are each valid (and determined if S is) and have reduced |S|g , and S can
be derived by ∧-right from these two sequents.
Suppose that S is Γ −→ Δ, ∀xA(x). Then S  = Γ −→ Δ, A(p) is
valid, where p is a new free variable. Further |S  |g = |S|g − 1 and S
follows from S  using ∀-right. This takes care of the second sentence in
the lemma, but for the ﬁrst sentence there is the problem that S  may not
be determined, even if S is. But each of the sequents p, Γ −→ Δ, A(p)
and Γ −→ Δ, A(p), p is valid and determined if S is, and by the induction
hypothesis can be proved with O(|S|r 2|S|g −1 ) sequents. Further S can be
derived from these two sequents with a cut on p and ∀-right, making a
total of O(|S|r 2|S|g + 2) = O(|S|r 2|S|g ) sequents.
Finally consider the case in which S is Γ −→ Δ, ∃xA(x). Since the
occurrence of ∃ is restricted, the second sentence of the lemma does not
apply, so we may assume that S is determined and valid. We claim that
one of the two sequents Γ −→ Δ, A() and Γ −→ Δ, A(⊥) is valid (they
are both determined). To see this, note that since S is determined there
is at most one truth assignment  to the free variables of S that could
falsify Γ −→ Δ. If no such  exists, we are done. Otherwise  satisﬁes
∃xA(x), and hence  satisﬁes either A() or A(⊥). Hence we may apply
the induction hypothesis to one of these sequents, and obtain S using
∃-right.
2

VII.4. The Systems Gi and Gi

179

VII.4. The Systems Gi and Gi
Deﬁnition VII.4.1 (Gi and Gi ). For each i ≥ 0, Gi is the subsystem
of G in which cut formulas are restricted to Σqi ∪ Πqi . The system Gi is
treelike Gi .
The following result is immediate from Theorem VII.3.9.
Corollary VII.4.2. Every valid QPC sequent S has a G0 proof of
size 2O(|S|) .

p-simulates Gi , when the systems are
Theorem VII.4.3. For i ≥ 0, Gi+1
q
q
restricted to proving Σi ∪ Πi formulas. G  p-simulates G.

Proof. The argument is similar to the proof of Theorem VII.1.8, except
for the quantiﬁer rules ∀-right and ∃-left we can no longer argue that the
conclusion is a logical consequence of the hypotheses. However for each
rule deriving a sequent S from a sequent S1 we know that ∀AS is a logical
consequence of ∀AS1 , where ∀B is the universal closure of B. Thus we
replace the Claim in the earlier proof by arguing that if  = S1 , . . . , Sn is
a daglike G proof then
−→ ∀AS1 ; −→ (∀AS1 ∧ ∀AS2 ); . . . ; −→ (∀AS1 ∧ · · · ∧ ∀ASn ); −→ ASn
(131)
can be augmented to a treelike G proof whose size is bounded by a
polynomial in the length of , and in which cut formulas are restricted to
subformulas of formulas in the sequence. The theorem then follows from
the fact if the all formulas in the sequent S are in Σqi ∪ Πqi then the formula
∀AS is in Πqi+1 .
Our new claim follows from Exercise VII.1.9 (b), the fact that for every
axiom S of G, −→ ∀AS has an easy G0 proof, and the exercise below. 2
Exercise VII.4.4. (a) Suppose that if S is derived from S1 (and S2 )
by an inference rule of G. Show that the following sequents have
polynomial size cut-free G proofs for any formula A. (For the PK
rules it is helpful to use Exercise VII.1.9 (b).)
(i) A ∧ ∀AS1 −→ A ∧ ∀AS .
(ii) A ∧ ∀AS1 ∧ ∀AS2 −→ A ∧ ∀AS .
(b) Show that for every sequent S = Γ −→ Δ, the sequent
∀AS , Γ −→ Δ
has a polynomial size cut-free treelike G proof.
The next result strengthens Theorem VII.4.3 for the case i = 0.

180

VII. Propositional Translations

Theorem VII.4.5 (Morioka [80]). G0 p-simulates G0 restricted to proving prenex Σq1 formulas.
Proof sketch. Note that the proof of Theorem VII.1.8 (treelike PK psimulates daglike PK) does not adapt to this case, because that argument
requires cuts on conjunctions of earlier lines in the proof, which now
would involve quantiﬁers.
Instead, following [80], we argue that a form of Gentzen’s Midsequent
Theorem can be made to work in polynomial time. Let  be a G0 proof
of a sequent
−→ ∃x1 . . . ∃xm C (p, x1 , . . . , xm )

(132)

where C (p, x1 , . . . , xm ) is quantiﬁer-free. Since all cut formulas in  are
quantiﬁer-free, it follows that every quantiﬁed formula in  is an ancestor
of the conclusion, and must occur on the RHS and must have the form
∃xk . . . ∃xm C (p, B1 . . . Bk−1 , xk , . . . , xm )

(133)

for some quantiﬁer-free formulas B1 , . . . , Bk−1 and some k, 1 ≤ k ≤ m.
Let us call a formula a -prototype if it is quantiﬁer-free and is the auxiliary
formula in an ∃-right rule (so it is the quantiﬁer-free parent of a formula
of the form (133), with k = m + 1). Thus a -prototype has the form
C (p, B1 . . . Bm ).
The Herbrand  disjunction S is the sequent
−→ A1 , . . . , Ah
where A1 , . . . , Ah is a list of all the -prototypes. It turns out that S is
a valid sequent, and in fact  can be transformed into a PK proof  of
S in polynomial time. To form  from , delete each quantiﬁed formula
(i.e. each formula of the form (133)) from  and add formulas from the
list A1 , . . . , Ah to the RHS of each sequent so that each -prototype is in
the succedent of every sequent. The result can be turned into a PK proof
of S by deleting applications of the rule ∃-right, and adding weakenings,
exchanges, and contractions.
We may assume that the PK proof  of S is treelike, by Theorem VII.1.8. Now   is easily augmented to a treelike proof of (132)
using the rules ∃-right, exchange and contraction.
2
We now show that for Gi we may as well assume that all cut formulas
are prenex Σqi . We start by proving an easy lemma which applies to both
Gi and Gi .
Lemma VII.4.6. If Gi (resp. Gi ) is modiﬁed so that cuts are restricted to
q
Σi -formulas, then the resulting system p-simulates Gi (resp. Gi ).
Proof. If A is a Πqi formula, then any application of the cut rule to
A can be replaced by ﬁrst moving A to the opposite side of each parent
sequent using ¬ introduction, and then cutting ¬A.
2

VII.4. The Systems Gi and Gi

181

Theorem VII.4.7 (Morioka [80]). Let Ĝi be Gi with cut formulas restricted to prenex Σqi formulas. Then Ĝi p-simulates Gi .
Proof. Fix i ≥ 1. Let  be a Gi proof. We may assume that  is in free
variable normal form.
Consider an application of the cut rule in , with cut formula A.
Γ −→ Δ, A

A, Γ −→ Δ

Γ −→ Δ
q

q

We may assume that A is Σi , since if A is Πi we can simply insert ¬introduction steps just before the cut so that the cut formula becomes ¬A.
Our task is to show that this cut on A can be replaced with a cut on A ,
where A is some prenex form of A. To do this we will replace the tree
derivation of Γ −→ Δ, A with a similar derivation of Γ −→ Δ, A , and
similarly replace the derivation of A, Γ −→ Δ by one of A , Γ −→ Δ.
The proof of the Prenex Form Theorem II.5.12 lists ten equivalences as
follows:
(∀xB ∧ C ) ⇐⇒ ∀x(B ∧ C )

(∀xB ∨ C ) ⇐⇒ ∀x(B ∨ C )

(C ∧ ∀xB) ⇐⇒ ∀x(C ∧ B)

(C ∨ ∀xB) ⇐⇒ ∀x(C ∨ B)

(∃xB ∧ C ) ⇐⇒ ∃x(B ∧ C )

(∃xB ∨ C ) ⇐⇒ ∃x(B ∨ C )

(C ∧ ∃xB) ⇐⇒ ∃x(C ∧ B)

(C ∨ ∃xB) ⇐⇒ ∃x(C ∨ B)

¬∀xB ⇐⇒ ∃x¬B

¬∃xB ⇐⇒ ∀x¬B

(where x does not occur free in C ).
To put a formula in prenex form (which is in the same class Σqj or Πqj
with the original formula), it suﬃces to successively transform a formula
A(B(x)) to A(B  (x)), where B ⇐⇒ B  is one of the above equivalences
and x is a list of the variables in B which are bound by quantiﬁers in A.
Consider a derivation of Γ −→ Δ, A(B(x)) or A(B(x)), Γ −→ Δ in
. If we trace the ancestors of A(B(x)) up through this derivation,
each path either ends when the ancestor is formed by a weakening, or it
includes an occurrence of B(D), where D is the list of target formulas
and eigenvariables used by the quantiﬁer introduction rules in forming
A(B(x)) from B(D).
Thus it suﬃces to show, for each of the above equivalences B ⇐⇒ B  ,
how to convert a derivation of Λ −→ Π, B to one of Λ −→ Π, B  and a
derivation of B, Λ −→ Π to one of B  , Λ −→ Π. (In the application to
the previous paragraph, B would be B(D), and B  would be B  (D).)
Consider, for example, converting a derivation of
Λ −→ Π, ¬∀xC (x)
to one of
Λ −→ Π, ∃x¬C (x).

182

VII. Propositional Translations

The ancestral paths of ¬∀xC (x) which do not end in weakening include
∀xC (x) in the antecedent and then C (D) in the antecedent, for some
target formula D. Thus we have arrived at a sequent
C (D), Λ −→ Π .
We modify the derivation after this point by using ¬-right and ∃-right to
obtain
Λ −→ Π , ∃x¬C (x)
and continue the derivation as before, omitting the steps which formed
¬∀xC (x) from C (D).
The argument is similar if ¬∀xC (x) is in the antecedent.
Now consider converting a derivation of
Λ −→ Π, ∀xC (x) ∧ D
to a derivation of
Λ −→ Π, ∀x(C (x) ∧ D).
The ancestral paths of ∀xC (x) ∧ D which do not end in weakening split
after an ∧-right, where the left branch has a ∀-right step
Λ → Π , C (p)
Λ → Π , ∀xC (x)
We modify this by combining it with the right branch just after the split
as follows:
Λ −→ Π , D
Λ −→ Π , C (p)
Λ −→ Π , C (p) ∧ D
Λ −→ Π , ∀x(C (x) ∧ D)
Here it is important that the original derivation be in free variable normal
form, both in order to insure that p does not occur in D, and to guarantee
that the variable restrictions continue to hold in the modiﬁed derivation
of Λ −→ Π, ∀x(C (x) ∧ D).
The other cases are handled similarly.
2
A part of the reverse direction of Theorem VII.4.3 is shown in the next
theorem.

Theorem VII.4.8 (Perron [91]). For i ≥ 1, Gi p-simulates Gi+1
( for all
formulas).
From this theorem and Theorem VII.4.3 we have:

Corollary VII.4.9. For i ≥ 1, Gi and Gi+1
are p-equivalent for proving
q
q
formulas in Σi ∪ Πi .

proof of a formula A. We
Proof of Theorem VII.4.8. Let  be a Gi+1

show how to get a suitable Gi proof  of A from . The idea is to replace
cuts of formulas C not in Πqi ∪ Σqi by cuts on simpler ancestors of C . By
Theorem VII.4.7 we can assume that all cut formulas in  are prenex Σqi+1

VII.4. The Systems Gi and Gi

183

formulas. Furthermore, we can assume that  is in free variable normal
form.
Assume that in  for all axioms of the form
B −→ B
the formula B is quantiﬁer free. This is possible because from these axioms
we can easily derive any axiom with quantiﬁed formulas. Similarly assume
that only quantiﬁer free formulas are used for the weakening rules.
An occurrence of a formula ∃xB(x) in  is said to be tagged if it occurs
in the antecedent Γ of a sequent
S = Γ −→ Δ
and B is in (Πqi − Σqi ) and some descendant in  of ∃xB(x) is cut. Let
−
→
−
→
−
→
B( q 1 ), B( q 2 ), . . . , B( q k )

(134)

−
→
be all (Πqi − Σqi ) ancestors of ∃xB(x), where the variables q i are eigenq
q
variables in . By our assumptions above, every (Σi+1 − Πi ) ancestor of
−
→
∃xB(x) lies on a path from some sequent containing some B( q i ) to S.
Deﬁne
S  = Γ −→ Δ
where Γ is obtained from Γ by replacing every tagged formula ∃xB(x)
in Γ (possibly for more than one formula B(x)) by its corresponding list
−
→
(134). By free variable normal form, the eigenvariables q i associated with
distinct tagged formulas in Γ are distinct. Notice that S  has size bounded
by the size of .
We will describe a polynomial time algorithm which successively transforms, for each sequent S in , the (treelike) derivation S of S to a
daglike Gi derivation S of S  . Note that if S is the ﬁnal sequent in  then
S  = S, and the theorem is proved.
The algorithm starts with the leaves of the proof tree  and works its
way down to the endsequent. The leaf sequents are axioms, which by
our assumptions have no tagged formulas, so there is nothing to do. For
the general step we need to consider the rule used to derive S. If the
principle formula in the rule is not tagged, then S is constructed using
the same rule applied to the transformed proof(s) of the parent(s). If the
principle formula is tagged, then the rule cannot be weakening by our
assumptions, so it must be one of ∃-left, contraction-left, or cut. For
∃-left or contraction-left there is nothing to do: just use the transformed
proof of the parent sequent.
Hence the only non-trivial case is where S is derived by cutting a tagged
formula. So suppose that S3 is a sequent in  and is derived from S1 and

184

VII. Propositional Translations

S2 as below:
S1

S2

=

Γ −→ Δ, ∃xB(x)

∃xB(x), Γ −→ Δ

S3
Γ −→ Δ
q
q
Here B(x) is a formula in (Πi − Σi ). Suppose that
S3 = Γ −→ Δ.
Then note that
and S2 has the form

S1 = Γ −→ Δ, ∃xB(x)

−
→
−
→
−
→
S2 = B( q 1 ), B( q 2 ), . . . , B( q k ), Γ −→ Δ
→
where no eigenvariable in any −
qi occurs in Γ or Δ. We have previously

found short Gi derivations S 1 , S 2 of the sequents S1 , S2 . The idea is to
convert S 1 into a Gi derivation of Γ −→ Δ by cutting ‘topmost’ ancestors
of ∃xB(x) using substitution instances of S2 .
First we add Γ to the antecedent and Δ to the succedent of every
sequent in S 1 (and add necessary weakenings to have a legitimate proof).
Call the result S1 .
Now consider a sequent
S11 = Λ −→ Π, B(C )

(135)

in  where B(C ) is an ancestor of ∃xB(x) in S1 . (Here C consists of Σq0
formulas.) We say that B(C ) is a topmost ancestor if it has no further
ancestor B(C ) in ; i.e. B(C ) is the principle formula in the ∀-right rule

has become
used to derive the sequent (135). In S1 S11
Γ , Λ −→ Δ, Π, B(C ).
Apply the Substitution Lemma VII.4.10 below and using contractions left
we create for each topmost ancestor B(C ) of ∃xB(x) a Gi derivation of
the form
S2
(136)
============
B(C ), Γ −→ Δ
(Since there may be more than one topmost ancestor with diﬀerent formulas C , the sequent S2 may have to be used more than once, which is
why our transformed proof may not be treelike). For each topmost ancestor B(C ) in turn, working from the top of  down, insert the following
derivation in S1 :
Γ , Λ −→ Δ, Π, B(C )
B(C ), Γ −→ Δ
(137)
============
=
=
=
=
=
=
=
=
=
===========
Γ , Λ −→ Π, Δ
(where the upper right sequent is derived by (136)) and remove all descendants of B(C ) in the so-far transformed S1 as far as possible. If a

VII.4. The Systems Gi and Gi

185

descendant is the principle formula in a contraction then simply delete
that contraction rule. If a descendant is a side formula in a two-parent
rule, then progress must wait until the matching side formula in the other
parent is removed. When this is done for each topmost ancestor, all descendants of the form ∃xB(x) will be removed, and we obtain a proof of
the sequent
Γ , Γ −→ Δ, Δ.
With additional applications of the contraction rules we obtain a legitimate derivation S 3 of S3 .
Finally we verify that the ﬁnal Gi proof  has size polynomial in the
size of . Notice that all new sequents have size polynomial in the size of
. (The bottom sequent in (136) is the only sequent that might have size
larger than .) So it remains to show that the number of sequents in  is
bounded by a polynomial in the size || of .
For a sequent S in  let nS  denote the number of sequents used in the
derivation of S  in  . Consider the interesting case of the cut rule in the
algorithm above. It suﬃces to show that for some polynomial p we have
nS3 ≤ nS1 + nS2 + p(||).
This follows from the fact that for each sequent S (135) in  the total
number of sequents in the derivations (136) and (137), as well as the
number of applications of weakening and contraction rules described
above are bounded above by some polynomial in || independent of S3 .
2
Lemma VII.4.10 (Substitution). There is a polynomial size Gi derivation
Γ(p), Γ −→ Δ(p), Δ
=======
==========
Γ(B), Γ −→ Δ(B), Δ

(138)

where B is a quantiﬁer-free formula, all formulas in Γ and Δ are in Σqi ∪ Πqi ,
and p does not occur in the bottom sequent.
To prove the above lemma we need:
Lemma VII.4.11 (G0 -Replacement). Let A(p) be a quantiﬁed propositional formula, and let A(B) be the result of substituting the formula B for
p in A(p). Then for all formulas B1 , B2 , the sequent
B1 ↔ B2 −→ A(B1 ) ↔ A(B2 )
has a G0 proof of size bounded by a polynomial in the size of its endsequent.
Exercise VII.4.12. Prove the Lemma. (See Exercise VII.1.11.)
Proof of the Substitution Lemma. From the G0 -Replacement Lemma above, we have a G0 proof of
p ↔ B, A(p) −→ A(B)

186

VII. Propositional Translations

for each formula A(p) in Δ(p). From these and
Γ(p), Γ −→ Δ(p), Δ
we obtain (by the cut rule on the formulas A(p) in Δ(p))
p ↔ B, Γ(p), Γ −→ Δ(B), Δ .

(139)

Again, by the G0 -Replacement Lemma, we have G0 derivations of
p ↔ B, A(B) −→ A(p)
for all formulas A(p) in Γ(p). From these and (139) we obtain
p ↔ B, Γ(B), Γ −→ Δ(B), Δ .
Now by the ∃-left rule we get
∃x(x ↔ B), Γ(B), Γ −→ Δ(B), Δ .
Finally, it is easy to see that the sequent
−→ ∃x(x ↔ B)
q

can be derived in G0 . Consequently, by the cut rule on the Σ1 formula
∃x(x ↔ B) we obtain the bottom sequent of (138). It is clear that all the
derivations above have size polynomial in the length of the endsequents.
2

Unlike the situation for PK and G0 , it seems unlikely that G1 p-simulates
G1 . To explain why, we need the notion of witnessing for QPC proof
systems.
VII.4.1. Extended Frege Systems and Witnessing in G1 . In previous
chapters we proved witnessing theorems which concern the complexity of
witnessing the leading existential quantiﬁers in a bounded L2A formula,
given values for the free variables. The analogous witnessing problem for
a QPC formula is trivial, because there are only ﬁnitely many possible
values for the free variables. However the problem becomes interesting if
we consider a family of formulas, and include a proof of the formula as
part of the input.
Theorem VII.4.13 (The Witnessing Theorem for G1 ). There is a polynomial time function F (, ) which, given a G1 proof  of a formula of the
form ∃xA(x, p) (where A(x, p) is quantiﬁer-free) and an assignment  to
p, returns an extension   of  such that   satisﬁes A(x, p).
We show in Theorem X.2.33 that if  is a G1 proof (as opposed to a
G1 proof), then the witnessing problem becomes complete for the search
class PLS (Polynomial Local Search). Since it seems unlikely that PLS
problems can all be solved in polynomial time, it seems unlikely that G1
p-simulates G1 .
In general the problem of computing such   from  without  is complete for PNP , if we are required to say “no” if there is no witness. Hence
it is clear that the proof  provides helpful information.

VII.4. The Systems Gi and Gi

187

We will prove the Witnessing Theorem for G1 by analyzing a closelyrelated system ePK, a member of the class of extended Frege proof systems.
In general, a line in an extended Frege proof has the expressive power
of a Boolean circuit, and a problem in nonuniform P is presented by
a polynomial size family of Boolean circuits. The connection between
the extended Frege proof systems and P is thus analogous to that of the
bounded depth Frege proof systems (e.g., bPK) and AC 0 that we have seen
(Section VII.2), or that of the Frege systems and NC 1 , as we discussed in
the Preface.
Deﬁnition VII.4.14 (Extension Cedent). The sequence of formulas
Λ = e1 ↔ B1 , e2 ↔ B2 , . . . , en ↔ Bn

(140)

is an extension cedent provided that for i = 1, . . . , n, the atom ei does not
occur in any of the formulas B1 , . . . , Bi . The atoms e1 , . . . , en are called
extension variables.
Intuitively, we think of e1 , . . . , en as gates in a Boolean circuit, where
the value of ei is determined by Bi together with the values of the earlier
gates e1 , . . . , ei−1 . In an ePK proof of an existential statement, some of
these extension variables are used to witness the existential quantiﬁers.
Deﬁnition VII.4.15 (ePK Proof). Let ∃xA(x, p) be a QPC formula
with free variables p such that A(x, p) is quantiﬁer-free. An ePK proof
of ∃xA(x, p) is a PK proof of any sequent of the form
Λ −→ A(e1 , p)
where Λ is an extension cedent (140) in which the extension variables e
are disjoint from p, e1 is a subset of e, and each Bi contains only variables
among e, p.
This deﬁnition is interesting even in the case that the ﬁnal formula is
quantiﬁer-free. Then the extension variables are not used to witness quantiﬁers, but they still may be useful in deﬁning polynomial time concepts
needed in the proof. As far as we know, PK does not p-simulate ePK even
when the latter is restricted to proving quantiﬁer-free formulas.
Theorem VII.4.16 (Krajı́ček [72]). G1 , restricted to proving prenex Σq1
formulas, is p-equivalent to ePK.
Before giving the proof, we show how the Witnessing Theorem for G1
follows from this.
Proof of Theorem VII.4.13. Let  be a G1 proof of ∃xA(x, p), and let
 be an assignment to p, as in the statement of the Witnessing Theorem. By
the preceding theorem, we can transform  to an ePK proof of ∃xA(x, p);
that is, a PK proof of a sequent
e1 ↔ B1 , e2 ↔ B2 , . . . , en ↔ Bn −→ A(e1 , p).

(141)

188

VII. Propositional Translations

Now given the the assignment  to p, values for e1 , e2 , . . . , en can be
computed successively by evaluating B1 , . . . , Bn , and these values deﬁne
the desired extension   of  which satisﬁes A(x, p).
2

Proof of Theorem VII.4.16. First we show that G1 p-simulates ePK .
Let  be a (treelike) ePK proof of ∃xA(x, p). Then  is a PK proof of a
sequent of the form (141). We show how to extend this PK proof to make
a G1 proof of ∃xA(x, p). We start by repeated application of ∃-right to
obtain a proof of
e1 ↔ B1 , e2 ↔ B2 , . . . , en ↔ Bn −→ ∃xA(x, p).

(142)

Now for each formula B there is a short PK proof of −→ (B ↔ B),
and with one application of ∃-right we obtain a short G1 proof of
−→ ∃x(x ↔ B).

(143)

Now apply ∃-left to (142) to change the formula (en ↔ Bn ) to ∃x(x ↔
Bn ). (Note that en does not occur elsewhere in (142), so the variable
restriction for this rule is satisﬁed.) Now apply the cut rule to this and
(143) to obtain
e1 ↔ B1 , e2 ↔ B2 , . . . , en−1 ↔ Bn−1 −→ ∃xA(x, p).
Applying this process a total of n times we may eliminate each formula
ei ↔ Bi in (142) to obtain the desired G1 proof of size polynomial in the
size of .
Now we prove the converse. Let  be a G1 proof of −→ ∃xA(x, p). We
may assume that  is in free variable normal form, and by Theorem VII.4.7
we may assume that all cut formulas in  are prenex Σq1 , so each sequent
of  has the form
S = . . . , ∃x i αi (x i , r), . . . , Γ −→ Δ, . . . , ∃y j j (y j , r), . . .

(144)

where all αi and j as well as all formulas in Γ and Δ are quantiﬁer-free,
and r is precisely the list of the free variables occurring in S. Notice
that r may have variables not in p, which are used as eigenvariables for
∃-left.
We transform the proof  to an ePK proof  by transforming each such
sequent S to a corresponding quantiﬁer-free sequent S  , and supplying
a suitable proof of S  . To describe S  , we ﬁrst replace each vector x i of
bound variables by a distinct vector q i = q1i , . . . , qii of new free variables,
and similarly we replace y i by a new vector e i . None of these new variables
should occur in . Then
S  = Λ, . . . , αi (q i , r), . . . , Γ −→ Δ, . . . ,

j (e

j , r), . . . ,

(145)

where Λ is an extension cedent deﬁning the extension variables . . . , e j , . . . .
If S is the endsequent −→ ∃xA(x, p), then S  has the form Λ −→
A(e1 , p), so  is the desired ePK proof of ∃xA(x, p).

VII.4. The Systems Gi and Gi

189

We deﬁne Λ and show that S  has an ePK proof polynomial in the size
of the G1 proof of S, by induction on the depth of S in .
For the base case, S is an axiom
∃xα(x, r) −→ ∃xα(x, r)


and S is easy to obtain.
For the induction step there is one case for each rule of G1 .
Case I. Weakening and exchange are trivial, and contraction follows
from cut. The single parent rules ¬ and ∧-left and ∨-right are easy, since
the principle formulas are quantiﬁer-free, and the same rule can be applied
to form S  .
Case II. For the two parent rules ∧-right and ∨-left, the principle
formulas are quantiﬁer-free, but we face the diﬃculty that the extension
cedents Λ for the two parents may give inconsistent deﬁnitions of the extension variables. This is similar to the diﬃculty for Case VII in the proof
of Lemma V.5.5 for the V 0 witnessing theorem. There the witnessing
functions for a formula in Π for the two parents might be diﬀerent. We
solve the problem in a similar way, by deﬁning the extension variables to
values that make them true when possible.
Speciﬁcally, consider the case of ∧-right, where for simplicity we assume
there is exactly one formula in the succedent beginning with existential
quantiﬁers (that formula cannot be C or D):
−
→
−
→
S1
S2
Γ −→ Δ, ∃y (y, r 1 ), C
Γ −→ Δ, ∃y (y, r 2 ), D
=
S
Γ −→ Δ, ∃y (y, r), (C ∧ D)
→
−
→ −
where r is the union of the lists r 1 , r 2 . By the induction hypothesis, we
have ePK proofs of the two sequents
−
→
S1 = Λ1 , Γ −→ Δ, (e, r 1 ), C
and

−
→
S2 = Λ2 , Γ −→ Δ, (s , r 2 ), D

where in the the second case we have changed the extension variables from
e to s. Since  is treelike, we can assume that the ePK derivations of S1
and S2 are disjoint, and hence we can change variable names in one proof
without aﬀecting the other proof. Thus we may assume that the extension
variables deﬁned in Λ1 and Λ2 are disjoint, and in particular e and s
have no variable in common. Thus the extension cedents Λ1 and Λ2 are
consistent. Further we may assume that the variables q i are the same in
S1 and S2 .
From S1 and S2 with ∧-right we obtain
Λ1 , Λ2 , Γ → Δ, (e, r), (s , r), (C ∧ D).

(146)

190

VII. Propositional Translations

Now we introduce new extension variables t, and introduce the extension
formulas


Ei =def ( (e, r) ∧ ei ) ∨ (¬ (s , r) ∧ si )
and deﬁne the extension cedent
Λ3 = t1 ↔ E1 , t2 ↔ E2 , . . . .
Then deﬁne
S  = Λ1 , Λ2 , Λ3 , Γ −→ Δ, (t, r), (C ∧ D).
One can show with the help of Lemma VII.1.10 that each of the sequents
Λ3 , (e, r) −→ (t, r),

(147)

Λ3 , (s, r) −→ (t, r)

(148)

has a short PK proof. Using these and (146) and two cuts we obtain a
short PK derivation of S  from S1 and S2 .
Case III. ∃-left is easy, since it just means changing the role of a free
eigenvariable r in S1 to the variable q in S  corresponding to ∃x.
Case IV. Suppose S comes from S1 using ∃-right.
Γ −→ Δ, ∃y (B, y, r)
S1
=
.
S
Γ −→ Δ, ∃z∃y (z, y, r)
Here the target formula B is quantiﬁer-free, by deﬁnition of G. Since 
is in free variable normal form, no free variable can be eliminated by this
rule, and so the list r of free variables in S is the same as for S1 . By the
induction hypothesis, we have an ePK derivation of
S1 = Λ, Γ −→ Δ , (B, e, r).
Let s be a new extension variable, and let
S  = Λ, s ↔ B, Γ −→ Δ , (s, e, r).
It follows from the PK-Replacement Lemma VII.1.10 that S  has a short
PK derivation from S1 .
Case V. Suppose S comes from S1 , S2 by cut:
S1
S2
Γ −→ Δ, C
C, Γ −→ Δ
=
S3
Γ −→ Δ
Since  is in free variable normal form, every free variable in C also occurs
in the conclusion S3 . Suppose ﬁrst that the cut formula C is quantiﬁerfree. Then the only diﬃculty is that the extension cedents Λ for the two
parents may give inconsistent deﬁnitions of the extension variables witnessing quantiﬁers in Δ. We handle this diﬃculty in the same way as for
Case II above.
The case in which C has existential quantiﬁers is more complicated,
since the deﬁnitions of the new extension variables witnessing quantiﬁers

VII.5. Propositional Translations for V i

191

in Δ now depend on witnesses for the quantiﬁers in C supplied by S1 .
These new deﬁnitions are similar to the new witnessing functions deﬁned
for the case of cut (Case VI) in the proof of Lemma V.5.5 used to prove
the V 0 Witnessing Theorem.
2
Exercise VII.4.17. Carry out the details of Case V in the above proof.

VII.5. Propositional Translations for V i
In this section we show that for i ≥ 1, Gi is closely related to the
theory V i . In fact Theorem VII.5.2 together with results in Chapter X
suggest that Gi restricted to Σqi formulas is a nonuniform version of
the ΣBi -fragment of V i . We have already shown by Theorem VII.4.13
a connection between G1 and V 1 : Σq1 -theorems of G1 can be uniformly
witnessed in polynomial time, just as each ΣB1 -theorem of V 1 can be
witnessed in polynomial time.
It is straightforward to extend the propositional translation of ΣB0 (L2A )
formulas (Section VII.2) to a translation of any bounded L2A formula.
Here every gΣBi (resp. gΠBi ) formula ϕ(x, X ), with all free variables indicated, translates into a family of Σqi (resp. Πqi ) formulas:
#ϕ(x, X )# = {ϕ(x, X )[m; n] : m, n ∈ N}
so that ϕ(x, X )[m; n] is valid iﬀ



N2 |= ∀X
|X | = n ⊃ ϕ(m, X ) .
The formula ϕ(x, X )[m; n] has size bounded by a polynomial p(m, n)
which depends only on ϕ. The free propositional variables in ϕ(x, X )[m;
n] consist of pjXi , for 0 ≤ j < ni − 1 for each ni ≥ 2.
We deﬁne the translation of a bounded L2A formula ϕ inductively, starting with the ΣB0 formulas, which is described in Section VII.2. For the
induction step, consider the case where
ϕ(x, X , Y ) ≡ ∃Y ≤ t (x, X , Y )
(here t is a number term of the form t(x, |X |)). By the induction hypothesis, (x, X , Y )[m; n, k] contains the free propositional variables
Y
is
p0Y , p1Y , . . . for Y , in addition to pjXi (when k < 2, the list p0Y , . . . , pk−2
empty). Deﬁne
r

Y
ϕ(x, X )[m; n] =def ∃p0Y . . . ∃pr−2
(x, X , Y )[m; n, k]
(149)
k=0

where r is the numerical value of t: r = val(t(m, n)) (recall that i is the i-th
numeral). Here the free variables pjY become bound, and if r ≤ 1 then the
Y
Y
is empty. Also, if any of the formulas k (p0Y , . . . , pk−2
)
list p0Y , . . . , pr−2

192

VII. Propositional Translations

is a logical constant ⊥ or , then we simplify ϕ(x, X )[m; n] in the obvious
way.
The case where ϕ(x, X ) ≡ ∀Y ≤ t (x, X , Y ) is similar:
r
Y
ϕ(x, X )[m; n] =def ∀p0Y . . . ∀pr−2

(x, X , Y )[m; n, k].

(150)

k=0

(The conjunction is also simpliﬁed if any conjunct is a Boolean constant.)
The cases of the Boolean connectives ∧, ∨, ¬ or the number quantiﬁers
are the same as for ΣB0 formulas.
Proposition VII.5.1. For each i ≥ 0, if ϕ is a gΣBi (resp. gΠBi ) formula,
q
q
then the formulas in #ϕ# are Σi (resp. Πi ). There is a polynomial p(m, n)
which depends only on ϕ so that ϕ[m; n] has size ≤ p(m, n) for all m, n ∈ N.
The connection between the theory V i and the proof system Gi is as
follows.
Theorem VII.5.2 (V i Translation). Let i ≥ 1. For any bounded theorem ϕ(x, X ) of V i , there is a polytime function F (m, n) such that F (m, n)
is a Gi proof of ϕ(x, X )[m; n], for all m, n ∈ N.
Proof. The proof is similar to that of the Translation Theorem for
V 0 VII.2.3. We consider the case where i = 1; the cases where i > 1
are handled in the same way. By Corollary VI.4.16, for every bounded
 1 proof  of
theorem ϕ(a, α) of V 1 there is a (treelike) anchored LK 2 -V
−→ ϕ(a, α). If we translate each sequent of  into the corresponding
QPC sequent, the result is close to a G1 proof. In particular, since any cut
 1 is ΣB , its translation is a Σq formula, and can be cut
formula in LK 2 -V
1
1

in G1 .
Formally, we will prove by induction on the depth of a sequent S(b, )
in  that there is a polytime function F (m, n) such that F (m, n) is a G1
 1 . The simple
proof of S[m; n]. For the base case, S is an axiom of LK 2 -V
B
axioms are sequents of Σ0 formulas, and these are treated as in the proof
of the Translation Theorem for V 0 . The remaining axioms are instances
of ΣB0 -COMP, so
S = −→ ∃X ≤ t∀z < t(X (z) ↔ (z))
and  is a ΣB0 formula. Let r = val(t). When r ≤ 1, it is easy to see that S
translates into a trivially valid sequent with a short G0 proof. Otherwise,
if r ≥ 2, then S[m; n] is the sequent


−→ ∃X ≤ t∀z < t(X (z) ↔ (z)) [m; n]

VII.5. Propositional Translations for V i

193

where (replace [. . . ] by [m; n]):


X
∃X ≤ t∀z < t(X (z) ↔ (z)) [. . .] ≡ ∃p0X . . . ∃pr−2
r−1
r

 k−2 X

(pi ↔ (i)[. . .]) ∧ (k − 1)[. . . ] ∧
¬(i)[. . . ]
i=0

k=0

i=k

where the conjunct (k − 1) is deleted when k = 0 and the conjuncts
k−2

r−1

(piX ↔ (i)[. . .])

¬(i)[. . . ]

and

i=0

i=k

are deleted when their sets of indices are empty.
Exercise VII.5.3. Let A0 , . . . , A be any PK formulas ( ≥ 0). Show
that the sequent


−→





¬Ai , A0 ∧
i=0

¬Ai , A1 ∧
i=1

¬Ai , . . . , A−1 ∧ ¬A , A
i=2

has a polynomial size treelike cut-free PK derivation.
We get S[m; n] as follows. First we apply the above exercise for  = r −1
and
Ai ≡ (i)[m; n].
Then note that it is straightforward to obtain polynomial size derivations
for the following tautologies:
k−2

((i)[. . .] ↔ (i)[. . .]).
i=0

Now by using the ∧-right and ∨-right rules obtain
−→

r
r−1

 k−2

((i )[. . .] ↔ (i)[. . .]) ∧ (k − 1)[. . . ] ∧
¬(i)[. . . ] .
k=0

i=0

i=k

From this sequent, by repeatedly applying the ∃-right rule we obtain a
polynomial size cut-free G proof of S[m; n].
 1 . In each case,
For the induction step, we consider all rules of LK 2 -V
assume that S is obtained from S1 (and S2 ). We will show that S[. . . ]
has short G1 derivation from S1 [. . . ] (and S2 [. . . ]). It is obvious that the
polytime function F (. . . ) giving the G1 proof of S[. . . ] can be constructed
from the polytime function(s) F1 (. . . ) for S1 (and F2 (. . . ) for S2 ).
All rules (including the IND rule) except for the string quantiﬁer rules
are treated just as in the proof of the Translation Theorem for V 0 (page
170), although now the translation will require cuts on Σqi formulas in
general. We consider the string ∃-introduction rules. The string ∀introduction rules are dual, and are left as an exercise.

194

VII. Propositional Translations

Case string ∃-right. Suppose that S is obtained from S1 by the string
 1 , the only string terms are string variables.
∃-right rule. Note that in V
S1
S

=

Λ() −→ Π(), || ≤ t ∧ ()
Λ() −→ Π(), ∃Z ≤ t

(Z)

We suppress all free variables except for the principle variable . Note that
|| ≤ t[. . . , n] is either  or ⊥. Let r = val(t), then

Λ[. . . , n] −→ Π[. . . , n], ()[. . . , n] if n ≤ r,
(151)
S1 [. . . , n] =def
Λ[. . . , n] −→ Π[. . . , n], ⊥
if n > r.
By deﬁnition (see (149)),
r


Z
S[. . . , n] =def Λ[. . . , n] −→ Π[. . . , n], ∃p0Z . . . ∃pr−2

(Z)[. . . , k].

k=0

Consider the interesting case where n ≤ r, First, by repeated applications of the rules weakening and ∨-right, we obtain from S1 [. . . , n]
Λ[. . . , n] −→ Π[. . . , n],

r


()[. . . , k].

k=0

Then we can derive S[. . . , n] using the rule ∃-right.
Case string ∃-left. Again, suppressing all other free variables:
S1
S

=

|| ≤ t ∧ (), Λ −→ Π
∃Z ≤ t

where  does not occur in S, and
S1 [. . . , n] =def

(Z), Λ −→ Π
is ΣB1 . Let r = val(t), then for n ≤ r,

()[. . . , n], Λ[. . . ] −→ Π[. . . ].

(152)

Also,
S[. . . ] =def

Z
∃p0Z . . . ∃pr−2

r


(Z)[. . . , n], Λ[. . . ] −→ Π[. . . ].

n=0

Now if r = 0, then we are done. Otherwise, combine the sequents
S1 [. . . , n] for n = 0, . . . , r by the rule ∨-left we obtain
r


()[. . . , n], Λ[. . . ] −→ Π[. . . ].

n=0

Thus we get S[. . . ] by r − 1 applications of the ∃-left rule.

2

Exercise VII.5.4. Carry out the cases for the string ∀-introduction
rules.

VII.5. Propositional Translations for V i

195

VII.5.1. Translating V 0 to Bounded Depth G0 . In Section VII.2 we
show that ΣB0 theorems of V 0 translate into families of tautologies with
polynomial-size bounded depth PK proofs. We generalize this and show
here that the translation of every bounded theorem of V 0 has polynomialsize proofs in a subsystem of G0 that extends bPK. First we deﬁne the
system.
Deﬁnition VII.5.5 (Bounded Depth G0 ). For each constant d ∈ N, a
d -G0 proof is a G proof in which all target formulas have depth at most
d and all cut formulas are quantiﬁer-free and also have depth at most d .
A bounded depth G0 system (or just bG 0 ) is any system d -G0 for d ∈ N.
Treelike d -G0 (resp. treelike bG 0 ) is denoted by d -G0 (resp. bG 0 ).
Theorem VII.2.3 is generalized as follows:
Theorem VII.5.6. For any bounded theorem ϕ(x, X ) of V 0 there is a
constant d and a polytime function F (m, n) such that F (m, n) is a d -G0 proof of ϕ(x, X )[m; n], for all m, n ∈ N.
We prove the theorem by translating LK 2 -V 0 proofs (as opposed to the
 0 proofs used in the proof of Theorem VII.2.3). An LK 2 -V 0 proof
LK 2 -V
can have cut formulas which are ΣB1 ; these are instances of the ΣB0 -COMP
axioms. Because in the translation we are not allowed to cut quantiﬁed
formulas, these instances of ΣB0 -COMP will require diﬀerent translations
than the translation described before Proposition VII.5.1.
The main idea is as follows. Consider an instance of ΣB0 -COMP:


∃X ≤ t∀i < t X (i) ↔ (i) .
Instead of introducing quantiﬁed Boolean variables piX for the bits X (i)
of X we will translate X (i) using the translation of (i). For the string
eigenvariable  that introduces X (in a string ∃-left rule) we also translate
(i) using the translation of (i). Now may contain other eigenvariables, so they must be translated ﬁrst.
Recall the notions of anchored proofs (Deﬁnition II.1.12 on page 14)
and free variable normal form (Section II.2.4 on page 23 and Section IV.4.1
on page 90).
Proof. Since ϕ is a theorem of V 0 , there is an anchored LK 2 -V 0 proof 
of ϕ. We can assume that  is in free variable normal form and is treelike.
Note that all cut formulas in  are ΣB1 , and all non-ΣB0 cut formulas
are instances of ΣB0 -COMP axioms. Here we are only interested in the
instances of ΣB0 -COMP that will be cut. Furthermore, we can assume that
all sequents that contain an instance of ΣB0 -COMP in the succedent are
derived from the ΣB0 -COMP axiom by weakenings:
−→ ∃X ∀x < t(X (x) ↔ (x))
===========================
Γ −→ ∃X ∀x < t(X (x) ↔ (x)), Δ

(153)

196

VII. Propositional Translations

Consider an application of the string ∃-left rule that introduces a
ΣB0 -COMP formula:
S1
S2

=

|| ≤ t ∧ ∀x < t((x) ↔

(x)), Γ −→ Δ

∃X ≤ t∀x < t(X (x) ↔

(x)), Γ −→ Δ

(154)

where  does not occur in S2 . Since  is in free normal variable form, each
variable  is used exactly once.
Notation. We say that  as above is a comprehension variable in . The
associated pair t,  as above is called the deﬁning pair of .
The idea is to translate the bit (i) of any comprehension variable 
in  using its deﬁning pair (instead of using new atoms p0 , p1 , . . . as
before). Note that two diﬀerent comprehension variables may have the
same deﬁning pair (for example, comprehension variables that introduce
two identical copies of a ΣB0 -COMP cut formula which are merged in
contraction right or in the branching rules such as ∨ left or ∧ right). In
this case they will have the same translation.
Notation. We say that a comprehension variable  depends on a variable (or b) if (resp. b) occurs in the deﬁning pair of .
Since  is treelike and in free variable normal form, this dependence
relation forms a partial ordering of the comprehension variables. The
deﬁning pair of  may contain other comprehension variables. For example, in (154) (x) might contain a comprehension variable   , where its
corresponding  is in Γ. In this case   must be translated before . This
motivates the following notions.
Notation. The dependence degrees of variables in  are deﬁned as follows. All non-comprehension variables have dependence degree 0. The
dependence degree of a comprehension variable  is one plus the maximum
dependence degree of all variables occurring in its deﬁning pair.
Translation of formulas in . The formulas in  are translated in stages
as follows. In stage 0 we translate all formulas that do not involve any
comprehension variables. Generally, in stage i we translate all formulas
that involve some variables of dependence degree i but no variable of
higher dependence degree. In each stage, the translation is by induction
on the depth of the formulas. Stage 0 is the same as described at the
beginning of Section VII.5.
Consider stage (i + 1) (where i ≥ 0). For the base case, all atomic
formulas have been translated in the previous stage except for atomic
formulas of the form (s), where  has dependence degree (i + 1). For

VII.5. Propositional Translations for V i

197

each such , let
⎧
⎪
⎨ (s)[n]
(s)[n , n] =def 
⎪
⎩
⊥

if j < n − 1,
if j = n − 1,
if j ≥ n

(155)

where t,  is the deﬁning pair for , and j = val(s(n)) (recall val from
page 166).
The induction step is handled as discussed at the beginning of Section VII.5 except for the case of the ΣB0 -COMP cut formulas. Intuitively
these formulas are true, so they should translate into tautologies. In this
case we will show that the tautologies have polynomial size d  -PK  proofs
for some d  . Therefore we will simply delete all sequents on the right
branches of the cut ΣB0 -COMP rule (these are ancestors of a sequent that
contains the cut ΣB0 -COMP formula in its succedent). Also, we will translate all occurrences of the cut ΣB0 -COMP formulas in the antecedents into
the empty formula. This completes the description of our translation.
We leave as an exercise to verify that the translation formulas have
polynomial sizes and constant depths as desired.
Exercise VII.5.7. Show that for each ΣB0 formula (x, X ) in  there is a
constant d1 and a polynomial p that depend on  such that (x, X )[m; n]
have depth at most d1 and size p(m, n), for all m, n. Show that Proposition VII.5.1 continues to hold for non-cut formulas in .
Now we show that for all sequents S of  that are not on the right
branches of a cut ΣB0 -COMP rule, the families S[m; n] have polynomial
size d -G0 proofs, for some constant d .
The base case, where S is a nonlogical axiom in 2-BASIC (Figure 2), is
handled just as in Section VII.2.3, with obvious modiﬁcations when a free
string variable in the axiom is a comprehension variable. The induction
step is the same as in the proof of Theorem VII.5.2 except for the case
where S = S2 as in (154), i.e., where it is obtained by the string ∃-left that
introduces a ΣB0 -COMP cut formula.
So suppose that S2 is obtained from S1 as in (154). Note that for n ≤ v
(where v = val(t))
S1 [m; n , n] =def C [m; n , n], Γ[m; n] −→ Δ[m; n]
where C [. . . ] translates the ﬁrst formula of S1 . Let v = val(t). By
deﬁnition:
v−1

¬ (x)[m, i; n]

C [m; 0, n] =
i=0

(i is the value of x)

198

VII. Propositional Translations

and for 1 ≤ n ≤ v (here let Ai denotes
n −2

C [m; n , n] =

 

(x)[m, i; n]):

v−1

(Ai ↔ Ai ) ∧ An −1 ∧
¬Ai .
i=n

i=0

Here the conjuncts
n −2

v−1

(Ai ↔ Ai )

¬Ai

and
i=n

i=0

are deleted when their sets of indices are empty. Also, by deﬁnition
S2 [m; n] =def Γ[m; n] −→ Δ[m; n].
Using Exercise VII.5.3, we can show (by the same arguments as in the
proof of Theorem VII.5.2 below Exercise VII.5.3) that there are polynomial size cut-free PK proofs of the tautologies:
−→

v


C [m; n , n].

(156)

n =0

Moreover, by Exercise VII.5.7 the above tautologies have depth at most d1
for some d1 depending only on . Therefore the proof of Theorem VII.1.8
shows that (156) have polynomial-size d2 -PK  proofs, where d2 = d1 + 3.
Hence, by using the ∨-left rule for the sequents S1 [m; n , n] (for 0 ≤
n ≤ v) and then applying a cut for the resulting sequent with (156) we
obtain S2 [m; n].
All cut formulas in our translation are either cut formulas in the d2 G0 derivations mentioned above, or the translations of ΣB0 cut formulas
in . Thus they have depth bounded by a constant depending on .
Furthermore, it can be seen that all target formulas are atomic formulas
of the form
piα
for some noncomprehension string variable α. As a result, the translations
of  are d -G0 proofs for some constant d depending on .
2
Exercise VII.5.8. Reprove Theorem VII.2.3 using the translation we
describe in the proof of Theorem VII.5.6.

VII.6. Notes
Deﬁnitions VII.1.2, VII.1.5 and Theorem VII.1.4 are from [46]. Also,
the fact that Frege proof systems are p-equivalent is proved in [46]. Ajtai’s
superpolynomial lower bound for bounded depth Frege proofs of PHP is
published in [5].

VII.6. Notes

199

The ﬁrst propositional translation of an arithmetic theory is described
in [39]. The translation of ΣB0 formulas given in Subsection VII.2.1 is from
[42], and both this and the V 0 Translation Theorem VII.2.3 are based on
the treatment of IΔ0 (R) by Paris and Wilkie [90].
A proof system for the Quantiﬁed Propositional Calculus was introduced by Dowd [48]. The system G and its subsystems Gi were introduced
by Krajı́ček and Pudlák [73] (see also Section 4.6 of [72]). The original
deﬁnition of G is what we refer to as KPG in Exercise VII.3.7 and the
original deﬁnition of Gi is KPG restricted so that all formulas must be either Σqi or Πqi . Our deﬁnitions are due to Morioka [80]. Theorem VII.3.9
is new. Theorem VII.4.8 is from [91].
The idea of Gi (treelike Gi ) is from [72], and the V 1 Translation Theorem VII.5.2 is adapted from a similar theorem for S21 also in [72]. Theorem VII.4.13 is from [41]. Extended Frege proof systems, which inspired
the system ePK in Section VII.4.1, were introduced in [46].
Theorem VII.5.6 is new.

Chapter VIII

THEORIES FOR POLYNOMIAL TIME AND BEYOND

We present a ﬁnitely-axiomatizable “minimal” theory for polynomial time
over the basic two-sorted vocabulary L2A . We show that it is robust by
giving three quite diﬀerent axiomatizations for it under the names VP,
TV 0 , and V 1 -HORN. We also present a universal conservative extension
VPV for this theory which has function symbols for all polynomial time
functions based on Cobham’s recursion-theoretic characterization of FP.
The theory V 1 from Chapter VI has the same ΣB1 theorems as the minimal
theory, but apparently has more ΣB2 theorems. The new theories have the
following inclusions:
 ⊂cons VPV
VP = TV 0 = V 1 -HORN ⊂cons VP
where T1 ⊂cons T2 means that T2 is a conservative extension of T1 .
Section VIII.3 introduces the TV i hierarchy and concentrates on the
bottom level TV 0 mentions above. Section VIII.5 is devoted to TV 1 ,
and characterizes the ΣB1 -deﬁnable search problems in this theory as those
reducible to polynomial local search. Section VIII.6 proves a form of the
Herbrand Theorem known as the KPT Witnessing Theorem, which can
be used to prove (or suggest) independence results for ΣB2 -formulas. As an
application we show that V 0 does not prove the ΣB0 -Replacement scheme,
and (unless integer factoring is easy) neither does VPV.
Section VIII.7 proves a host of results on V ∞ , the interleaved V i and
TV i hierarchies. These include the ﬁnite axiomatizability of V i and TV i ,
ΣBi -deﬁnability results (see Table 3 page 250 for a summary), and the
equivalence of the collapse of these hierarchies and the provable collapse
of the polynomial hierarchy. Section VIII.8 proves ‘RSUV’ isomorphism
theorems relating our two-sorted theories V i and TV i to Buss’s singlesorted theories S2i and T2i .

VIII.1. The Theory VP and Aggregate Functions
The theory VP extends V 0 by adding a single axiom asserting that the
gates of a given monotone Boolean circuit with speciﬁed inputs can be
201

202

VIII. Theories for Polynomial Time and Beyond

evaluated. We will then use the fact that the Monotone Circuit Value
problem is complete for P under many-one AC 0 reductions to prove that
all polynomial time functions are ΣB1 deﬁnable in VP. We will show that
V 1 extends VP, and show that the ΣB1 theorems of V 1 and VP are the same.
Later, in Section VIII.6, we give evidence that VP does not prove either
the ΣB0 -REPL scheme or the ΣB1 -COMP scheme (which do not consist of
ΣB1 formulas), and hence apparently V 1 is not conservative over VP.
It seems that VP is a “minimal” theory for polynomial time reasoning
because it extends our base theory V 0 by adding one axiom asserting the
existence of a solution to a standard complete problem for P. We use
this same method in Chapter IX to introduce minimal theories for other
complexity classes.
We specify a monotone Boolean circuit (using our two-sorted vocabulary L2A ) by a triple (a, G, E), where the gates are numbered 0, 1, . . . , (a −
1), and for x > 1, G(x) holds iﬀ gate x is an ∧ gate (otherwise gate x is
an ∨ gate). Gates numbered 0 and 1 are “input” gates, and always have
the values 0 and 1 respectively. The edge relation E speciﬁes the inputs to
the other gates as follows:
• For 0 ≤ y < x, 2 ≤ x < a, E(y, x) holds iﬀ the output of gate y is
connected to an input of gate x.
The ΣB0 formula MCV (a, G, E, Y ) asserts that Y (x) holds iﬀ the output
of gate x is 1 (i.e. ), and is deﬁned as follows:
MCV (a, G, E, Y ) ≡ ¬Y (0) ∧ Y (1) ∧ ∀x < a, 2 ≤ x ⊃
Y (x) ↔ [(G(x) ∧ ∀y < x(E(y, x) ⊃ Y (y))) ∨
(¬G(x) ∧ ∃y < x(E(y, x) ∧ Y (y)))].

(157)

Deﬁnition VIII.1.1 (VP). The theory VP has vocabulary L2A and is
axiomatized by the axioms of V 0 and one more axiom called MCV ,
where
MCV ≡ ∃Y ≤ a + 2 MCV (a, G, E, Y ).
The next result is immediate from the above deﬁnition and the fact that
V 0 is ﬁnitely axiomatizable (Theorem V.7.1).
Corollary VIII.1.2. VP is ﬁnitely axiomatizable.
Theorem VIII.1.3. V 1 is an extension of VP.
Proof. It suﬃces to show that V 1 proves the axiom MCV . But MCV
is a ΣB1 -formula, and is easily proved by induction on a.
2
Note that MCV is a bounded formula, and hence VP is a polynomialbounded theory (Deﬁnition V.3.3). Thus by Parikh’s Theorem V.3.4 a
function is provably total (i.e. Σ11 -deﬁnable) in VP iﬀ it is ΣB1 -deﬁnable
in VP.

203

VIII.1. The Theory VP and Aggregate Functions
Theorem VIII.1.4. A function is provably total in VP iﬀ it is in FP.

One direction is proved as Theorem VIII.1.8 below, and the other direction is Corollary VIII.1.14.
We introduce a string function FMCV which witnesses the existential
quantiﬁer in the axiom MCV . The deﬁning axiom is
Y = FMCV (a, G, E) ↔ (|Y | ≤ a ∧ MCV (a, G, E, Y )).

(158)

Lemma VIII.1.5. FMCV is ΣB0 deﬁnable in VP.
Proof. We need to show that VP proves
∃!Y (|Y | ≤ a ∧ MCV (a, G, E, Y )).
Existence of Y follows from the axiom MCV . Uniqueness can be proved
in V 0 by induction on i using the ΣB0 formula (i) asserting that the ﬁrst
i bits of Y are uniquely determined.
2
We deﬁne the two-sorted Monotone Circuit Value problem using the
relation RMCV (a, G, E), which holds iﬀ the circuit speciﬁed by (a, G, E)
·
has output 1 (the gate numbered a −
1 is designated the output).
Deﬁnition VIII.1.6.
RMCV (a, G, E) ↔ ∃Y ≤ a(MCV (a, G, E, Y ) ∧ Y (a −· 1)).

(159)

The following proposition shows that RMCV is AC 0 -many-one complete
for P.
Proposition VIII.1.7. For any relation R(x, X ) in P there are functions
a0 , G0 , E0 in FAC 0 such that
R(x, X ) ↔ RMCV (a0 (x, X ), G0 (x, X ), E0 (x, X )).

(160)

Proof sketch. First we point out that Circuit Value Problem CVP
for Boolean circuits which have ¬ gates in addition to ∧ and ∨ gates is
easily reduced to the Monotone Circuit Value Problem MCV by using
the method of “double-rail logic”. Given a circuit C which has gates
for ∧, ∨, ¬ we compute (in FAC 0 ) a monotone circuit C  which has two
inputs x and x  for each input x of C , and two gates g  and g  for every
gate g in C . This is done such that, assuming that each input x  is the
negation of x, then g  ↔ g and g  ↔ ¬g. Given an assignment of inputs
to C , suitable inputs to C  satisfying x  ↔ ¬x can trivially be computed
by an FAC 0 function. To design C  , note that the gate g has one of the
three types ∧, ∨, ¬, and in each case (by De Morgan’s laws) there are easy
monotone circuits which compute both g  and g  from the inputs to g
and their negations.
Now to prove the Proposition it suﬃces to show that, given a polytime
Turing machine M for computing a relation R(x, X ), there is an AC 0
function FM such that FM (x, X ) describes a circuit (allowing ¬ gates and

204

VIII. Theories for Polynomial Time and Beyond

with given input values) whose gate values describe the computation of M
on input x, X .
One way to see how to do this is to consider equation (95) (page 138),
where the variable Z describes the computation of a polytime Turing
machine. Here the rows Z [z] of Z are computed successively using the AC 0
functions InitM and NextM . All AC 0 functions are computed by uniform
circuit families, which themselves are describable by AC 0 functions. 2
Theorem VIII.1.8. Every function in FP is ΣB1 -deﬁnable in VP.
Proof. It suﬃces to prove this for string functions, since by Proposition VI.2.1 every number function f(x, X ) in FP has the form |F (x, X )|
for some string function F in FP, and by Exercise V.4.5 the ΣB1 deﬁnable
functions in VP are closed under composition.
By Deﬁnition V.2.3, a string function F (x, X ) is in FP iﬀ it is p-bounded
and its bit-graph is in P; i.e. there is an L2A term t(x, X ) and a relation
BF (i, x, X ) in P such that


F (x, X )(i) ↔ i < t(x, X ) ∧ BF (i, x, X ) .
(161)
Our task is to ﬁnd a ΣB1 formula ϕF (x, X , Z) representing the graph of F
by satisfying
Z = F (x, X ) ↔ ϕF (x, X , Z)
and such that
VP  ∃!ZϕF (x, X , Z).

(162)

Since the bit graph BF of F is a polytime relation, by (159), (160) there
are functions a0 , G0 , E0 in LFAC 0 such that
BF (i, x, X ) ↔ ∃Y ≤ a0 (i), MCV (a0 (i), G0 (i), E0 (i), Y ) ∧ Y (a0 (i) −· 1)
(163)
where we have suppressed the arguments (x, X ) in a0 , G0 , E0 . We can use
the function FMCV deﬁned in (158) to witness Y in the above equation,
and hence the graph ϕF of F satisﬁes
·
ϕF (x, X , Z) ↔ ∀i < t[Z(i) ↔ FMCV (a0 (i), G0 (i), E0 (i))(a0 (i) −
1)].
(164)

Unfortunately the formula on the right is not ΣB1 , and although the part
in brackets [. . . ] can be made ΣB1 , the existential string quantiﬁer there
requires the Replacement Axiom (Deﬁnition VI.3.2) to move it in front
of the quantiﬁer ∀i < t. In Section VIII.6 we give evidence that VP does
not prove ΣB0 -REPL.
So we use another approach. From (163) we see that for each ﬁxed
i, 0 ≤ i < t, the parameters (a0 (i), G0 (i), E0 (i)) describe a circuit C (i)
which computes bit i of F (x, X ). Our task is to describe one circuit

VIII.1. The Theory VP and Aggregate Functions

205

C = C (x, X ) which combines the circuits C (0), . . . , C (t − 1) to compute
all of these bits together.
In order to do this it will be helpful to introduce the important notion
∗
of FMCV , where the aggregate F ∗ of F
of the aggregate function FMCV
is the string function that gathers the values of F for a polynomially
long sequence of arguments. We use the notation Z [x] = Row(x, Z)
(Deﬁnition V.4.26) and (Z)x = seq(x, Z) (Deﬁnition V.4.31).
Deﬁnition VIII.1.9 (Aggregate Function). Suppose that
F (x1 , . . . , xk , X1 , . . . , Xn )
is a polynomially bounded string function, i.e., for some L2A term t,
|F (x, X )| ≤ t(x, X ).
Then F  (b, Z1 , . . . , Zk , X1 , . . . , Xn ) is the polynomially bounded string
function that satisﬁes
|F  (b, Z, X )| ≤ b, t(|Z|, X )
and
F  (b, Z, X )(w) ↔ ∃i < b∃v < t, w = i, v ∧
F ((Z1 )i , . . . , (Zk )i , X1[i] , . . . , Xn[i] )(v). (165)
Notice that by (165)
∀i < b, F  (b, Z, X )[i] = F ((Z1 )i , . . . , (Zk )i , X1[i] , . . . , Xn[i] ).

(166)

The use of seq in (165) and (166) can be eliminated using its deﬁnition V.4.31 to obtain an equivalent ΣB0 (Row, F ) deﬁnition of the bit graph
of F  , but in general the use of Row cannot be eliminated to get a ΣB0 (F )
deﬁnition.
∗
Lemma VIII.1.10 below shows that the aggregate function FMCV
of
B
∗
FMCV is Σ1 -deﬁnable in VP. We can interpret FMCV as assigning values
to the gates of a collection C (0), . . . , C (b − 1) of circuits. Thus (166)
becomes
∗
∀i < b, FMCV
(b, Z, U, V )[i] = FMCV ((Z)i , U [i] , V [i] )

(167)

and writing
((Z)i , U [i] , V [i] ) = (ai , Gi , Ei )

(168)

we want the the triple (ai , Gi , Ei ) to describe the circuit C (i) which computes bit i of F (x, X ). Thus by (164) we want
((Z)i , U [i] , V [i] ) = (a0 (i), G0 (i), E0 (i)).

206

VIII. Theories for Polynomial Time and Beyond

For this we deﬁne “pseudo-aggregate” functions A1 , G1 , E1 for the functions a0 , G0 , E0 which, for ﬁxed x, X , collect values for arguments i <
t(x, X ). Thus for i < t
(A1 (x, X ))i = a0 (i, x, X ),
G1 (x, X )[i] = G0 (i, x, X ),
E1 (x, X )[i] = E0 (i, x, X ).
Since each of the functions a0 , G0 , E0 is in FAC 0 , it follows easily from
the FAC 0 Elimination Lemma V.6.7 that the functions A1 , G1 , E1 have
ΣB0 -deﬁnable bit graphs and hence are themselves in FAC 0 .
∗
If Y = FMCV
(t, A1 , G1 , E1 ) (where we have suppressed the arguments
[i]
x, X ) then Y gives the correct assignment to the gates of C (i). Thus for
each i < t
F (x, X )(i) ↔ Y [i] (a0 (i, x, X ) −· 1).
So we deﬁne the FAC 0 function Extract by deﬁning its bit graph as
follows:


·
Extract(x, X , Y )(i) ↔ i < t(x, X ) ∧ Y [i] (a0 (i, x, X ) −
1) .
Then
∗
(t, A1 , G1 , E1 ))
F (x, X ) = Extract(x, X , FMCV

(169)

(again suppressing some occurrences of x, X ). This, Lemma VIII.1.10
and the fact that the ΣB1 -deﬁnable functions in a polynomial-bounded
theory are closed under composition (Exercise V.4.5) show that F is ΣB1 deﬁnable in VP.
2
To complete the proof of Theorem VIII.1.8 we need the following result.
∗
∗
is ΣB1 -deﬁnable in VP, and VP(FMCV , FMCV
)
Lemma VIII.1.10. FMCV
proves (167).

Proof. For i < b let C (i) be the circuit described by (ai , Gi , Ei ) as in
(168). We want to embed the circuits C (0), C (1), . . . , C (b − 1) into a
single circuit C . Each C (i) has ai < |Z| gates, and we will be generous
and allot |Z| gates in the embedded version of each C (i), so that C has
a total of b|Z| gates. Thus gate j of C (i) corresponds to gate i|Z| + j
of C .
Circuit C has the description (â, Ĝ , Ê), where â = b|Z| and Ĝ =
Ĝ(b, Z, U ) and Ê = Ê(b, Z, V ) are FAC 0 functions. These functions are
straightforward to deﬁne to satisfy the intended embedding of C (i) into
C , except that the gates in C corresponding to gates 0 and 1 of C (i) must
have constant values 0 and 1 respectively. To achieve this, these gates have
no input edges and we make them OR gates and AND gates respectively.

VIII.1. The Theory VP and Aggregate Functions

207

Thus for i, i  < b
Ĝ(b, Z, U )(i|Z| + j)↔(U [i] (j) ∧ 2 ≤ j) ∨ j = 1 if j < |Z|,
Ê(b, Z, V )(i|Z| + j, i  |Z| + k)↔V [i] (j, k) ∧ i = i  ∧ 2 ≤ k if j, k < |Z|.
This is easily turned into ΣB0 -deﬁnitions of the bit graphs of Ĝ and Ê.
Referring to (167), it remains to deﬁne an FAC 0 function Compile(b, Z,
Y ) whose i-th row assigns correct values to the gates of C (i), assuming
that Y assigns correct values to the gates of C . Thus


Compile(b, Z, Y )(i, j) ↔ i < b ∧ j < (Z)i ∧ Y (i|Z| + j) .
Finally
∗
FMCV
(b, Z, U, V ) = Compile(FMCV (b|Z|, Ĝ (b, Z, U ), Ê (b, Z, V )))
(170)

and (167) is provable from this equation and the deﬁning axioms for the
∗
is a composition of ΣB1 -deﬁnable functions
functions involved. Also FMCV
B
2
in VP, and hence is itself Σ1 -deﬁnable in VP.
To prove the converse to Theorem VIII.1.8 we introduce a universal
conservative extension of VP in the next subsection.
 Let  
VIII.1.1. The Theory VP.
MCV (a, G, E, Y ) denote a quantiﬁer0
free formula in the vocabulary LFAC 0 which V proves equivalent to

MCV (a, G, E, Y ) (see Lemma V.6.3). The function FMCV
has deﬁning
axiom


(a, G, E) ↔ |Y | ≤ a ∧ MCV
(a, G, E, Y ).
Y = FMCV

(171)


Thus FMCV (deﬁned in (158)) and FMCV
are equal as functions, although
they have diﬀerent deﬁning axioms.

 The universal theory VP
 has vocabulary
Deﬁnition VIII.1.11 (VP).

LVP
c = LFAC 0 ∪ {FMCV }
0


and axioms those of V together with the deﬁning axiom (171) for FMCV
.

Since FMCV is in FP and every function in LFAC 0 is in FP, it is clear that
 represents a function in FP. The next
every term in the vocabulary of VP
result states the converse.
Theorem VIII.1.12. Every function in FP is represented by a term in the

vocabulary of VP.
∗
Proof. Equation (170) expresses FMCV
as a term involving FMCV and
functions in LFAC 0 , and equation (169) (ﬁnishing the proof of Theorem VIII.1.8) expresses an arbitrary string function F in FP as a term
∗
involving FMCV
and functions in LFAC 0 . By Proposition VI.2.1 every
number function f(x, X ) in FP has the form |F (x, X )| for some string
function F in FP.
2

208

VIII. Theories for Polynomial Time and Beyond

 is a universal conservative extension
Theorem VIII.1.13. The theory VP
of VP.

 by
(a, G, E)) is provable in VP
Proof. The formula MCV (a, G, E, FMCV

(171) and implies the axiom MCV for VP, and hence VP is an extension
of VP.
0
0
VP + V is conservative over VP because V is conservative over V 0
 can be obtained from VP+V 0 by adding the deﬁning
(Theorem V.6.5). VP
0


axiom for FMCV
, and FMCV
is deﬁnable in VP + V by Lemma VIII.1.5
0
(note that V proves the equivalence of the deﬁning axioms for FMCV and

 is conservative over VP + V 0 and
). Thus by Theorem V.4.2, VP
FMCV
hence over VP.
2
1

Corollary VIII.1.14. Every function Σ -deﬁnable in VP or VP is in FP.
1

 stands for a function in
Proof. As observed above every term of VP
 is a universal theory, it follows from the Herbrand Theorem
FP. Since VP
 can be witnessed
that the existential quantiﬁers in any Σ11 theorem of VP
by a combination of terms and hence by functions in FP (see Section V.6.1
0
for this argument applied to V ). Therefore every Σ11 -deﬁnable function in
 is in FP. Since VP
 is an extension of VP, the same is true of VP. 2
VP
 proves the ΣB (L c )-IND and ΣB (L c )-COMP
We wish to show that VP
0
0
VP
VP

schemes. Note that Lemma VIII.1.10 easily follows from the fact that VP
)-COMP,
and
to
prove
this
scheme
we
need
a
general
reproves ΣB0 (LVP
c
sult about aggregate functions which will also play an important role in
Chapter IX.
Theorem VIII.1.15 (Aggregate Function). Let T be a theory with vocabulary L which extends V 0 (Row) and proves ΣB0 (L)-COMP. Suppose
that F and F  are deﬁnable in T (Deﬁnition V.4.1) and T (F, F  ) proves
(166). Then T (F ) proves ΣB0 (L ∪ {F })-COMP.
Proof. Since T proves ΣB0 (L)-COMP, by Lemma V.4.25 it proves the
Multiple Comprehension axioms for ΣB0 (L).
Claim. For any L-terms s, T that contain variables z, T (F ) proves
∃Y ∀z1 < b1 . . . ∀zm < bm , Y [z] = F (s, T )

(172)

where Y [z] denotes Y [z] .
Proof of the Claim. Since T proves the Multiple Comprehension axiom scheme for ΣB0 (L) formulas, it proves the existence of X such that
Xj[z] = Tj , for 1 ≤ j ≤ n. It also proves the existence of Zi such that
(Zi )z = si , for 1 ≤ i ≤ k. Now the value of Y that satisﬁes (172) is just
2
F  (b, Z, X ).

VIII.1. The Theory VP and Aggregate Functions

209

Let L = L ∪ {F }. We show by induction on the quantiﬁer depth of a
that T (F ) proves

ΣB0 (L ) formula

∃Z ≤ b1 , . . . , bm ∀z1 < b1 . . . ∀zm < bm (Z(z) ↔
where z are all free number variables of

(z))

(173)

. It follows that

T (F )  ΣB0 (L )-COMP.
For the base case,
is quantiﬁer-free. The idea is to replace every
occurrence of a term F (s, T ) in by a new string variable W which has
the intended value of F (s, T ). The resulting formula is ΣB0 (L), and we
can apply the hypothesis.
Formally, suppose that F (s1 , T1 ), . . . , F (sk , Tk ) are all occurrences of F
in . Note that the terms si , Ti may contain z as well as nested occurrences
of F . Assume further that these F -terms are ordered by depth so that
s1 , T1 do not contain F , and for 1 < i ≤ k, any occurrence of F in si , Ti
must be of the form F (sj , Tj ), for some j < i. We proceed to eliminate
F from by using its deﬁning axiom.
−
→
−
→
Let W1 , . . . , Wk be new string variables. Let s1 = s1 , T1 = T1 , and for
−
→
−
→
2 ≤ i ≤ k, si and Ti be obtained from si and Ti respectively by replacing
every maximal occurrence of any F (sj , Tj ), for j < i, by Wj[z] . Thus F
−
→
−
→
−
→
−
→
does not occur in any si and Ti , but for i ≥ 2, si and Ti may contain
W1 , . . . , Wi−1 .
By the Claim above, for 1 ≤ i ≤ k, T (F ) proves the existence of Wi
such that
−
→ −
→
∀z1 < b1 . . . ∀zm < bm , Wi[z] = F ( si , Ti ).
(174)
Let  (z, W1 , . . . , Wk ) be obtained from (z) by replacing each maximal
occurrence of F (si , Ti ) by Wi[z] , for 1 ≤ i ≤ k. Then
T  ∃Z ≤ b1 , . . . , bm ∀z1 < b1 . . . ∀zm < bm (Z(z) ↔


(z, W1 , . . . , Wk )).

Such Z satisﬁes (173) when each Wi is deﬁned by (174).
The induction step is straightforward. Consider for example the case
(z) ≡ ∀x < t(z, x). By the induction hypothesis,
T (F )  ∃Z  ∀z1 < b1 . . . ∀zm < bm ∀x < t, Z  (z, x) ↔ (z, x).
Now
V 0  ∃Z∀z1 < b1 . . . ∀zm < bm , Z(z) ↔ ∀x < tZ  (z, x)
and hence T (F )  ∃Z∀z < b (Z(z) ↔ (z)).
2
B
B
 proves the Σ (L c )-IND and Σ (L c )Corollary VIII.1.16. VP
0
0
VP
VP
COMP axioms.

210

VIII. Theories for Polynomial Time and Beyond
0


. Then
Proof. In Theorem VIII.1.15 take T = VP ∪V and F = FMCV
B
L = LFAC 0 so T proves Σ0 (L)-COMP by Lemma V.6.4. Also T proves the

deﬁning equations (158) and (171) for FMCV and FMCV
are equivalent,

so by Lemmas VIII.1.5 and VIII.1.10 F and F are ΣB1 -deﬁnable in T ,
and T (F, F  ) proves (166). Thus the corollary follows from the theorem,
 = T (F ) (and V 0 proves ΣB -IND).
since VP
2
0
)
represent
precisely
the
polynomial
time
Note that the formulas ΣB0 (LVP
c
relations, so Corollary VIII.1.16 together with Theorem VIII.1.4 suggest
 (and hence VP) “capture” polynomial time reasoning. Also VP
that VP
seems to be a minimal such theory (relative to the base theory V 0 ), since
surely polynomial time reasoning should be able to prove the basic axiom
MCV, that the monotone circuit value problem is complete for P. In
the next sections we will also prove that VP is a robust theory, by giving
several equivalent axiomatizations for it.

VIII.2. The Theory VPV
The universal theory VPV is based on the single-sorted theory PV [39],
which historically was the ﬁrst theory designed to capture polynomial time
 and (unlike VP)
 it has a function
reasoning. It is an extension of VP,
symbol (and not just a term) for every string function in FP. We will
 The vocabulary of
show that VPV is a conservative extension of VP.
0
VPV extends that of V , with additional function symbols introduced
based on Cobham’s characterization of FP (Theorem VI.2.12).
Following Deﬁnition VI.2.11, we can write the deﬁning equations for a
string function F (y, x, X ) deﬁned by limited recursion from G(x, X ) and
H (y, x, X , Z) as
F (0, x, X ) = G(x, X ),
F (y + 1, x, X ) = (H (y, x, X , F (y, x, X )))<t(y,x,X )

(175)
(176)

where the bounding term t(y, x, X ) is in L2A and the notation Z <y refers
to Cut(y, Z) (the ﬁrst y bits of Z, page 139).
For convenience we repeat the deﬁning axiom (86) for the functions
0
Fϕ(z),t introduced in Section V.6 to deﬁne V .


Fϕ(z),t (x, X )(z) ↔ z < t(x, X ) ∧ ϕ(z, x, X ) .
(177)
Deﬁnition VIII.2.1. The vocabulary LFP is the smallest set that satisﬁes
(1) LFAC 0 ⊆ LFP .
(2) For each open formula ϕ(z, x, X ) over LFP and term t = t(x, X ) of
L2A there is a string function Fϕ(z),t in LFP .

211

VIII.2. The Theory VPV

(3) For each triple G, H, t, where G(x, X ) and H (y, x, X , Z) are functions in LFP and t = t(y, x, X ) is a term in L2A , there is a function
FG,H,t in LFP (with deﬁning equations (175), (176)).
To simplify this deﬁnition we have not introduced new number functions of the from fϕ(z),t that were used along with Fϕ(z),t in the inductive
deﬁnition of LFAC 0 (although by 1) everything in LFAC 0 remains in LFP ).
Nevertheless by Cobham’s Theorem it is easy to see that semantically the
string functions of LFP comprise the polytime string functions in FP. In
particular every string term T over LFP is represented by a function symbol of the form Fϕ(z),t in LFP , where (referring to (177)) ϕ ≡ T (z) and t
is a suitable bounding term. Note also that every number function in FP
has the form |F | for some function F in LFP .
0
We now deﬁne the theory VPV in the style of Deﬁnition V.6.2 of V .
Deﬁnition VIII.2.2. VPV is the theory over LFP whose axioms are
0
those of V together with the deﬁning axioms (177) for each function
Fϕ(z),t in LFP and deﬁning axioms (175), (176) for each function FG,H,t in
LFP .
0

Thus VPV is a universal theory which extends V . Every function
introduced in Deﬁnition VIII.2.1 is explicitly bounded by a term in L2A ,
and hence VPV is a polynomial-bounded theory.
The following general result can be proved by structural induction on
ϕ in the same way as Lemma III.3.19 and Lemma V.6.3. Our immediate
intended application is to take T = VPV.
Lemma VIII.2.3. Let T be a theory with vocabulary L such that T extends
V 0 and for every open formula ϕ(z, x, X ) over L and term t(x, X ) over L2A
there is a function Fϕ(z),t in L such that
T  Fϕ(z),t (x, X )(z) ↔ (z < t ∧ ϕ(z, x, X )).
Then for every ΣB0 (L) formula ϕ there is an open L-formula ϕ + such that
T  ϕ ↔ ϕ+.
Next we state a general witnessing theorem for universal theories, which
applies to VPV.
Theorem VIII.2.4 (Witnessing). Let T be a universal polynomial-bounded theory which extends V 0 , with vocabulary L, such that for every open
formula ϕ(z, x, X ) over L and term t(x, X ) over L2A there is a function
Fϕ(z),t in L such that


T  Fϕ(z),t (x, X )(z) ↔ z < t ∧ ϕ(z, x, X ) .
Then for every theorem of T of the form ∃Zϕ(x, X , Z), where ϕ is an open
formula, there is a function F in L such that
T  ϕ(x, X , F (x, X )).

212

VIII. Theories for Polynomial Time and Beyond

Proof. The proof is based on the Herbrand Theorem, and is very
similar to the alternative proof of the witnessing theorem for V 0 given in
Section V.6.1. This proof deﬁnes the witnessing function F by cases, and
in fact F has the form Fϕ(z),t for suitable ϕ, t. By our assumption that
T is polynomial-bounded, we know that there is a bounding term t for
Fϕ(z),t in L2A (as opposed to L).
2
Corollary VIII.2.5 (Witnessing for VPV). Every Σ11 (LFP ) theorem of
VPV is witnessed in VPV by functions in LFP .
Proof. It is clear that VPV satisﬁes the hypotheses for the theory T in
the theorem. Although the theorem only states that formulas of the form
∃Zϕ (where ϕ is quantiﬁer-free) can be witnessed, it is easy to generalize
it to witness an arbitrary Σ11 (LFP ) formula ∃z∃Zϕ. (See Lemma V.5.5
2
and how it is used to prove the witnessing theorem for V 0 .)
This witnessing result immediately implies the following.
Corollary VIII.2.6. Every function Σ11 -deﬁnable in VPV is in FP.
Of course this holds whether we interpret Σ11 -deﬁnable to mean Σ11 (L2A )deﬁnable, or more generally Σ11 (LFP )-deﬁnable. The converse of the latter,
that every polytime function is Σ11(LFP )-deﬁnable in VPV, is obvious, since
LFP comprises the polytime functions. However we are interested in the
stronger converse, that every LFP -function has a ΣB1 (L2A ) deﬁnition, provably in VPV. This is not straightforward to prove, mainly because we do
not have the ΣB0 -REPL axioms available in VPV (Theorem VIII.6.3). Section VI.3.1 shows how we could proceed if ΣB0 -REPL were available, and
Theorem IX.2.10 shows how we could proceed using aggregate functions.
But here we take a diﬀerent approach: Since V 1 proves the ΣB0 -REPL
axioms it is relatively easy to show that every LFP function is ΣB1 (L2A )deﬁnable in V 1 . From this we use the fact that ΣB1 theorems of V 1 are
witnessed in VPV to get our desired result (Theorem VIII.2.15).
The next result is proved in the same way as Lemma V.6.4.
Lemma VIII.2.7. VPV proves the ΣB0 (LFP )-COMP,
B
Σ0 (LFP )-MIN, and ΣB0 (LFP )-MAX axiom schemes.

ΣB0 (LFP )-IND,

Deﬁnition VIII.2.8 (ΔBi Formula). Let T be a theory over L ⊇ L2A .
We say that a formula ϕ is ΔBi (L) in T if there is a ΣBi (L) formula ϕ1 and
a ΠBi (L) formula ϕ2 such that T  ϕ ↔ ϕ1 and T  ϕ ↔ ϕ2 .
Corollary VIII.2.9. If ϕ is ΔB1 (LFP ) in VPV then VPV  ϕ ↔ ϕ0 for
some open LFP -formula ϕ0 .
Proof. Suppose that ϕ is ΔB1 (LFP ) in VPV, and let ϕ1 and ϕ2 be as
in the deﬁnition. Then using pairing functions we may assume that ϕ1
and ϕ2 each have single string quantiﬁers, so for some ΣB0 (LFP )-formulas

VIII.2. The Theory VPV
1,

213

2 we have

ϕ1 ≡ ∃Y ≤ t1

1 (x, X , Y ),

ϕ2 ≡ ∀Z ≤ t2

2 (x, X , Z).

Since VPV  ϕ2 ⊃ ϕ1 we have
VPV  ∃Y ∃Z,

2 (x, X , Z) ⊃

1 (x, X , Y ).

By Corollary VIII.2.5 there are FP-functions F and G such that
VPV 

2 (x, X , F (x, X )) ⊃

1 (x, X , G(x, X )).

Then VPV  ϕ ↔ ϕ0 , where ϕ0 ≡ 1 (x, X , G(x, X )). By Lemma
VIII.2.3 we may assume 1 is an open LFP -formula, as required.
2
VIII.2.1. Comparing VPV and V 1 . Here we prove that every L2A -theorem of VPV is provable in V 1 . We also prove a partial converse, that
every Σ11 theorem of V 1 is provable in VPV. In Section VIII.6 we show
evidence that not all ΣB2 theorems of V 1 are provable in VPV.
We establish the ﬁrst assertion by deﬁning an extension V 1 (VPV) of
both V 1 and VPV, and showing that it is conservative over V 1 . We
establish the partial converse by showing that every Σ11 theorem of V 1 can
be, provably in VPV, witnessed by functions in LFP .
Deﬁnition VIII.2.10. For i ≥ 1, the theory V i (VPV) has vocabulary
LFP , and axioms the union of the axioms for V i and for VPV.
Theorem VIII.2.11. (a) Every function in LFP is ΣB1 -deﬁnable in V 1 .
(b) For i ≥ 1, every ΣBi (LFP )-formula is provably equivalent in V 1 (VPV)
to a ΣBi (L2A )-formula.
(c) For i ≥ 1, V i (VPV) is conservative over V i .
Corollary VIII.2.12. For i ≥ 1, V i (VPV) proves the ΣBi (LFP )-COMP,
B
Σi (LFP )-IND, ΣBi (LFP )-MIN, and ΣBi (LFP )-MAX axiom schemes.
Proof. The corollary follows immediately from part (b) of the theorem,
since by Corollary V.1.8 V i proves these schemes for ΣBi (L2A )-formulas. 2
Proof of Theorem VIII.2.11. Part (a) of the Theorem is essentially
proved in Subsection VI.2.2. Part (b) for general i follows immediately
from the case i = 1. Now parts (b) and (c) follow from Corollary VI.3.11,
where we take T0 to be V 1 (Row), or V i (Row) for part (c) (we can get rid
of the function Row by Lemma V.4.27), and the extensions T1 , T2 , . . . are
introduced by successively adding the functions in LFP and their deﬁning
axioms. The fact that the new function introduced in Ti+1 is Σ11 -deﬁnable
in Ti (and even in T0 ) is proved in Section VI.2.2.
2
Theorem VIII.2.13. Every Σ11 (LFP ) theorem of V 1 (VPV) is witnessed in
VPV by functions in LFP .

214

VIII. Theories for Polynomial Time and Beyond

Proof. A slight modiﬁcation of the proof of the Witnessing Theorem
for V 1 given in Section VI.4.2 proves this theorem. Note that every
witnessing function introduced is in FP, and, noting that VPV proves
ΣB0 (LFP )-IND (by Lemma VIII.2.7), we see that VPV proves the desired
sequents.
2
The following corollary is immediate from Theorem VIII.2.13.
Corollary VIII.2.14. VPV and V 1 (VPV) have the same Σ11 (LFP ) theorems.
In particular, every ΣB1 theorem of V 1 is provable in VPV. From this
and Corollary VIII.2.6 and part (a) of Theorem VIII.2.11 we have the
following:
Theorem VIII.2.15 (Σ11 -Deﬁnability for VPV). A function is Σ11 (L2A )deﬁnable in VPV iﬀ it is in FP.
Finally, from Corollary VIII.2.14 and part (b) of Theorem VIII.2.11
we have
Theorem VIII.2.16. Every ΣB1 (LFP )-formula is provably equivalent in
VPV to a ΣB1 (L2A )-formula.
VIII.2.2. VPV Is Conservative over VP.
 and VP.
Theorem VIII.2.17. VPV is a conservative extension of VP
Proof. By deﬁnition the vocabulary and axioms of VPV include the
0

vocabulary and axioms of V . Also it is easy to see that FMCV
can be
deﬁned from functions in LFAC 0 using limited recursion (175), (176), and
its deﬁning axiom (171) is provable in VPV from these recursion equations

using induction (Lemma VIII.2.7). Therefore VPV is an extension of VP
(and VP).
 and hence by TheoWe now show that VPV is conservative over VP,
rem VIII.1.13 over VP. The functions of LFP can be introduced successively, each one either by a ΣB0 bit deﬁnition or by limited recursion, in
terms of previously-deﬁned functions. Thus VPV is the union of theories
Ti satisfying
T 0 ⊂ T1 ⊂ T2 ⊂ · · ·

(178)

 and for i > 0 each Ti is obtained from Ti−1 by adding the
where T0 is VP
deﬁning equation for one new function Fi . We show by induction on i
 by a ΣB (L c )-formula
that each new string function Fi is deﬁnable in VP
0
VP
αFi (x, X , Y ) satisfying
Z = Fi (x, X ) ↔ αFi (x, X , Z).

(179)

Also Ti−1 together with (179) prove the original deﬁning axiom for Fi
in Ti .

This shows that each Ti is conservative over Ti−1 , and hence Ti is

conservative over VP.

VIII.2. The Theory VPV

215

Setting F ≡ Fi , the formula αF in (179) for a general string function
F (x, X ) is based on a family of Boolean circuits CF (n1 , n2 ) which compute
F , where n1 is an upper bound on the length of each argument in (x, X )
and n2 is an upper bound on |F (x, X )|. The circuit expects unary notation
for the number inputs, so n1 ≥ xi for each xi in x and n1 ≥ |Xi | for each
Xi in X . CF (n1 , n2 ) is described by a triple
(aF (n1 , n2 ), GF (n1 , n2 ), EF (n1 , n2 ))
0

of FAC functions, using the (a, G, E) notation explained in Section
VIII.1. The circuit is monotone, and is based on the “double-rail logic”
described in the proof sketch of Proposition VIII.1.7, so each of the inputs in (x, X ) must be presented twice; once using the expected bit string
and once as the string of negations of those bits. In fact CF expects its
inputs to be the values of gate numbers 2, 3, . . . , 2n1 kF + 1, where kF is
the number of input variables in x, X (recall that gates 0 and 1 always
have the constant values 0 and 1 respectively).
Let the L2A term tF (n1 ) be an upper bound on |F (x, X )|, when n1 is an
upper bound on each of the input lengths x, X , and let the L2A term gF (n1 )
be an upper bound on the number of “computing” gates in CF (n1 , n2 ),
not counting gates used for inputs and outputs. Then there are 2n2 output
gates right after the computing gates, which store both F (x, X ) and the
negations of these bits.
The FAC 0 output function Out(c, d, Y ) extracts bits c through d −· 1
·
of Y (bits Y (c), Y (c + 1), . . . , Y (d −
1)), so


Out(c, d, Y )(i) ↔ c ≤ i ∧ i + 1 ≤ d ∧ Y (i) .
The FAC 0 input function InF (n1 , x, X , E) = E  augments the edge relation E for CF , so E  is the same as E except edges from gates 0 and 1
to the input gates 2, 3, . . . , 2n1 kF + 1 are set so that these gates code the
values x, X . Thus

F (x, X ) = Out c, d, FMCV (aF (n1 , n2 ), GF (n1 , n2 ),

InF (n1 , x, X , EF (n1 , n2 ))) (180)
where
n1 = max{x, |X |},
n2 = tF (n1 ),
aF (n1 , n2 ) = 1 + 2n1 kF + gF (n1 ) + 2n2 ,
c = 2n1 kF + gF (n1 ) + 2,
d = c + 2n2 .
Notice that (180) (with the speciﬁed LFAC 0 terms for the variables other
than x, X ) expresses F (x, X ) as a term of LVP
c.

216

VIII. Theories for Polynomial Time and Beyond

Now the formula αFi in (179) (with F ≡ Fi ) is given by
αF (x, X , Z) ≡ ∀j < t, Z(j) ↔ T (j)

(181)

where the term T is the RHS of equation (180), and the quantiﬁer bound
t(x, X ) is tF (max{x, |X |}).
It remains to show that we can deﬁne the triple aF , GF , EF of FAC 0
functions specifying the circuits CF (n1 , n2 ) for every function F (or f) in
 proves their deﬁning axioms (in terms of earlier
LFP , in such a way that VP
functions). In order to show this, we follow Deﬁnition VIII.2.1, specifying
LFP . We start with LFAC 0 . The initial functions in L2A ∪ {pd, fSE } have
straightforward circuits (recall that the number inputs for +, ×, pd are
given in unary notation). After that functions are introduced successively
using parts (2) and (3) of the deﬁnitions of LFAC 0 and LFP , where part
(2) introduces functions Fϕ,t and (in the case of LFAC 0 ) fϕ,t , where ϕ
is a a quantiﬁer-free formula involving previously-deﬁned functions, and
part (3) introduces the function FG,H,t deﬁned from G and H by limited
recursion, where G, H are previously-deﬁned.
To illustrate how to build circuits for new functions in terms of old
functions we consider a simple example of composition. Suppose
F (x, X ) = H (K(x, X ))

(182)

and suppose that we have a circuits CK speciﬁed by (aK , GK , EK ) computing K, and circuits CH speciﬁed by (aH , GH , EH ) computing H , where
all functions are in FAC 0 . Then we can combine these circuits to form CF
by placing CK in its original position and adding 2n1 kK + gK (n1 ) to each
gate number of CH , so that the input gates of the shifted CH coincide with
the output gates of CK . Now FAC 0 descriptor functions (aF , GF , EF ) for
CF are easily bit-deﬁned by ΣB0 formulas in terms of (aK , GK , EK ) and
(aH , GH , EH ). In particular the size of CF is given by
aF (n1 , n2 ) = aK (n1 , tK (n1 )) + aH (tK (n1 ), n2 ).
Note that if the composition (182) is more complicated, say F = H (K1 ,
K2 ), then to describe the circuit CF for F the circuit CK2 for K2 needs
to be shifted and the original inputs x, X need to be copied to the input
gates for the shifted CK2 , and the outputs for both CK1 and CK2 need to be
copied to the inputs for the shifted CH . But all this is easily accomplished
with FAC 0 functions, using the techniques developed in Section VIII.1.
Each new function F introduced via circuits has a deﬁnition given by
(179) and (181) and hence satisﬁes (180). However the theory Ti in the
sequence (178) should be able to prove the deﬁning axioms for F as given
in Deﬁnition VIII.2.2 for VPV. A simple example is when F ≡ Fϕ,t and
ϕ(z) ≡ H (K(x, X ))(z).

VIII.3. TV 0 and the TV i Hierarchy

217

In this case we may assume as an induction hypothesis that Ti proves
(180) when F is replaced by either H or K, and since Ti (F ) deﬁnes F by
combining the circuits for H and K as explained above we may assume
that Ti (F ) proves (180) as it stands. We must show that Ti (F ) proves
(182), which amounts to showing that the combined circuits for H and K
compute their composition, as intended.
The main lemma needed for this and similar correctness proofs is
roughly that if C and C  are two circuits, and gates a  , . . . , b  of C 
are the same as gates a, . . . , b of C but with their numbers shifted by a
constant c, and if Y and Y  are correct assignments to C and C  respectively (i.e. (157) (page 202) holds), and if Y and Y  agree on the ‘inputs’
to C and C  , then Y (i) ↔ Y (i + c) for a ≤ i ≤ b. This kind of lemma
0
can be proved in V by induction on a ΣB0 (LFAC 0 ) formula.
In case the new function F is introduced by limited recursion, then
F ≡ FG,H,t , and F, G, H satisfy (175) and (176) (page 210). The circuit
CF (n1 , n2 ) for F is built by combining the circuit CG (n1 , n2 ) for G with n1
shifted copies of the circuit CH (max{n1 , n2 }, n2 ) for H , interleaved with
circuits computing the sequence of values 0, 1, . . . , (n1 − 1) for the ﬁrst
argument for H .
The output of CG is F (0) (i.e. F (0, x, X )), and successive outputs of the
shifted circuits CH comprise the sequence F (1), . . . , F (n1 ). The output
gates for CF select from this sequence of outputs the correct output F (y)
based on the input argument y. Thus the i-th output gate of CF is an OR
of AND-gates, where the j-th AND-gate has one input from the i-th bit
of F (j) and the other input from a selector gate which is on iﬀ y = j.
This selector gate is the AND of bit j of the input y (which is presented
in unary) and bit j + 1 of the negated bits of y (which are also part of the
input to CF ).
2
Corollary VIII.2.18. V 1 is ΣB1 -conservative over VP.
Proof. This is immediate from Theorem VIII.2.17 and Corollary
VIII.2.14.
2

VIII.3. TV 0 and the TV i Hierarchy
We now introduce the TV i hierarchy, where for i > 0 TV i is the twosorted version of Buss’s [20] single-sorted theory T2i . For i = 0 it turns
out that TV 0 = VP, although the two theories have very diﬀerent axioms.
For i ≥ 0 the theory TV i is the same as V i , except instead of the
B
Σi -COMP axioms we introduce the ΣBi “string induction” axiom scheme.
Here we view a string X as the number i X (i)2i , and deﬁne the string

218

VIII. Theories for Polynomial Time and Beyond

zero ∅ (empty string) and string successor function S(X ) as in Example V.4.17. Thus S(X ) has ΣB0 -bit deﬁnition
S(X )(i) ↔ ϕSbit (i, X )

(183)

where
ϕSbit (i, X ) ≡ i ≤ |X | ∧ [(X (i) ∧ ∃j < i¬X (j)) ∨ (¬X (i) ∧ ∀j < iX (j))].
Deﬁnition VIII.3.1 (String Induction Axiom). If Φ is a set of formulas, then the string induction axiom scheme, denoted Φ-SIND, is the set
of all formulas
[ϕ(∅) ∧ ∀X (ϕ(X ) ⊃ ϕ(S(X )))] ⊃ ϕ(Y )

(184)

where ϕ(X ) is in Φ, and may have free variables other than X .
Since we want the theories TV i to have underlying vocabulary L2A ,
in case Φ has vocabulary L2A we will interpret (184) as a formula over
L2A , using the standard method of eliminating ΣB0 -bit-deﬁnable function
symbols (Lemma V.4.15).
Deﬁnition VIII.3.2. For i ≥ 0, TV i is the theory over L2A with axioms
those of V 0 together with the ΣBi -SIND scheme.
Although the induction scheme (184) has an unbounded string quantiﬁer, it is easy to see that the theory TV i remains the same if that quantiﬁer ∀X is replaced by the bounded quantiﬁer ∀X ≤ |Y | (see Exercise III.1.16). Hence TV i is a polynomial-bounded theory, axiomatized
by ΣBi+1 -formulas.
Lemma VIII.3.3. For i ≥ 0, TV i proves ΣBi -IND.
Proof. We are to show that TV i proves
[ϕ(0) ∧ ∀x(ϕ(x) ⊃ ϕ(x + 1))] ⊃ ϕ(z)
where ϕ(x) is ΣBi .
We need the following easily veriﬁed fact:
V 0  (|S(X )| = |X | ∨ |S(X )| = |X | + 1).

(185)

Reasoning in TV i , assume
[ϕ(0) ∧ ∀x(ϕ(x) ⊃ ϕ(x + 1))].
From this and (185) we conclude
[ (∅) ∧ ∀X ( (X ) ⊃

(S(X )))]

where (X ) ≡ ϕ(|X |). Hence (Xz ) follows by ΣBi -SIND, where Xz is a
string with length z. Hence ϕ(z).
2

VIII.3. TV 0 and the TV i Hierarchy

219

Theorem VIII.3.4. For i ≥ 0, V i ⊆ TV i .
Proof. We generalize Deﬁnition VI.4.6 to deﬁne Ṽ i to be V 0 +ΣBi -IND.
The proof of Theorem VI.4.8 easily generalizes to show V i = Ṽ i . Hence
the theorem follows from Lemma VIII.3.3.
2
Just as V i proves the number minimization and maximization axioms
for ΣBi -formulas (Corollary V.1.8), TV i proves the stronger string minimization and maximization axioms for ΣBi -formulas. First, we deﬁne the
ordering relation for strings.
Deﬁnition VIII.3.5 (String Ordering). The string relation X ≤ Y has
deﬁning axiom
X ≤ Y ↔ [X = Y ∨ (|X | ≤ |Y | ∧ ∃z ≤ |Y | (Y (z) ∧ ¬X (z) ∧
∀u ≤ |Y |, z < u ⊃ (X (u) ⊃ Y (u))))].

(186)

Often our vocabularies do not contain extra relation symbols outside
L2A . Thus the syntactic formula X ≤ Y will be an abbreviation for the
RHS of Equation (186). Also, X < Y stands for X ≤ Y ∧ ¬(X = Y ).
Exercise VIII.3.6. Show that the following are theorems of V 0 (where
∅, S, + are deﬁned in Example V.4.17):
(a) X ≤ Y ∨ Y ≤ X (X ≤ Y is a total order).
(b) (X ≤ Y ∧ Y ≤ X ) ⊃ X = Y (X ≤ Y is irreﬂexive).
(c) ∅ ≤ X .
(d) X ≤ Y ↔ X + Z ≤ Y + Z.
(e) X < Y ⊃ S(X ) ≤ Y .
For a string term T , we deﬁne ∃X ≤ T ϕ(X ) as an abbreviation for
∃X (X ≤ T ∧ ϕ(X )). Similarly, ∀X ≤ T ϕ(X ) is an abbreviation for
∀X (X ≤ T ⊃ ϕ(X )). Note that the bounding term T is for the value
of X , while the bounding term t in ∃X ≤ t . . . or ∀X ≤ t . . . is for the
length of X (Deﬁnition IV.3.1).
Deﬁnition VIII.3.7 (String Minimization & Maximization Axioms).
The string minimization axiom scheme for Φ, denoted Φ-SMIN, is
ϕ(Y ) ⊃ ∃X ≤ Y, ϕ(X ) ∧ ¬∃Z < Xϕ(Z)
where ϕ is a formula in Φ. Similarly the string maximization axioms
scheme for Φ, denoted Φ-SMAX, is
ϕ(∅) ⊃ ∃X ≤ Y, ϕ(X ) ∧ ¬∃Z ≤ Y (X < Z ∧ ϕ(Z))
where ϕ is a formula in Φ.
Theorem VIII.3.8. For i ≥ 0, TV i proves the ΣBi -SMIN and ΣBi -SMAX
axioms.

220

VIII. Theories for Polynomial Time and Beyond

Proof. To prove ΣBi -SMAX, let ϕ(X ) be a ΣBi -formula. Let ϕ  (X ) be
the ΣBi -formula obtained by taking a prenex form of
X ≤ Y ⊃ ∃U ≤ Y (X ≤ U ∧ ϕ(U )).
Then the SMAX axiom for ϕ(X ) follows from the SIND axiom (184)
applied to ϕ  (X ).
The proof of ΣBi -SMIN is similar, but uses the binary subtraction function Z −· Y .
2
Exercise VIII.3.9. Show that the limited subtraction function for string
·
Z −· Y is ΣB0 -bit-deﬁnable, where the intended meaning of Z −
Y is ∅ if
·
Z ≤ Y , and (Z − Y ) + Y = Z otherwise.
We now concentrate on TV 0 .
Theorem VIII.3.10. TV 0 = VP.
Proof. Subsection VIII.3.1 shows that TV 0 ⊂ VPV, and by Theorem VIII.2.17 VPV is conservative over VP. Hence TV 0 ⊆ VP. The
reverse inclusion is shown in Subsection VIII.3.2.
2
By Theorem VIII.3.10 we know the properties of VP proved in Section VIII.1 also hold for TV 0 . In particular TV 0 is ﬁnitely axiomatizable, the functions ΣB1 -deﬁnable in TV 0 comprise FP, and by Corollary VIII.2.18 V 1 is ΣB1 -conservative over TV 0 .
In the following corollary, TV i (VPV) is deﬁned analogously to
i
V (VPV) in Deﬁnition VIII.2.10, namely it has the vocabulary of VPV
and the axioms are the union of the axioms for TV i and VPV. (See also
Theorem VIII.2.11 and Corollary VIII.2.12).
Corollary VIII.3.11. For i ≥ 0, TV i (VPV) is a conservative extension
of TV i .
Proof. For i = 0 this follows from the fact that VPV is a conservative
extension of TV 0 (Theorems VIII.2.17 and VIII.3.10). For i ≥ 1 we know
V 1 ⊆ TV i , and hence TV i ΣB1 -deﬁnes all functions in LFP , and also TV i
proves ΣB1 -REPL by Corollary VI.3.8. Therefore the corollary follows
from Corollary VI.3.11.
2
VIII.3.1. TV 0 ⊆ VPV. In this subsection we use the string addition
function X + Y introduced in Chapter V and use some of its simple
properties stated in Exercise V.4.19. We also need the string relation
X ≤ Y (Deﬁnition VIII.3.5) and the string function POW2(x) deﬁned
below. The intended meaning of POW2(x) is such that (see Notation on
page 85) bin(POW2(x)) = 2x .
Example VIII.3.12. The string function POW2(x), also denoted by
{x}, has bit deﬁning axiom
POW2(x)(i) ↔ i = x.

VIII.3. TV 0 and the TV i Hierarchy

221

0

Exercise VIII.3.13. Show that V proves the following:
X + POW2(0) = S(X ),
X < POW2(|X |),
POW2(i) + POW2(i) = POW2(i + 1).
The following theorem suﬃces to prove TV 0 ⊂ VPV. That VPV proves
the open string induction axioms may seem surprising, since unwinding
the induction requires exponentially many steps.
Theorem VIII.3.14. VPV proves the ΣB0 (LFP )-SIND axioms.
Proof. By Lemma VIII.2.3 we may assume that ϕ(X ) in (184) is an
open LFP -formula. Let y, Y be a list of the parameters in ϕ(X ). We
use binary search to deﬁne in VPV an LFP function G(y, Y , X ) such that
VPV proves


(ϕ(∅) ∧ ¬ϕ(X )) ⊃ ϕ(G(y, Y , X )) ∧ ¬ϕ(S(G(y, Y , X )))
(187)
from which (184) follows immediately.
In more detail, we use the string functions X + Y and POW2(x) and
the string relation X ≤ Y deﬁned above.
In the following we suppress mention of the parameters y, Y .
Deﬁne the formula
ϕ  (X, Z) ≡ ϕ(Z) ∧ Z ≤ X.
Now we use limited recursion (175), (176) (page 210) to deﬁne in VPV the
binary search function H (i, X ), whose value is the left end of the interval
[A, B] of length POW2(|X | −· i) satisfying ϕ  (X, A) ∧ ¬ϕ  (X, B). (Recall
the number function x −· y (limited subtraction), Section III.3.3).
Let n = |X |.
H (0, X ) = ∅,

H (i, X ) if ¬ϕ  (X, H (i, X ) + POW2(n −· (i + 1))),
H (i + 1, X ) =
H (i, X ) + POW2(n −· (i + 1)) otherwise.
We can use |X | as a bounding term to limit this recursion. Now deﬁne
G(X ) = H (|X |, X ).
The following two formulas can be proved in VPV by induction on i
(Lemma VIII.2.7), using Exercises V.4.19 and VIII.3.13. The ﬁrst formula
justiﬁes |X | as a length bound for the recursion.
X = ∅ ⊃ (H (i, X ) + POW2(0)) ≤ X,
(ϕ(∅) ∧ ¬ϕ(X ) ∧ i ≤ n) ⊃
·
(ϕ  (X, H (i, X )) ∧ ¬ϕ  (X, H (i, X ) + POW2(n −
i))).

222

VIII. Theories for Polynomial Time and Beyond

Then (187) follows from these two formulas and X + POW2(0) = S(X )
(Exercise VIII.3.13).
2
Recall the notion of a ΔBi formula in a theory (Deﬁnition VIII.2.8).
Deﬁnition VIII.3.15. Let T be a theory with vocabulary L. Let AX
denote any of the axiom schemes COMP, IND, SIND, etc. We say that T
proves ΔBi -AX if for any ΔBi (L) formula ϕ in T , T proves the AX axiom
for ϕ.
From Theorem VIII.3.14 and Corollary VIII.2.9 we have
Corollary VIII.3.16. VPV proves ΔB1 -SIND.
VIII.3.2. Bit Recursion. In order to show that VP ⊆ TV 0 we introduce
a bit-recursion scheme and show that it is provable in TV 0 .
For each formula ϕ(i, X ) (possibly with other free variables) we deﬁne
a formula ϕ rec (y, X ) which says that each bit i of X is deﬁned in terms
of the preceding bits of X using ϕ. That is, using the notation X <i for
Cut(i, X ) (see (97) on page 139)
ϕ rec (y, X ) ≡ ∀i < y(X (i) ↔ ϕ(i, X <i )).
In case ϕ(i, X ) is an L2A -formula we can interpret ϕ rec (y, X ) as an L2A formula by eliminating occurrences of Cut(i, X ) using the standard method of eliminating ΣB0 -bit-deﬁnable function symbols (Lemma V.4.15).
If ϕ(i, X ) is in ΣB0 it is easy to see that V 0 can use induction on y to prove
that the condition ϕ rec (y, X ) uniquely determines bits X (0), . . . , X (y − 1)
of X .
Deﬁnition VIII.3.17. If Φ is a set of formulas, then the bit recursion
axiom scheme, denoted Φ-BIT-REC, is the set of formulas
∃Xϕ rec (y, X )

(188)

where ϕ(i, X ) is in Φ, and may have free variables other than X .
We will show that TV 0 = V 0 + ΣB0 -BIT-REC.
Theorem VIII.3.18. TV 0 proves the ΣB0 -BIT-REC-scheme.
Proof. We use ΣB0 -SMAX to prove the existence of X in (188). Informally, imagine computing the bits X (0), . . . , X (y − 1) of X in that order.
Suppose that false negative is allowed, but there is no false positive. That
is, we consider strings Y that satisfy
∀i < y, Y (i) ⊃ ϕ(i, Y <i ).
The idea is that the maximal string Y guaranteed by SMAX cannot have
any false negative bit, and thus must be the correct string.
To actually use the SMAX principle we need a twist in the above argument. This is because we compute X in (188) from bit 0, while string

VIII.4. The Theory V 1 -HORN

223

comparison starts with high order bits. Thus, let the string reversal function Rev(y, X ) have bit-deﬁning axiom
Rev(y, X )(i) ↔ i < y ∧ X (y −· i −· 1)
where −· is limited subtraction (Section III.3.3). Then Rev(y, X ) is the
reverse of the string X (0) . . . X (y − 1).
Let ϕ  (y, Y ) be the formula
∀i < y, Rev(y, Y )(i) ⊃ ϕ(i, (Rev(y, Y ))<i ).

(189)

We can tacitly assume that ϕ  (y, Y ) is ΣB0 (by Lemma V.4.15). It is easy
to see that ϕ  (y, ∅). Thus, by ΣB0 -SMAX, there is a maximal string
X  ≤ POW2(y) that satisﬁes (189). It is also easy to show (in V 0 ) that
X  in fact satisﬁes
∀i < y, Rev(y, X  )(i) ↔ ϕ(i, (Rev(y, X  ))<i ).
As a result, the string X = Rev(y, X  ) satisﬁes (188).

2

Lemma VIII.3.19. VP ⊆ V 0 + ΣB0 -BIT-REC
Proof. Observe that the axiom MCV for VP (Deﬁnition VIII.1.1) is
an instance of ΣB0 -BIT-REC.
2
This lemma completes the proof of Theorem VIII.3.10, showing that
VP = TV 0 .
Corollary VIII.3.20. TV 0 proves its ΔB1 -SIND axioms. V 1 proves its

ΔB1 -SIND axioms.

Proof. The ﬁrst sentence follows from VP = TV 0 and Corollary
VIII.3.16. The second sentence follows from the ﬁrst, since by Corol2
lary VIII.2.18 any ΣB1 -formula that is ΔB1 in V 1 is also ΔB1 in TV 0 .

VIII.4. The Theory V 1 -HORN
This section will not be needed for any later results, but it is interesting
in that gives more evidence for the robustness of VP by giving yet another
axiomatization.
The theory V 1 -HORN [43] is the same as VP and TV 0 but presented
with very diﬀerent axioms. The of ideal of V 1 -HORN comes from a
theorem of Grädel in descriptive complexity theory, characterizing the
class P as the sets of ﬁnite models of certain second-order formulas. We
will formulate Grädel’s theorem as a representation theorem over L2A . We
start with some deﬁnitions and examples.
Deﬁnition VIII.4.1. A Horn formula is a propositional formula in conjunctive normal form such that each clause (i.e. conjunct) is a Horn clause,
i.e. it contains at most one positive occurrence of a variable.

224

VIII. Theories for Polynomial Time and Beyond

Horn formulas are important because the satisﬁability problem HornSat (given a Horn formula, determine whether it is satisﬁable) is complete
for P. A polytime algorithm for HornSat can be described as follows.
HornSat Algorithm. To test whether a given Horn formula A is satisﬁable, initialize a truth assignment  by assigning ⊥ to each atom of A.
Now repeat the following until satisﬁability is determined: If  satisﬁes
all clauses of A then decide that A is satisﬁable. Otherwise select a clause
C of A not satisﬁed by . If C has no positive occurrence of any atom
then decide that A is unsatisﬁable. Otherwise C has a unique positive
occurrence of some atom p, in which case ﬂip the value of  on p from ⊥
to .
Exercise VIII.4.2. Show that the above algorithm runs in polynomial
time and correctly determines whether a given Horn formula A is satisﬁable.
The HornSat algorithm suggests that a Horn clause (p ∨¬q1 ∨· · ·∨¬qk )
can be written as an assignment statement
p ← (q1 ∧ · · · ∧ qk ).
(In fact some logic-based programming languages such as Prolog use this
idea.)
We now indicate why HornSat is complete for P. It suﬃces to show that
a known complete problem CVP (Circuit Value Problem) can be reduced
to HornSat. Given a Boolean circuit C with binary gates ∧, ∨ and unary
gates ¬, and given a value v(x) ∈ {0, 1} for each input x to C , we want
to ﬁnd a Horn formula A which is satisﬁable iﬀ C has output 1 for the
given inputs v(x). The formula A uses double rail logic (see the proof of
Proposition VIII.1.7) to evaluate C : for each gate and each input x of C
the formula has two atoms x + and x − asserting that the gate or input is 1
or 0, respectively. For each such x, A has a Horn clause (¬x + ∨ ¬x − ) to
insure that not both atoms are true. For each input x, A has a unit clause
x + if v(x) = 1 and unit clause x − if v(x) = 0. For each gate in C , A has
up to three Horn clauses which assert that the output of the gate has the
appropriate value with respect to its inputs. For example, if x is the ∨ of
inputs y, z, then the clauses are
(x + ← y + ) ∧ (x + ← z + ) ∧ (x − ← (y − ∧ z − )).

(190)

+
, where xout is the output gate.
Finally A has the unit clause xout
It turns out that the collection of propositional Horn formulas that
correspond to a given polytime problem can be represented by single ΣB1
formula as follows.

Deﬁnition VIII.4.3. A ΣB1 -Horn formula is an L2A -formula of the form
ϕ ≡ ∃Z1 . . . ∃Zk ∀y1 ≤ t1 . . . ∀ym ≤ tm

(191)

VIII.4. The Theory V 1 -HORN

225

where k, m ≥ 0 and is quantiﬁer-free in conjunctive normal form and
each clause contains at most one positive occurrence of a literal of the form
Zi (t). No term of the form |Zi | may occur in ϕ, although ϕ may contain
free string variables X (and free number variables) with no restriction
on occurrences of |X |, and any clause of may contain any number of
positive (or negative) literals of the form X (t).
We will show that ΣB1 -Horn formulas represent polynomial time relations in their free variables.
Example VIII.4.4 (ParityHorn (X )). This is a ΣB1 -Horn-formula which
holds iﬀ the string X contains an odd number of 1’s. ParityHorn (X )
encodes a dynamic-programming algorithm for computing the parity of
X : Zodd (i) is true (and Zeven (i) is false) iﬀ the preﬁx of X of length i
contains an odd number of 1’s.
∃Zeven ∃Zodd ∀i < |X | Zeven (0) ∧ ¬Zodd (0) ∧ Zodd (|X |) ∧
(¬Zeven (i + 1) ∨ ¬Zodd (i + 1)) ∧ (¬Zeven (i) ∨ ¬X (i) ∨ Zodd (i + 1)) ∧
(¬Zodd (i) ∨ ¬X (i) ∨ Zeven (i + 1)) ∧ (¬Zeven (i) ∨ X (i) ∨ Zeven (i + 1)) ∧
(¬Zodd (i) ∨ X (i) ∨ Zodd (i + 1)).
Exercise VIII.4.5. Prove that ParityHorn (X ) has the stated property.
In Section IV.3.2 we showed how the complexity classes AC 0 and the
members ΣPi of the polynomial hierarchy can be characterized by representation theorems involving the formula classes ΣBi . Now we state a
similar theorem characterizing P.
Theorem VIII.4.6 (Grädel). A relation R(x, X ) is polynomial time iﬀ it
is represented by some ΣB1 -Horn-formula.
Proof sketch. (⇐=) Suppose that the formula ϕ(x, X ) has the form
(191). We outline an algorithm that runs in time polynomial in (x, |X |)
which, given values for x, X , determines whether ϕ(x, X ) holds (in the
standard model). First note that once values for x, X are given, the bounding terms ti = ti (x, X ) can be evaluated to numbers bounded by polynomials in (x, |X |). We expand the quantiﬁer preﬁx ∀y1 ≤ t1 . . . ∀ym ≤ tm
by giving all possible m-tuples of values (y1 , . . . , ym ) satisfying the bounding terms, and form the conjunction Ψ(Z1 , . . . , Zk ) of all instances (y),
as y ranges over all these tuples. (Note that the number of such tuples is
bounded by a polynomial in (x, |X |).)
Then Ψ(Z1 , . . . , Zk ) can be made into a propositional conjunctive normal form formula Ψ involving only literals of the form Zi (j) and ¬Zi (j)
for speciﬁc numbers j, since all terms and all other variables in have
been evaluated. (Here it is important that we have disallowed occurrences
of |Zi | in ϕ.) The arguments j in Zi (j) and ¬Zi (j) are values of terms

226

VIII. Theories for Polynomial Time and Beyond

t, for each Zi (t) or ¬Zi (t) that is a literal in the original formula . Let
B be an upper bound on the possible values of j (so B is a polynomial
in (x, X )). Then Ψ is a Horn formula whose propositional variables are
all in the set {Zi (j) : i ≤ k, j ≤ B}. Thus the problem of checking for
the existence of Z1 , . . . , Zk reduces to the polytime HornSat problem of
deciding whether Ψ is satisﬁable.
(=⇒) Let R(x, X ) be a polytime relation and let M be a deterministic
polytime Turing machine that recognizes R in time t(x, X ). By choosing t large enough, the entire computation of M on input x, X can be
represented (using the pairing function) by an array Z(i, j) with t rows
and columns, where the i-th row speciﬁes the tape conﬁguration at time
i. Thus R(x, X ) is represented by the ΣB1 -Horn-formula
∃Z∃Z̃∀i ≤ t∀j ≤ t (i, j, x, X , Z, Z̃).
Here the variable Z̃ is forced to be ¬Z in the same way that Zeven and
Zodd are forced to be complementary in the parity example above. The
formula satisﬁes the conditions in Deﬁnition VIII.4.3 and each clause
speciﬁes a local condition on the computation.
2
Deﬁnition VIII.4.7. The theory V 1 -HORN has vocabulary L2A and
axioms those of V 0 together with ΣB1 -Horn-COMP.
The original deﬁnition of V 1 -HORN in [43] was a little diﬀerent.
Recall that V 0 has axioms 2-BASIC together with ΣB0 -COMP (Definition V.1.3). The original deﬁnition was essentially V 1 -HORN =
2-BASIC + ΣB1 -Horn-COMP. It was shown with some eﬀort that
V 1 -HORN proves ΣB0 -COMP, so the two deﬁnitions are equivalent.
The next theorem follows from results in [43].
Theorem VIII.4.8. V 1 -HORN = VP.
Proof sketch. V 1 -HORN ⊆ VP: It suﬃces to show
VP  ΣB1 -Horn-COMP.
Since VPV is a conservative extension of VP (Theorem VIII.2.17), it
suﬃces to show VPV  ΣB1 -Horn-COMP. Since VPV  ΣB0 (LFP )-COMP
(Lemma VIII.2.7), it suﬃces to show that for every ΣB1 -Horn-formula ϕ
there is a ΣB0 (LFP ) formula ϕ  such that VPV  ϕ ↔ ϕ  .
So let ϕ be a ΣB1 -Horn-formula as in (191), where we write (Z1 , . . . , Zk )
simply as , and let x, X be the free variables in ϕ. The idea is to ﬁnd a
“witnessing function” Fi (x, X ) in LFP for each Zi such that VPV proves
ϕ ↔ ϕ  , where
ϕ  ≡ ∀y1 ≤ t1 . . . ∀ym ≤ tm (F1 (x, X ), . . . , Fk (x, X )).
To deﬁne Fi we refer to the direction ⇐= in the proof of Theorem VIII.4.6.
There the algorithm to evaluate ϕ(x, X ) computes a propositional Horn
formula Ψ whose propositional variables have the form Zi (j), and then

VIII.4. The Theory V 1 -HORN

227

applies the HornSat algorithm to determine whether Ψ is satisﬁable. This
algorithm computes a truth assignment  to the atoms Zi (j) of Ψ such
that Ψ is satisﬁable iﬀ  satisﬁes Ψ . Thus it suﬃces to deﬁne the string
Fi (x, X ) to be the array of truth values that  gives to Zi . That is, the the
bit deﬁnition of each Fi is
Fi (x, X )(j) ↔ j ≤ B ∧ (Zi (j)).
The algorithm outlined to compute Fi is clearly polytime and hence corresponds to some function in FP. The missing details in the proof are to
show that VPV proves the correctness of the algorithm; i.e. VPV  ϕ ⊃
ϕ .
VP ⊆ V 1 -HORN: By Deﬁnition VIII.1.1 it suﬃces to show that
V 1 -HORN  MCV.
We indicated earlier (190) how propositional Horn clauses can be used
to evaluate circuit gates. Now we show how to use a ΣB1 -Horn formula
to evaluate the circuit C described by parameters a, G, E as described
in Section VIII.1. In essence, the new atoms x + , x − , etc. in (190) are
encoded by the (existentially quantiﬁed) string variables Z in the ΣB1 -Horn
formula. Note that the algorithm outlined on page 224 is for circuits with
binary gates, while here the circuit may have unbounded fan-ins.
Thus we want to deﬁne an array Z(x) (and its negation Z̃(x)) to
evaluate gate x in C . We will put in the clause
¬Z(x) ∨ ¬Z̃(x)
to make sure that not both are true. For gates 0 and 1 (with constant
values 0 and 1 respectively) we put in the four clauses
Z̃(0),

¬Z(0),

¬Z̃(1),

Z(1).

(192)

Next, consider gate x. Suppose that this is an ∨-gate, i.e., ¬G(x) holds.
Then we need several clauses. The ﬁrst is


¬G(x) ∧ y < x ∧ E(y, x) ∧ Z(y) ⊃ Z(x)
which assures that Z(x) holds if at least one of the inputs to gate x is 1.
To ensure that Z̃(x) holds if all inputs to gate x are 0 is more involved. In
fact, we formalize a simple algorithm that runs through the inputs of gate
x to check if all of them are 0. We use a string variable P, where P(x, y)
is intended to mean that all gates u which are input to x, where u < y,

228

VIII. Theories for Polynomial Time and Beyond

output 0. The formalization is as follows:
P(x, 0),
(P(x, y) ∧ ¬E(y, x)) ⊃ P(x, y + 1),
(P(x, y) ∧ Z̃(y)) ⊃ P(x, y + 1),
(P(x, x) ∧ E(y, x)) ⊃ Z̃(y),
(¬G(x) ∧ P(x, x)) ⊃ Z̃(x).
Let ∨ denote the set of the six clauses described above for the case
where the gate (x) is an ∨-gate. Also, let I be the set of clauses in (192).
The set ∧ of clauses for handling the case where (x) is an ∧-gate is similar
to ∨ , using an extra variable Q instead of P.
Exercise VIII.4.9. Give the six clauses of

∧.

Now we can show in V 0 that a string Y that is computed by
Y (i) ↔ ∃Z∃Z̃∃P∃Q∀x < a∀y < a, (¬Z(x) ∨ ¬Z̃(x)) ∧
I ∧

∧∧

∨ ∧ Z(i)

(193)

(for i < a) satisﬁes MCV (a, G, E, Y ). The following exercise is helpful.
Exercise VIII.4.10. Let the string variables Z, Z̃, P, Q satisfy the RHS
of (193), and Y  satisfy MCV (a, G, E, Y  ). Show by induction on i that
for i < a,
¬Z(i) ⊃ ¬Y  (i)

and

¬Z̃(i) ⊃ Y  (i).

Exercise VIII.4.11. Prove by number induction that the string Y described above satisﬁes the recursion in MCV (a, G, E, Y ).
Finally, the existence of Y in MCV follows from the existence of Y
that satisﬁes (193), and the latter follows from ΣB1 -Horn-COMP. This
2
completes the proof that VP ⊆ V 1 -HORN.

VIII.5. TV 1 and Polynomial Local Search
It follows from Theorem VIII.3.4 that V 1 ⊆ TV 1 , and hence TV 1 can
But there is no known nice
characterization of the set of all functions ΣB1 -deﬁnable in TV 1 . There
is however a nice characterization of the set of all search problems ΣB1 deﬁnable in TV 1 .
A search problem is essentially a multivalued function, and the associated computational problem is to ﬁnd one of the possible values. Here
we are concerned with total search problems, which means that the set of
possible values is always nonempty. We present a search problem by its
ΣB1 -deﬁne all polynomial time functions.

VIII.5. TV 1 and Polynomial Local Search

229

graph. The search problem is deﬁnable in a theory if the theory proves
its totality. In the two-sorted setting the set of possible values is a set of
strings.
Deﬁnition VIII.5.1. A search problem QR is a multivalued function
with graph R(x, X , Z), so
QR (x, X ) = {Z : R(x, X , Z)}.
Here the arity of either or both of x, X may be zero. The search problem
is total if the set QR (x, X ) is non-empty for all x, X . The search problem
is a function problem if |QR (x, X )| = 1 for all x, X . A function F (x, X )
solves QR if
F (x, X ) ∈ QR (x, X )
for all x, X .
Here we will be concerned only with total search problems. The following notion of reduction preserves totality.
Deﬁnition VIII.5.2. A search problem QR1 is many-one reducible to
a search problem QR2 , written QR1 ≤AC 0 QR2 , provided there are FAC 0 functions f, F , G such that G(x, X , Z) ∈ QR1 (x, X ) for all Z ∈ QR2 (f(x,
X ), F (x, X )).
We note that the usual deﬁnition states the weaker requirement that
f, F , G are polytime functions. However experience shows that when
reductions are needed they can be made to meet our stronger requirement.
Exercise VIII.5.3. Show that ≤AC 0 is a transitive relation. Also show
that if QR1 ≤AC 0 QR2 and QR2 is solvable by a polytime function, then QR1
is solvable by a polytime function.
Local search is a method of ﬁnding a local maximum of a function
by starting at a point in the domain of the function, ﬁnding a neighbor
of the point that increases the value of the function, and continuing this
process until no such neighbor exists. Polynomial Local Search (PLS)
formalizes this as a search problem in case the function is polytime and
suitable neighboring points can be found in polynomial time. Recall that
∅ denotes the empty set (Example V.4.17).
Deﬁnition VIII.5.4. A PLS problem Q is speciﬁed by the following:
1) A polytime relation ϕQ (x, X , Z) and an L2A -term t(x, X ) satisfying
the two conditions
ϕQ (x, X , ∅),
ϕQ (x, X , Z) ⊃ |Z| ≤ t(x, X ).
({Z : ϕQ (x, X , Z)} is the set of candidate solutions for problem
instance (x, X ).)

230

VIII. Theories for Polynomial Time and Beyond

2) Polytime string functions PQ (x, X , Z) and NQ (x, X , Z) satisfying
the two conditions
ϕQ (x, X , Z) ⊃ ϕQ (x, X , NQ (x, X , Z)),
NQ (x, X , Z) = Z ⊃ PQ (x, X , Z) < PQ (x, X , NQ (x, X , Z)).
(NQ is a heuristic for ﬁnding a neighbor of Z which increases the
proﬁt PQ . NQ (x, X , Z) = Z is taken to mean that Z is locally
optimal. Recall that X < Y stands for X ≤ Y ∧ ¬X = Y , where
X ≤ Y is deﬁned in Deﬁnition VIII.3.5.)
Then
Q(x, X ) = {Z : ϕQ (x, X , Z) ∧ NQ (x, X , Z) = Z}.

(194)

The problem Q is an AC 0 -PLS problem if ϕQ , NQ , PQ are AC 0 -relations
and functions.
It is easy to see that a PLS problem is a total search problem. For ﬁxed
x, X , the set of candidate solutions Z (those satisfying ϕQ (x, X , Z)) is
nonempty and bounded. Thus given x, X , any candidate solution Z that
maximizes the proﬁt PQ (x, X , Z) is a member of Q(x, X ).
We will concentrate on a subclass of PLS called ITERATION , which
is complete for PLS.
Deﬁnition VIII.5.5. An ITERATION problem Q = QF is speciﬁed by
a polytime function F (x, X , Z) and a bounding term t(x, X ). The graph
relation R is speciﬁed by a formula F (x, X , Z) which is (suppressing the
parameters x, X ):
≡ (Z = ∅ ∧ F (∅) = ∅) ∨


|Z| ≤ t ∧ Z < F (Z) ∧ t < |F (Z)| ∨ F (F (Z)) ≤ F (Z) . (195)

F (Z)

Then
QF (x, X ) = {Z :

F (x, X , Z)}.

(196)

The problem QF is an AC 0 -ITERATION problem if F is an AC 0 -function.
To see that QF is a total search problem, note that the largest Z ≤ t such
that (Z = ∅ ∨ Z < F (Z)) is always a solution. The next exercise shows
that every polytime function can be interpreted as an AC 0 -ITERATION
problem with exactly one solution.
Exercise VIII.5.6. Show that for each polytime function G(x, X ) there
is an AC 0 function F (x, X , Z) and an L2A term t(x, X ) so that provably
in VPV, the only solution to QF is G(x, X ). (Hint: Consider the computation of a Turing machine that computes G.)

VIII.5. TV 1 and Polynomial Local Search

231

Lemma VIII.5.7. Every ITERATION problem is a PLS problem.
Proof. Let QF be an ITERATION problem as above. Then QF can be
speciﬁed as a PLS problem using the following deﬁnitions:
ϕQ (Z) ≡ |Z| ≤ t ∧ (Z = ∅ ∨ Z < F (Z)),
PQ (Z) = Z,

F (Z) if |F (Z)| ≤ t and Z < F (Z) < F (F (Z)),
NQ (Z) =
Z otherwise.
Then (196) follows from (194). Notice that if QF is an AC 0 -ITERATION
2
problem then the corresponding problem is an AC 0 -PLS problem.
Theorem VIII.5.8. Every PLS problem is many-one reducible to some
ITERATION problem. Every AC 0 -PLS problems is many-one reducible to
some AC 0 -ITERATION problem.
Proof. Let Q be a PLS problem and let t, ϕQ , PQ , NQ be as in Deﬁnition VIII.5.4.
We give the following ΣB0 -deﬁnition of the concatenation function X ∗z
Y , which is the ﬁrst z bits of X followed by Y :
(X ∗z Y )(i) ↔ i < z + |Y | ∧ [(i < z ∧ X (i)) ∨ (z ≤ i ∧ Y (i −· z))].
We wish to deﬁne an ITERATION problem QF with bounding term t 
whose solutions yield solutions of Q. The idea is to let the domain of F
consist of concatenations U ∗t V where U is a candidate solution for Q
and V is its proﬁt. Note that if V1 < V2 then U1 ∗t V1 < U2 ∗t V2 for all
U1 , U2 .
In the following we suppress the parameters x, X .
Let u = u(x, X ) be an L2A -term large enough so that |PQ (NQ (Z))| ≤ u
for |Z| ≤ t. Then deﬁne
t = t + u
and
F (U ∗t V ) =



NQ (U ) ∗t PQ (NQ (U )) if V = PQ (U ) and ϕQ (U ),
U ∗t V otherwise.

The term t  is chosen so that if U satisﬁes ϕQ (U ) then |F (U ∗t PQ (U ))| ≤
t.
Here we redeﬁne PQ so that PQ (∅) = ∅. Note that the result is a PLS
problem with the same solutions as the original problem.
Now suppose Z is a solution to the ITERATION problem QF . We
show how to obtain a solution G(Z) (= G(x, X , Z)) to the original PLS
problem Q. We write Z = U ∗t V where U, V are uniquely determined by
Z (for |U | ≤ t and |V | ≤ u). Then from (194), (196) and our deﬁnitions
we see that G(U ∗t V ) = NQ (U ) is a solution to Q.

232

VIII. Theories for Polynomial Time and Beyond

Hence by Deﬁnition VIII.5.2 we conclude Q ≤AC 0 QF , where f, F take
x, X to itself and G(x, X , Z) = NQ (x, X , Z <t(x,X ) ).
2
Deﬁnition VIII.5.9. If S is a set of search problems, then CC(S) is the
set of search problems many-one reducible to S.
Theorem VIII.5.10.
CC(ITERATION ) = CC(PLS) =
CC(AC 0 -ITERATION ) = CC(AC 0 -PLS).
Proof. The ﬁrst and last equalities follow from the preceding deﬁnition and theorem. The middle equality follows from these and Theorem VIII.5.12 below.
2
Deﬁnition VIII.5.11. Let Q(x, X ) be a search problem with graph
R(x, X , Z). We say that Q is Φ-deﬁnable in a theory T if there is a
formula R (x, X , Z) in Φ such that
R (x, X , Z) ⊃ R(x, X , Z)

and
T  ∃Z

R (x, X , Z).

Theorem VIII.5.12. The following are equivalent for a search problem Q:
(a) Q is ΣB1 -deﬁnable in TV 1 .
(b) Q is in CC(PLS).
(c) Q is in CC(AC 0 -PLS).
Proof. (a) =⇒ (c) follows from Theorem VIII.5.13 below (Witnessing
for TV 1 ) and Lemma VIII.5.7. (c) =⇒ (b) is obvious. Hence it suﬃces
to show (b) =⇒ (a).
By Theorems VIII.5.8 and VIII.2.16 and Corollary VIII.3.11 it suﬃces
to show that every problem in CC(ITERATION) is ΣB1 (LFP )-deﬁnable in
TV 1 (VPV). We start by showing this for every ITERATION problem
QF . Let F (x, X , Z) be the formula (195) deﬁning QF . We may assume
that F is an LFP -function, and hence F is a ΣB1 (LFP )-formula. Let
(x, X , Z) ≡ (Z = ∅ ∨ Z < F (x, X , Z)).
Then VPV proves  is equivalent to a ΣB1 -formula (Theorem VIII.2.16),
and hence by ΣB1 -SMAX (Theorem VIII.3.8), TV 1 (VPV) proves the existence of a largest Z ≤ t satisfying (Z). Thus TV 1 (VPV) proves that
this Z satisﬁes F (Z).
This shows that every ITERATION problem is ΣB1 (LFP )-deﬁnable in
TV 1 (VPV). Now suppose the search QR1 is many-one reducible to some
ITERATION problem QR2 . Deﬁne the formula R1 (x, X , Z) by (suppressing x, X )
R1 (Z) ≡ ∃W ≤ t(Z = G(W ) ∧

R2 (f, F , W ))

VIII.5. TV 1 and Polynomial Local Search

233

where t is the bounding term for QR2 and R2 is a ΣB1 (LFP )-formula which
deﬁnes QR2 in TV 1 (VPV), and f, F , G show QR1 ≤AC 0 QR2 according to
Deﬁnition VIII.5.2. Then R1 is equivalent to a ΣB1 (LFP )-formula, and by
Deﬁnition VIII.5.2
R1 (x, X , Z) ⊃ R1 (x, X , Z).

Since by assumption TV 1 (VPV) proves ∃W ≤ u R2 (W ) (where u is a
bounding term from Parikh’s Theorem) it follows that TV 1 (VPV) proves
2
∃Z R1 (Z), as required.
Theorem VIII.5.13 (Witnessing for TV 1 ). Suppose that ϕ(x, X , Z) is
a Σ11 -formula such that
TV 1  ∃Zϕ(x, X , Z).
Then there is an AC 0 -ITERATION problem QF with graph
from (195) and an FAC 0 -function G such that
0

V 

F (x, X , Z)

F (x, X , Z) ⊃ ϕ(x, X , G(x, X , Z)).

Proof. By using pairing functions we may assume that ϕ is ΣB0 . The
proof is similar to the proof of the Witnessing Theorem for V 1 (Section VI.4). Thus we deﬁne a sequent system LK 2 -TV 1 , which is the same
 1 except that we replace the IND Rule by the single-ΣB -SIND
as LK 2 -V
1
Rule, deﬁned below. Recall (Example V.4.17) the AC 0 functions ∅ (empty
set) and S(X ) (successor of X ). For the next deﬁnition, when Φ is ΣBi (L2A )
(for i ≥ 0) the formulas A(S()) and A(∅) are understood to be the equivalent ΣBi (L2A ) formulas as stated by the FAC 0 Elimination Lemma V.6.7.
Deﬁnition VIII.5.14 (The SIND Rule). For a set Φ of formulas, the
Φ-SIND rule consists of the inferences of the form
Γ, A() −→ A(S()), Δ
Γ, A(∅) −→ A(T ), Δ

(197)

where A is a formula in Φ and T is a string term.
Restriction. The variable  is called an eigenvariable and does not occur
in the bottom sequent.
The proof that LK 2 -TV 1 is a complete system for TV 1 is the same as
 1 is a complete system for V
 1 , with obvious modiﬁthe proof that LK 2 -V
cations. Further the proof of Theorem VI.4.15, Anchored Completeness
for LK 2 +IND, works for LK 2 -TV 1 , so every theorem of TV 1 has an
anchored LK 2 -TV 1 proof.
Now we proceed as in the proof of the Witnessing Theorem for V 1
(Section VI.4.2) and for V 0 (Section V.5.2), with appropriate changes.

234

VIII. Theories for Polynomial Time and Beyond

Suppose that ∃Zϕ(x, X , Z) is a Σ11 -theorem of TV 1 , where ϕ is a ΣB0 formula. Then there is an anchored LK 2 -TV 1 proof  of
−→ ∃Zϕ(a, α, Z).
We may assume that  is in free variable normal form. By the Subformula
Property the formulas in  are Σ11 formulas, and in fact they are ΣB0
formulas or single-Σ11 formulas. As a result, every sequent in  has the
form
S = ∃Xi i (Xi ), Γ −→ Δ, ∃Yj j (Yj )
  
  
i=1,...,m

(198)

j=1,...,n

for m, n ≥ 0, where i and j and all formulas in Γ and Δ are ΣB0 .
We will prove by induction on the depth in  of the sequent S that there
is an AC 0 -ITERATION problem QF with graph F and for 1 ≤ i ≤ n
0
there are LFAC 0 -functions Gi such that V proves (the semantic equivalent
of) the sequent
S  = i ( i ) , Γ,
  
i=1,...,m

F (a, α,

, ) −→ Δ, j (Gj (a, α, , ))




(199)

j=1,...,n

where a, α is a list of exactly those variables with free occurrences in S.
(This list may be diﬀerent for diﬀerent sequents.) Also 1 , . . . , m are distinct new free variables corresponding to the bound variables X1 , . . . , Xm ,
although the latter variables may not be distinct. When S is the ﬁnal
sequent of , note that Γ and Δ are empty, i = 0, j = 1, and is empty,
so the theorem follows.
Note that this induction hypothesis is the same as in the proof for V 1
and V 0 , except now each witnessing function Gj is allowed to take the
argument , which is a solution to the ITERATION problem QF . As
before, the induction step has a case for ΣB0 -COMP and for each rule.
The argument for ΣB0 -COMP is the same as for V 0 (since the witnessing
function Gj can ignore its argument ). The argument for each rule except
ΣB1 -SIND is similar to that for V 0 (Section V.5.2). In the case of a rule
with two parents, such as ∧-right or cut, we need the following lemma to
combine the two ITERATION problems for the two parents into a single
problem for the conclusion. This lemma is stated more generally than is
needed for these rules (namely insertion of U as an argument of F2 ) in
order to accommodate the ΣB1 -SIND rule.
Lemma VIII.5.15 (Combining ITERATION Problems). Suppose that
QF1 and QF2 are ITERATION problems with graphs F1 (x, X , U ) and
F2 (x, X , U, V ). Then there is an ITERATION problem QF with graph
B
F (x, X , Z) such that F is Σ0 -bit-deﬁnable from F1 , F2 , and there are

VIII.5. TV 1 and Polynomial Local Search

235

FAC 0 -functions G1 (x, X ) and G2 (x, X ) such that (suppressing x, X )
0

V (F1 , F2 , F ) 

F (Z) ⊃

F1 (G1 (Z)) ∧

F2 (G1 (Z), G2 (Z)).

Proof. Assume the hypotheses of the Lemma, and let t be the bounding
term for QF1 and let u be the bounding term for QF2 . Using the notation
U ∗t V in the proof of Theorem VIII.5.8, we express the argument Z in
F (x, X , Z) in the form
Z = (U ∗t V ) ∗t+u 
where  is a binary string equal to 0,1,or 2. We abbreviate Z by
Z = U ∗ V ∗ .
Then we deﬁne F by (suppressing x, X )
⎧
U ∗V ∗2
if F1 (U ) ∧ F2 (U, V ) ∧  ≤ 1,
⎪
⎪
⎪
⎪
⎪
U
∗
F
⎪
2 (U, V ) ∗ 1 if F1 (U ) ∧ |V | ≤ u∧
⎪
⎪
⎨
V < F2 (U, V ) ∧  ≤ 1,
F (U ∗ V ∗ ) =
⎪
if V =  = ∅∧
F1 (U ) ∗ ∅ ∗ ∅
⎪
⎪
⎪
⎪
⎪
|U | ≤ t ∧ U < F1 (U ),
⎪
⎪
⎩
U ∗V ∗
otherwise.
Let the ITERATION problem QF have bounding term t + u + 2.
We claim that
0

V (F1 , F2 , F ) 

F (U ∗ V ∗ ) ⊃  = 2 ∧

F1 (U ) ∧

F2 (U, V ).

(200)

To see this, note that by line 3 in the deﬁnition of F , F (∅) = ∅, since
if F1 (∅) = ∅ then F1 (∅), and hence one of the ﬁrst two lines applies.
Hence assuming F (U ∗ V ∗ ) we have by (195)
U ∗ V ∗  < F (U ∗ V ∗ ) = F (F (U ∗ V ∗ )).
From the deﬁnitions of F1 and F2 we see that this can only happen if
line 1 applies in evaluating F (U ∗ V ∗ ).
This establishes (200). To prove the lemma, we deﬁne
G1 (U ∗ V ∗ ) = U,

G2 (U ∗ V ∗ ) = V.

We can make these deﬁnitions explicit by deﬁning
G1 (x, X , Z) = Z <t
and G2 (x, X , Z) to be the substring Z(0), Z(1), . . . , Z(u −· 1):
G2 (x, X , Z) = Y ↔ (|Y | ≤ u ∧ ∀i < u(Y (i) ↔ Z(t + i))).

2

It remains to handle the case in which S is obtained by an application of
the ΣB1 -SIND rule. Then S is the bottom sequent of
S1
S

=

Λ, ∃X ≤ r()(, X ) −→ ∃X ≤ r(S())(S(), X ), Π
Λ, ∃X ≤ r(∅)(∅, X ) −→ ∃X ≤ r(T )(T, X ), Π

236

VIII. Theories for Polynomial Time and Beyond

where  does not occur in S and  is ΣB0 .
By the induction hypothesis for the top sequent S1 it follows that V
proves a sequent S1 of the form
S1 = Λ , 1 ,

F (,

, ) −→ 2 , Π

0

(201)

where
1 ≡ | | ≤ r() ∧ (, ),

(202)

2 ≡ |G(, , )| ≤ r(S()) ∧ (S(), G(, , ))

(203)

and F deﬁnes the graph of an AC 0 -ITERATION problem QF and G is
an LFAC 0 -function. Here , ,  do not occur in Λ , but they may occur in
Π as arguments to the witnessing functions Gj .
Our task is to use QF and G to ﬁnd QF  and G  to compute a witness
for ∃X ≤ r(T )(T, X ), given a witness 0 for ∃X ≤ r(∅)(∅, X ). We
0
want V to prove the following sequent S  :
S  = Λ , 1 ,



F  ( 0 ,  ) −→ 2 , Π

(204)

where
1 ≡ | 0 | ≤ r(∅) ∧ (∅,


0 ),



(205)




2 ≡ |G ( 0 ,  )| ≤ r(T ) ∧ (T, G ( 0 ,  ))

(206)

and Π will be given later.
We will use the technique in the proof of Lemma VIII.5.15 and assume
that the search variable   for QF  has the form
  = ( ∗r(T ) ) ∗r(T )+t 
where , ,  are as in (201), and t an upper bound for  based on the
bounding term for QF . In the following we drop the subscripts to ∗ and
write
  = ∗ ∗.
The idea is that QF  uses F and G to ﬁnd witnesses for successive string
values of  = 1, 2, . . . , T knowing that 0 is a witness in case  = ∅. QF 
should succeed under the assumption that (201) holds for all  < T and
all , assuming that the formulas in Λ are true and those in Π are false.
We deﬁne F  ( 0 , ∗ ∗) by cases in such a way that if 1 holds, then
it continues to hold when F  is applied repeatedly, and progress is made
toward ﬁnding  such that (T,  ).
⎧
G(, , ) ∗ ∅ ∗ S() if 1 ∧  < T ∧ F (, , ),
⎪
⎪
⎨
else
∗ F ( , , ) ∗  if 1 ∧  < T ∧  < F ( , , ),
F  ( 0 , ∗ ∗) =
=  =  = ∅,
else
⎪
0 ∗∅∗∅, if
⎪
⎩
else ∗ ∗.

VIII.6. KPT Witnessing and Replacement

237

We deﬁne the witness-extracting function G  ( 0 ,   ) as follows:

if T = ∅,
0
G  ( 0 , ∗ ∗)) =
G(, , ) if T = ∅.
The following Claim asserts that a witness for ∃X(T, X ) can be obtained
from a solution ∗ ∗ to QF  , provided (201) holds with Λ true and Π
false.
0

Claim. V proves
T = ∅, 1 ,

F  ( 0,

∗ ∗) −→ 1 ∧

F (,

, ) ∧ (¬2 ∨ 2 ).

0

Proof of the Claim. We argue in V . Assume T = ∅, 1 , F  ( 0 , ∗∗).
By F  ( 0 , ∗ ∗) and (195) there are two possibilities. The ﬁrst is that
F  (∅) = ∅. But this is impossible, because if =  =  = ∅ then either

0 = ∅ and line 3 in the deﬁnition of F applies, or 0 = ∅ and one of
the ﬁrst two lines applies (by 1 and the deﬁnition of F ).
Therefore the second possibility in the deﬁnition of F  ( 0 , ∗  ∗ )
applies, and we have
∗ ∗ < F  ( ∗ ∗) = F  (F  ( ∗ ∗)).

(207)



Analyzing the deﬁnition of F and our assumptions (T = ∅, 1 ) shows
that the only way that (207) can hold is if line 1 in the deﬁnition of F 
applies when evaluating F  ( ∗  ∗ ). Thus 1 ∧ F (, , ). Also since
line 1 applies, if S() < T then ¬2 , for otherwise line 1 or line 2 would
apply when evaluating F  (F  ( ∗ ∗)), contradicting the second part of
(207). This proves the Claim in case S() < T . Finally if S() = T then
2 ⊃ 2 , and the Claim follows.
0
To establish that V proves (204) we need to specify Π by giving values
(in terms of   ) for the variables , ,  which occur as arguments to the
functions Gj in Π . Motivated by the Claim and (201) we deﬁne, for
  = ∗ ∗,
B(  ) = ,

GA(  ) = ,

D(  ) = 

and deﬁne Π to be the result of replacing , ,  in Π by B(  ), GA(  ),
D(  ) respectively.
0
The fact that V proves (204) now follows from the Claim and by (201)
with , ,  replaced by B(  ), GA(  ), D(  ). (The case T = ∅ follows
from (T = ∅ ∧ 1 ) ⊃ 2 , which holds by deﬁnition of G  .)
2

VIII.6. KPT Witnessing and Replacement
Here we present a generalization of the Herbrand Theorem from Chapter II and show how it can be used to prove the independence of the

238

VIII. Theories for Polynomial Time and Beyond

Replacement Axiom Scheme (Section VI.3) in some cases. In Section
VIII.7.3 we use it to show how the collapse of the polynomial hierarchy
follows from the collapse of the bounded arithmetic hierarchy V i .
Form 2 of the Herbrand Theorem (Corollary II.5.5) applies to a ∀∃
consequence of a universal theory. The next result is a generalization
which applies to ∀∃∀ consequences. We call it the KPT Witnessing Theorem, after the authors of [75], who used it to prove the ﬁrst part of
Theorem VIII.7.20.
Theorem VIII.6.1 (KPT Witnessing). Let T be a universal two-sorted
theory with vocabulary L. Let ϕ be an open formula and suppose
T  ∀X ∃Y ∀Zϕ(X, Y, Z).
Then there exists a ﬁnite sequence T1 , . . . , Tk of string terms over L such
that
T  ϕ(X, T1 (X ), Z1 ) ∨ ϕ(X, T2 (X, Z1 ), Z2 ) ∨ · · · ∨
ϕ(X, Tk (X, Z1 , . . . , Zk−1 ), Zk )
where the notation Ti (X, Z1 , . . . , Zi−1 ) means that only the displayed variables may occur in Ti .
In our applications of this theorem each term Ti is a function
Fi (X, Z1 , . . . , Zi−1 )
in some complexity class such as FAC 0 or FP. The “student-teacher”
interpretation of the theorem [74] is a useful way to think of it. The
student is given X and wants to ﬁnd Y satisfying ∀Zϕ(X, Y, Z), but has
computing power limited to the relevant complexity class. The student
starts by trying Y = F1 (X ). The teacher either approves, or comes up
with a counter-example Z1 such that ¬ϕ(X, F1 (X ), Z1 ). The student next
tries Y = F2 (X, Z1 ), and the teacher either agrees or supplies a counterexample Z2 . This process continues for at most k steps after which the
student ﬁnds a value of Y that works for all Z.
Proof of Theorem VIII.6.1. Let B, C1 , C2 , . . . be a list of new string
constants, and let U1 , U2 , . . . be an enumeration of all terms built from the
functions of L together with B, C1 , C2 , . . . , where the only new constants
in Uk are among {B, C1 , . . . , Ck−1 }. We will show that
T ∪ {¬ϕ(B, U1 , C1 ), ¬ϕ(B, U2 , C2 ), . . . , ¬ϕ(B, Uk , Ck )}
is unsatisﬁable for some k, from which the theorem follows (let Ti be Ui
with B replaced by X and each Cj replaced by Zj ).
Suppose otherwise. Then by compactness
T ∪ {¬ϕ(B, U1 , C1 ), ¬ϕ(B, U2 , C2 ), . . . }

(208)

239

VIII.6. KPT Witnessing and Replacement

has a model M. Since T is universal, the substructure M consisting of
the denotations of the terms U1 , U2 , . . . is also a model for (208). It is
easy to see that
M |= T + ∀Y ∃Z¬ϕ(B, Y, Z)
and hence T  ∀X ∃Y ∀Zϕ(X, Y, Z).

2

VIII.6.1. Applying KPT Witnessing. Following [47] we now outline the
method for using the KPT Witnessing Theorem to show that a universal
0
theory T which extends V and has a vocabulary L associated with certain
complexity classes cannot prove the ΣB0 (L)-REPL axioms (sometimes
0

subject to complexity assumptions). Our main examples are T = V and
T = VPV. That VPV is unlikely to prove ΣB0 -Replacement may seem
surprising, since V 1 proves it (Corollary VI.3.8), and V 1 and VPV have
the same ΣB1 -theorems.
Choose a function F which is in the relevant complexity class but
whose inverse probably is not. Suppose T proves the following instance of
replacement (which has W as a parameter, and t = t(W ) and u = u(W )
as terms):
(∀i < t ∃Z < u F (Z) = W [i] ) ⊃ ∃Y ∀j < t F (Y [j] ) = W [j] .

(209)

We can rewrite this as


∃i < t ∃Y ∀Z < u F (Z) = W [i] ⊃ ∀j < t F (Y [j] ) = W [j] .
Applying the KPT Witnessing Theorem we get a positive integer k and
functions g1 , . . . , gk , H1 , . . . , Hk such that T proves
(F (Z1 ) = W [g1 (W )] ⊃ ∀j < t F (H1 (W )[j] ) = W [j] ) ∨
(F (Z2 ) = W [g2 (W,Z1 )] ⊃ ∀j < t F (H2 (W, Z1 )[j] ) = W [j] ) ∨ · · · ∨
(F (Zk ) = W [gk (W,Z1 ,...,Zk−1 )] ⊃ ∀j < t F (Hk (W, Z1 , . . . , Zk−1 )[j] ) = W [j] ).
This allows the “student”, given an input W (considered as a sequence
W [0] , . . . , W [t−1] ), to compute Y coding a sequence of pre-images of F of
all t elements of W , by asking the “teacher” for pre-images of at most k
elements of W .
The student proceeds as follows. Let Y = H1 (W ). If ∀j < t F (Y [j] ) =
W [j] then output Y and halt. Otherwise compute g1 (W ) and ask the
teacher for a pre-image Z1 of W [g1 (W )] . Let Y = H2 (W, Z1 ). If ∀j <
t F (Y [j] ) = W [j] then output Y and halt. Otherwise compute g2 (W, Z1 )
and ask the teacher for a pre-image Z2 of W [g2 (W,Z1 )] , and so on. By our
assumption the algorithm will run for at most k steps of this form before
it outputs a suitable Y .

240

VIII. Theories for Polynomial Time and Beyond
0

Theorem VIII.6.2 ([47]). V 0 and V do not prove ΣB0 -REPL.
0

Proof. Since V extends V 0 and every ΣBi (LFAC 0 )-formula is provably
equivalent to a ΣBi -formula (Lemma V.6.7), it suﬃces to prove the theorem
0
for the case V .
Recall that PARITY (X ) holds iﬀ the string X has an odd number of
ones. We have pointed out that PARITY is not an AC 0 relation, but in
fact is is known [52, 3] that PARITY is not even in nonuniform AC 0 ; i.e.
it cannot be computed by any polynomial size bounded depth family
of Boolean circuits. We will show using the student-teacher method
0
outlined above that if V proves ΣB0 -REPL then there is a randomized
0
AC algorithm which on each input X , with probability at least one-half,
correctly outputs PARITY (X ), and if it does not output PARITY (X )
it outputs an ‘abort’ message, meaning the computation failed. From
this it follows using a standard argument that PARITY is in nonuniform
AC 0 . For each input length n, the circuit for computing PARITY (X ) for
|X | = n is obtained by repeating the randomized computation n + 1 times
with independent random bits, to obtain a randomized AC 0 algorithm
that computes PARITY (X ) with abort probability at most 2−n−1 . Hence
there must be some ﬁxed setting of the random bits which aborts on at
most a fraction 2−n−1 inputs X of length n; which means this setting of
random bits allows the circuit to correctly compute PARITY (X ) on all
inputs X of length n.
Let PAR be the function that maps a binary string of length m to its
parity vector. That is, PAR(m, X ) = Y if |Y | ≤ m and, for each i < m,
Y (i) is the parity of the string X (0) . . . X (i). In what follows we take m to
be a parameter, assume X is a string of length at most m, and suppress the
argument m from PAR(m, X ). Note that for ﬁxed m, PAR is a bijection
from the set of strings of length at most m to itself.
Although PAR(X ) cannot be computed in AC 0 , its inverse, which we
will call UNPAR, is in (uniform) FAC 0 : the ith bit of UNPAR(Y ) is given
by the ΣB0 -formula
(i = 0 ∧ Y (i)) ∨ (i > 0 ∧ Y (i − 1) ⊕ Y (i)).
Here UNPAR has an argument m, which we suppress. Then
UNPAR(PAR(X )) = X
and
PAR(UNPAR(Y )) = Y.
Notice also that for all m-bit strings A, B, C , writing ⊕ for bitwise XOR,
if A = B ⊕ C then PAR(A) = PAR(B) ⊕ PAR(C ).
0
Assuming that V proves ΣB0 -REPL we can apply the argument of
0
Section VIII.6.1 and assume that V proves (209) for the case in which

VIII.6. KPT Witnessing and Replacement

241

F is UNPAR. We can assume that the parameter m is coded by the
parameter W ; speciﬁcally m = |W [0] |, where W [0] is a string of 0’s except
bit m − 1 is 1. (Note that PAR(W [0] ) = W [0] .) Also we deﬁne the terms
t = m + 1, and u = m. Then for some ﬁxed k there is a uniform AC 0
algorithm which, for any sequence W [1] , . . . , W [m] of binary strings of
length at most m makes k queries of the form “what is PAR(W [i] )?” and
outputs the sequence of parity vectors of W .
Suppose m ≥ 2k. We will show how to use this algorithm to compute
the parity of a single string I , |I | ≤ m, in uniform randomized AC 0 .
Choose m strings U1 , . . . , Um of m bits each uniformly at random, and
for each i compute Vi = UNPAR(Ui ). Choose a number r, 1 ≤ r ≤ m,
uniformly at random. For 1 ≤ i ≤ m deﬁne W [i] by the condition
W [i] =

Vi
I ⊕ Vr

if i = r,
if i = r.

Since for each m the function UNPAR deﬁnes a bijection from the set
{0, 1}m to itself, and since for each I with |I | < m the map X %→ I ⊕ X
also deﬁnes a bijection from that set to itself, it follows that the string W
deﬁned above, interpreted as an m × m bit matrix, is uniformly distributed
over all such matrices.
Now run our student-teacher AC 0 algorithm on W . If the student asks
“what is PAR(W [i] )?” for i = r, reply with Ui (or W [0] if i = 0) (which is
the correct answer). If the algorithm queries “what is PAR(Y [r] )?”, then
abort the computation.
Since PAR(W [i] ) is queried for at most k diﬀerent values of i and since
for each input I each pair (W, r) is equally likely to have been chosen,
it follows that the computation will be aborted with probability at most
k/m ≤ 1/2.
Hence with probability at least 1/2 the algorithm is not aborted, we
are able to answer all the queries correctly, and we obtain Y such that
Y [r] = PAR(W [r] ) = PAR(I ⊕ Vr ). But I = Vr ⊕ (I ⊕ Vr ) and hence
PAR(I ) = PAR(Vr ) ⊕ PAR(I ⊕ Vr )
= Ur ⊕ Y [r] .
We use this to compute PAR(I ) and use bit m − 1 of PAR(I ) to determine
PARITY (I ).
For each input I the algorithm succeeds with probability at least 1/2,
where the probability is taken over its random input bits. If the algorithm
aborts, this is reﬂected in the output. As explained earlier, this implies the
existence of a nonuniform AC 0 algorithm for PARITY (I ). Since no such
algorithm exists, it follows that V 0 does not prove the ΣB0 -Replacement
scheme.
2

242

VIII. Theories for Polynomial Time and Beyond

We now show that VPV seems unlikely to prove ΣB0 -REPL because a
consequence would be that integer factoring is easy. This contrasts with
V 1 , which proves the stronger gΣB1 -REPL scheme (Corollary VI.3.8).
We adapt the proof [94] that cracking Rabin’s cryptosystem based on
squaring modulo N is as hard as factoring. Let N be the product of
distinct odd primes P and Q. Suppose 0 < X1 < N and gcd(X1 , N ) = 1.
Let C = X12 . Then C has precisely four square roots X1 , X2 , X3 , X4
modulo N . This can be seen as follows: let XP = (X1 mod P) and
XQ = (X1 mod Q). By the Chinese remainder theorem there are uniquely
determined numbers X1 , X2 , X3 , X4 with 0 < Xi < N such that
X1 ≡ XP (mod P)
X2 ≡ XP (mod P)
X3 ≡ −XP (mod P)
X4 ≡ −XP (mod P)

X1 ≡ XQ (mod Q)
X2 ≡ −XQ (mod Q)
X3 ≡ XQ (mod Q)
X4 ≡ −XQ (mod Q).

Now X1 − X2 ≡ 0 (mod P) and X1 − X2 ≡ 2XQ ≡ 0 (mod Q), so
gcd(X1 − X2 , N ) = P. So from X1 and X2 we can recover P, and similarly
from X1 and X3 we can recover Q.
Hence if we have one square root of C , and are then given a square root
at random, we can factor N with probability 1/2.
Theorem VIII.6.3 ([47]). If VPV proves ΣB0 -REPL then factoring (of
products of two odd primes) is possible in probabilistic polynomial time.
Proof. We will argue as in the proof of the previous theorem, this time
taking squaring modulo N as our function F (so F has N as a parameter).
If VPV proves ΣB0 -REPL then there is polynomial time algorithm which,
for some ﬁxed k, given any sequence W [0] , . . . , W [m−1] of squares (modulo
N ) (where m = |N |), makes at most k queries of the form “what is the
square root of W [i] ?” and, if these are answered correctly, outputs square
roots of all the W [i] s.
Now suppose N is large enough that m = |N | > k. Choose numbers
X0 , . . . , Xm−1 uniformly at random with 0 < Xi < N . We may assume
that gcd(Xi , N ) = 1 for all i, since otherwise we can immediately ﬁnd a
factor of N .
Choose W so that for each i, W [i] = (Xi2 mod N ). Notice that each
Xi is distributed uniformly among the four square roots of W [i] .
Run our algorithm, and to each query “what is the square root of
W [i] ?”, answer with Xi . We will get as output Y coding a sequence
Y [0] , . . . , Y [m−1] of square roots of W [0] , . . . , W [m−1] .
If we think of N as ﬁxed, the value of Y depends only on the inputs
given to the algorithm, namely W and the k many numbers Xi that we
gave as replies. Let i be some index for which Xi was not used. Then
Xi is distributed at random among the square roots of W [i] , and Y [i] is a
square root of W [i] that was chosen without using any information about

VIII.7. More on V i and TV i

243

which square root Xi is. Hence gcd(Xi − Y [i] , N ) is a factor of N with
probability 1/2.
2

VIII.7. More on V i and TV i
VIII.7.1. Finite Axiomatizability. V 0 is ﬁnitely axiomatizable by Theorem V.7.1. By the discussion following Theorem VIII.3.10 we know that
TV 0 is ﬁnitely axiomatizable, as are the ∀ΣB1 -consequences of V 1 . Here
we show that V i and TV i are ﬁnitely-axiomatizable for all i ≥ 0. (In
Chapter X we will give other proofs using the Reﬂection Principles for Gi
and Gi .) We start by proving the existence of a universal polynomial time
function.
Theorem VIII.7.1 (Universal Function). There is an LFP function
Univ(X, W )
such that for every LFP -function F (X ) there is an LFAC 0 -function HF (n)
such that
VPV  |X | < n ⊃ F (X ) = Univ(X, HF (n)).
In particular VPV proves F (X ) = Univ(X, HF (|X |)).
Proof. We use the machinery of (180) (page 215). The value of Univ(X,
W ) is the output of the circuit C described by W , where C expects an
input string of length at most n (speciﬁed by W ), and (assuming |X | < n)
Univ(X, W ) supplies X to the input gates of C . Then HF (n) describes a
circuit which computes F (X ) for |X | < n.
2
To help prove the next result, we introduce a string pairing function.
Deﬁnition VIII.7.2. X, Y  is the LFAC 0 -function deﬁned by
X, Y (i) ↔ ∃j ≤ i, (i = 0, j ∧ X (j)) ∨ (i = 1, j ∧ Y (j)).
More generally X1 , . . . , Xn  is deﬁned inductively by
X1 , . . . , Xn+1  = X1 , . . . , Xn , Xn+1 .
Finally we deﬁne
x1 , . . . , xk , X  = POW2(x1 ), . . . , POW2(xk ), X .
0

Note that V proves
X, Y  = Z ⊃ (X = Z [0] ∧ Y = Z [1] ).
Theorem VIII.7.3. V i and TV i are ﬁnitely axiomatizable for all i ≥ 0.
Proof. We have already proved this for i = 0. For the general case we
start with the ﬁnitely axiomatizable theory VP and add one ΣBi -COMPaxiom to get V i and one ΣBi -SIND-axiom to get TV i . The axioms in
question involve universal formulas. For notational simplicity we treat
the case i = 1; the general case will be clear.

244

VIII. Theories for Polynomial Time and Beyond

For V 1 we deﬁne the ΣB1 (LFP ) formula
UV (i, a, X, W ) ≡ ∃Y ≤ aUniv(i, X, Y , W )(0)


and let UV (i, a, X, W ) be the equivalent ΣB1 formula according to Theorem VIII.2.16 (so VPV  UV ↔ UV  ).
Let T be the ﬁnitely axiomatizable theory extending VP by the comprehension axiom for formula UV  (i, a, X, W ) (where a, X, W are parameters). Obviously T ⊆ V 1 . To prove the reverse inclusion, since VPV is
conservative over VP, it suﬃces to show V 1 ⊆ T + VPV.
Let ϕ(i, x, X ) be a ΣB1 -formula. Then there is an LFP -function F such
that (using Theorem VIII.7.1) VPV proves
ϕ(i, x, X ) ↔ ∃Y ≤ t F (i, x, X , Y )(0)
↔ ∃Y ≤ t Univ(i, x, X , Y , HF (|i, x, X , Y |))(0)
↔ UV  (i, t, x, X , HF (|i, x, X , Y |)).
Hence VPV proves the comprehension for ϕ from the comprehension
axiom for UV  . It follows that V 1 = T .
The argument is similar for TV 1 . This time we deﬁne
UT(a, X, Z, W ) ≡ ∃Y ≤ aUniv(X, Z, Y , W )(0)
and axiomatize TV 1 by the string induction axiom for UT  (X ), where
a, Z, W are parameters and UT  is a ΣB1 -formula equivalent to UT.
2
Since VP ⊆ V 1 (Theorem VIII.1.3) and TV 0 = VP (Theorem
VIII.3.10) it follows that TV 0 ⊆ V 1 . This is generalized in the following
result.
Theorem VIII.7.4. For i ≥ 0
V i ⊆ TV i ⊆ V i+1 .
Proof. The ﬁrst inclusion is Theorem VIII.3.4. For the second inclusion, by deﬁnition VIII.3.2 it suﬃces to show that V i+1 proves the
ΣBi -SIND induction scheme
[ϕ(∅) ∧ ∀X (ϕ(X ) ⊃ ϕ(S(X )))] ⊃ ϕ(Y )
where ϕ(X ) is a ΣBi -formula. Reasoning in V i+1 (VPV) (which by Theorem VIII.2.11 is conservative over V i+1 ) assume
ϕ(∅) ∧ ∀X (ϕ(X ) ⊃ ϕ(S(X ))).

(210)

Deﬁne the ΠBi+1 -formula



(i) ≡ ∀Z ≤ i ∀W ≤ |Y | (|W + Z| ≤ |Y | ∧ ϕ(W )) ⊃ ϕ(W + Z) .

By Corollary VI.1.4 applied to V i+1 we are justiﬁed in using number
induction on (i). The base case (0) is easy since ϕ(W ) ⊃ ϕ(S(W ))
by assumption (210). The induction step (i) ⊃ (i + 1) is proved
by using the hypothesis (i) twice, ﬁrst with (W, Z) set to (W, Z  ) with

VIII.7. More on V i and TV i

245

Z  =  21 Z and then with (W, Z) set to (W +Z  , Z  ) to infer ϕ(W +2Z  ),
from which (i + 1) follows (using the assumption (210) if 2Z  = Z).
Finally ϕ(Y ) follows from (|Y | + 1) and ϕ(∅).
2
From the above theorem we have the hierarchy
V 0 ⊂ TV 0 ⊆ V 1 ⊆ TV 1 ⊆ V 2 ⊆ TV 2 ⊆ V 3 ⊆ · · ·
so the unions of V i and TV i are the same. We use the notation


Vi =
TV i .
V∞ =
i

(211)

i

The next result follows from Theorem VIII.7.3 and compactness.
Corollary VIII.7.5. V ∞ is ﬁnitely axiomatizable iﬀ V ∞ collapses to
V or TV i for some i.
i

See Section VIII.7.3 for consequences of the collapse of V ∞ .
It is not known whether V ∞ (or equivalently S2 ) and IΔ0 are ﬁnitely
axiomatizable, although it is known that their relativized versions S2 (R)
 0 , Section VII.2.2) are not [75]. (For IΔ0 (R)
and IΔ0 (R) (or equivalently V
0

and V this follows also from the results of [71, 78].)
VIII.7.2. Deﬁnability in the V ∞ Hierarchy. See Table 3 page 250 for a
partial summary of the results in this section.
Recall that for i ≥ 1, ΣPi is the set of (two-sorted) relations in level
i of the polynomial hierarchy, and that these are precisely the relations
P
represented by ΣBi -formulas (Theorem IV.3.7). Also FPΣi is the set of
functions computable by a polynomial time Turing machine with a ΣPi
P
oracle. (See also Appendix A.3.) For i = 0, we will take FPΣ0 to be
simply FP (this is consistent with taking ΣP0 to be either P or AC 0 ). We
P
will show that for i ≥ 0, FPΣi is the class of functions ΣBi+1 -deﬁnable in
TV i , and also in V i+1 . (We have already shown this for i = 0.)
We start by generalizing the universal theory VPV to VPV i , for i ≥ 1.
Here VPV 1 = VPV, and for i ≥ 0 VPV i+1 has function symbols for all
P
functions in FPΣi . We use LFPi to denote the vocabulary of VPV i .
0
Since LFPi includes the vocabulary LFAC 0 of V , it includes symbols for
the string functions ∅, S, + deﬁned using ΣB0 -formulas in Example V.4.17.
Since we want the theories VPV i to be universal we take the deﬁning
axioms for these functions to be the quantiﬁer-free axioms for these func0
tions in V . Also for the present purposes string ordering X ≤ Y as
given in Deﬁnition VIII.3.5 is replaced by its equivalent quantiﬁer-free
0
deﬁnition in V . See Example VIII.3.12 for the deﬁnition of POW2(x).
We need functions to witness bounded existential string quantiﬁers,
just as fϕ(z),t as deﬁned in (87) (page 125) is used to witness bounded
existential number quantiﬁers. Thus let Gϕ,t (x, X ) be the least Y with

246

VIII. Theories for Polynomial Time and Beyond

|Y | ≤ t(x, X ) such that ϕ(x, X , Y ) holds, or POW2(t) if there is no such
Y . Then Gϕ,t has deﬁning axiom (suppressing x, X )


Gϕ,t ≤ POW2(t) ∧ Gϕ,t < POW2(t) ⊃ ϕ(Gϕ,t ) ∧


Y < Gϕ,t ⊃ ¬ϕ(Y ) . (212)
The deﬁnition of vocabularies LFPi is similar to Deﬁnition VIII.2.1
for LFP .
Deﬁnition VIII.7.6. The vocabularies LFP 1 ⊂ LFP2 ⊂ · · · are deﬁned
as follows.
(i) LFP1 = LFP .
(ii) For i ≥ 1 LFPi+1 is the smallest set that satisﬁes
(1) LFPi+1 ⊇ LFPi .
(2) For each open formula ϕ(x, X , Y ) over LFPi and term t(x, X )
of L2A there is a string function Gϕ,t in LFPi+1 .
(3) For each open formula ϕ(z, x, X ) over LFPi+1 and term t =
t(x, X ) of L2A there is a string function Fϕ(z),t in LFPi+1 .
(4) For each triple G, H, t, where G(x, X ) and H (y, x, X , Z) are
functions in LFPi+1 and t = t(y, x, X ) is a term in L2A , there is a
function FG,H,t in LFPi+1 .
Deﬁnition VIII.7.7. For i ≥ 1 the universal theory VPV i has vocabulary LFPi and (i) VPV 1 = VPV and (ii) for i ≥ 1 VPV i+1 contains
VPV i and has as (sometimes) additional deﬁning axioms (212) for each
function Gϕ,t in LFPi+1 and (177) for each function Fϕ(z),t in LFPi+1 and
(175), (176) (page 210) for each function FG,H,t in LFPi+1 .
Lemma VIII.7.8. For all i ≥ 0 for every ΣBi -formula there is an open
formula ϕ over LFPi+1 such that VPV i+1 proves ↔ ϕ.
Proof. We use induction on i. For i = 0 this is clear. Now suppose
i > 0 and is a ΣBi -formula. Then we may assume that ≡ ∃Y < t (Y ),
where  is ΠBi−1 . By the induction hypothesis there is an open formula ϕ
over LFPi such that VPV i proves  ↔ ϕ. Then VPV i+1 proves
ϕ(Gϕ,t ) ↔ ∃Y < tϕ(Y )
so VPV  ↔ ϕ(Gϕ,t ) and hence ϕ(Gϕ,t ) satisﬁes the Lemma.
2
Theorem VIII.7.9. For i ≥ 0 the string function symbols F of LFPi+1 repP
resent precisely the string functions in FPΣi and terms of the form |F (x, X )|
P
represent precisely the number functions of FPΣi .
Proof. The part about number functions follows from the part about
string functions, so we prove the latter. We use induction in i. For i = 0
this was observed when introducing LFP . For the induction step the proof
is similar to the proof of Cobham’s Theorem. To see that every string
i

VIII.7. More on V i and TV i

247

P

function in LFPi+1 is in FPΣi it suﬃces to show that this is true for each
of the cases in part (ii) of Deﬁnition VIII.7.6. For 3) and 4) this is true
because the functions computable by a polynomial time Turing machine
with a ΣPi oracle are closed under composition and limited recursion,
and such a machine can evaluate an open formula whose functions are
so computable. For 2), observe that such a machine can query its ΣPi
oracle to ﬁnd out for W ≤ POW2(t) whether there is Y ≤ W satisfying
ϕ(x, X , Y ), and hence use binary search to ﬁnd the least such Y (if any).
P
Conversely, to see that every string function in FP Σi is represented by
a function symbol in LFPi+1 , use limited recursion to deﬁne a function
like Conf M in the proof of Cobham’s Theorem VI.2.12 to compute the
conﬁgurations of the oracle Turing machine, where now the ΣPi oracle
queries are answered with the help of open formulas in Lemma VIII.7.8.
Now the value of F can be extracted using the output function OutM as
in (100) (page 140), so F (x, X ) = T (x, X ) for some term T of LFPi+1 .
Then F ≡ Fϕ(z),t where ϕ(z) ≡ T (z) and t is a bounding term for F . 2
The next result generalizes Theorem VIII.2.7.
Theorem VIII.7.10. For i ≥ 1 VPV i proves the ΣB0 (LFPi )-COMP,
B
Σ0 (LFPi )-IND, ΣB0 (LFPi )-MIN, and ΣB0 (LFPi )-MAX axiom schemes.
Proof. By Corollary V.1.8 it suﬃces to prove this for the case of COMP.
For every ΣB0 (LFPi )-formula ϕ there is an open LFPi -formula ϕ + such that
VPV i proves ϕ ↔ ϕ + (see the proof of Lemma V.6.3). The function Fϕ,y is
easily used to prove the comprehension axiom for an open formula ϕ. 2
Theorem VIII.7.11. For i ≥ 0, every function in LFPi+1 is ΣBi+1 -deﬁnable
in TV i , and VPV i+1 is a conservative extension of TV i .
Proof. For i = 0 this follows from Theorems VIII.2.11 a), VIII.2.17,
VIII.3.10, and Corollary VIII.2.18.
In general we show VPV i+1 extends TV i , by showing VPV i+1 proves
the ΣBi -SIND axioms (184). By Lemma VIII.7.8 we may assume that
ϕ is an open LFPi+1 -formula. Now proceed exactly as in the proof of
Theorem VIII.3.14, replacing VPV by VPV i+1 .
To show that the extension is conservative, and to show that every
LFPi+1 -function is ΣBi+1 -deﬁnable in TV i , by Theorem VIII.7.9 it suﬃces
P

to show that all functions in FPΣi are ΣBi+1 -deﬁnable in TV i , and (for
conservativity) that this can be done in such a way that the deﬁning
axioms for the LFPi+1 -functions are provable. We omit the latter (which
amounts to formalizing in TV i part of the proof of Theorem VIII.7.9),
and concentrate on the former.
P
Let F (x, X ) be a function in FPΣi , where i ≥ 1. Then some polynomial
time oracle Turing machine M computes F using an oracle ϕ(W ), where
ϕ is (represented by) a ΣBi -formula.

248

VIII. Theories for Polynomial Time and Beyond

Let t = t(x, X ) be a suitable L2A bounding term and let
CompM (x, X , U, W, Z)
be a ΣB0 -formula which asserts that U codes a computation of M on input
·
i)
x, X where for all i < t, W [i] is the ith oracle query (if any) and Z(t −
is the answer to this query.
Deﬁne (x, X , Z, Y ) to be
∃U ≤ t∃W ≤ tCompM (x, X , U, W, Z) ∧ Y = AnsM (U ) ∧
·
i) ⊃ ϕ(W [i] ))
∀i < t(Z(t −

where AnsM (U ) is the output of the computation coded by U . Let

(x, X , Z) be ∃Y < t (x, X , Z, Y ). Then  is a gΣBi -formula, which
TV i proves equivalent to a ΣBi -formula by the Replacement scheme (Corollary VI.3.8). Note that if  (x, X , Z) holds then the ‘true’ query answers
coded by Z must be correct, but ‘false’ answers may not be correct. However the largest Z satisfying  must code all correct answers, since if
·
the ith query is the ﬁrst incorrect answer then changing Z(t −
i) from
‘false’ to ‘true’ would increase Z no matter how the subsequent answers
are changed.
Since TV i proves the ΣBi -SMAX axioms (Theorem VIII.3.8) and VPV
proves  (x, X , ∅) it follows that TV i proves the existence of a largest Z,
|Z| < t, satisfying  (x, X , Z).
Thus we may use the following deﬁnition for F (x, X ).

Y = F (x, X ) ↔ ∃Z < t (x, X , Z, Y ) ∧

∀Z  < t(Z < Z  ⊃ ¬  (x, X , Z  )) .
The formula (x, X , Y ) on the RHS is equivalent to a ΣBi+1 -formula. Also
TV i proves the existence of a largest Z < t satisfying  (x, X , Z) and
hence the existence of Y satisfying (x, X , Y ). Finally V 0 (and hence
TV i ) proves the uniqueness of Y , since obviously there is at most one
largest Z satisfying  , and by ΣB0 -IND this Z uniquely determines U, W
in CompM and hence Y .
2
Theorem VIII.7.12. For i ≥ 0 the following are equivalent for a string
function F :
P

(i) F is in FPΣi .
(ii) F is ΣBi+1 -deﬁnable in TV i .
(iii) F is ΣBi+1 -deﬁnable in V i+1 .
(iv) F is ΣBi+1 -deﬁnable in VPV i+1 .
(v) F is ΣB1 (LFPi+1 )-deﬁnable in VPV i+1 .
Similarly for a number function f.

VIII.7. More on V i and TV i

249

Proof. (i) =⇒ (ii) by Theorems VIII.7.9 and VIII.7.11. (ii) =⇒ (iii)
by Theorem VIII.7.4. (iii) =⇒ (ii) by Theorem VIII.7.13. (ii) =⇒ (iv)
by Theorem VIII.7.11. (iv) =⇒ (v) by Lemma VIII.7.8. (v) =⇒ (i) by
Theorems VIII.2.4 and VIII.7.9.
2
i
i+1
B
Theorem VIII.7.13. For i ≥ 0 V
is Σi+1 -conservative over TV .
Proof. By Lemma VIII.7.8 every ΣBi+1 -formula ϕ is provably equivalent
in VPV i+1 to a ΣB1 (LFPi+1 )-formula ϕ  . Thus if V i+1 proves ϕ then V i+1 +
VPV i+1 proves ϕ  , and, arguing as in the proof of Theorem VIII.2.13,
VPV i+1 proves that ϕ  can be witnessed by functions in LFPi+1 . Thus
VPV i+1 proves ϕ  and ϕ, and so TV i proves ϕ by Theorem VIII.7.11. 2
P

The next result generalizes Theorem VIII.5.12. We deﬁne a PLS Σi
problem Q to be the same as in Deﬁnition VIII.5.4 except now the relation
ϕQ and the functions NQ and PQ are allowed to be polynomial time with
a ΣPi -oracle.
Theorem VIII.7.14. For i ≥ 1 a search problem Q is ΣBi -deﬁnable in
P
TV i iﬀ Q ≤AC 0 Q  for some PLS Σi−1 problem Q  .
Proof. The proof is very similar to the proof of Theorem VIII.5.12. InP
stead of an AC 0 -ITERATION problem we need an FPΣi−1 -ITERATION
P
problem, in which the function F is allowed to be in FPΣi−1 . To see that evP
P
ery PLS Σi−1 problem is many-one reducible to some FPΣi−1 -ITERATION
problem, we need to slightly alter the proof of Theorem VIII.5.8. The
diﬃculty in that proof is that the reducing function G is deﬁned by
G(U ∗t V ) = NQ (U ), where the neighborhood function NQ is now alP
lowed to be in FPΣi−1 instead of in FAC 0 . To ﬁx this, we change the
iterating function F in the proof to a function F  . The idea behind F
was to let its domain be concatenations U ∗t V where U is a candidate
solution for Q and V is its proﬁt. The idea behind F  is that its domain
consists of concatenations (U ∗t W ) ∗2t V where U and V are as before, and W = NQ (U ). Now we can deﬁne the reducing function G by
G((U ∗t W ) ∗2t V ) = W .
Exercise VIII.7.15. Work out the details in the deﬁnition of F  .
Continuing the proof of Theorem VIII.7.14, it remains to generalize
the witnessing theorem VIII.5.13 so that the assumption is
TV i  ∃Zϕ(x, X , Z)
P

where now ϕ is ΠBi−1 and QF is an FPΣi−1 -ITERATION -problem. By
Theorems VIII.7.11 and VIII.7.12 it suﬃces to replace TV i by TV i +VPV i
0
and ϕ by an open formula in LFPi , and V by VPV i . The proof is a
straightforward modiﬁcation of the proof of Theorem VIII.5.13, where
now the string induction rule (197) applies to ΣB1 (LFPi )-formulas A. 2

250

VIII. Theories for Polynomial Time and Beyond

The previous results characterize the search problems ΣBi -deﬁnable in
V and TV j when i = j and sometimes when i and j diﬀer by one.
In order to specify these search problems for more general i and j we
need to deﬁne a generalization of oracle Turing machines. (See also
Appendix A.3.)
j

Deﬁnition VIII.7.16. A witness query Y to an oracle ∃W ≤ t R(Y, W )
returns a witness W ≤ t satisfying R(Y, W ) if such exists, and otherwise
P
returns “NO”. For i ≥ 1, FPΣi [wit, O(g(n))] is the class of search problems Q solvable by a polynomial time Turing machine that makes O(g(n))
witness queries to a ΣPi oracle ∃W ≤ t R(Y, W ) for R ∈ ΠPi−1 .
Notice that a witness query can be simulated by polynomial many
Boolean queries, using binary search. Hence
P

P

FPΣi [wit, n O(1) ] = FPΣi .
P

However as far as we know, the class FPΣi [wit, O(g(n))] cannot be speciﬁed without referring to witness queries when g(n) is O(log n).

ΣB1

V0

TV 0

V1

TV 1

FAC 0

FP

FP

CC(PLS)

ΣP
1

ΣB2

FP [wit, O(1)]

ΣB3

FP Σ2 [wit, O(1)]

ΣB4

FP Σ3 [wit, O(1)]

ΣB5

FPNP [wit, O(1)] FPNP [wit, O(log n)]

P

FP Σ2 [wit, O(1)]

P

FP Σ3 [wit, O(1)]

FP Σ4 [wit, O(1)]

P

V2
ΣB1

CC(PLS)

ΣB2

FPNP

P

FPΣ2 [wit, O(1)]

P

FPΣ3 [wit, O(1)]

FP Σ4 [wit, O(1)]

P

P

FP Σ2 [wit, O(1)]

P

FP Σ3 [wit, O(1)]

FPΣ4 [wit, O(1)]

P

FP Σ4 [wit, O(1)]

TV 2

V3

TV 3

CC(PLS)NP

CC(PLS)NP

P

P

ΣB3 FPΣ2 [wit, O(log n)]

P

FPΣ2

FP Σ3 [wit, O(1)] FPΣ3 [wit, O(log n)]

P

FP Σ4 [wit, O(1)]

FP Σ3 [wit, O(1)]

ΣB5

FP Σ4 [wit, O(1)]

P

FPΣ2

P

ΣB4

FP NP
P

P

P

P

CC(PLS)Σ2

P

P

P

FPΣ4 [wit, O(1)]

P

FP Σ3
P

FP Σ4 [wit, O(1)]

Table 3. Deﬁnable search problems.
Theorem VIII.7.17.

(i) For i ≥ 1, a search problem Q is ΣBi+1 -deﬁP

nable in V i iﬀ Q ∈ FPΣi [wit, O(log n)].
(ii) For j ≥ 2 and V 0 ⊆ T ⊆ TV j−2 , a search problem Q is ΣBj -deﬁnable
P

in T iﬀ Q ∈ FPΣj−1 [wit, O(1)].

VIII.7. More on V i and TV i

251

Proof of (ii). By Theorem VIII.7.11 VPV j−1 extends TV j−2 and hence the ‘only if ’ direction is an easy consequence of the KPT Witnessing
Theorem (see Exercise VIII.7.19 below).
For the ‘if ’ direction it suﬃces to show that for j ≥ 2, V 0 can ΣBj -deﬁne
P

every search problem Q in FPΣj−1 [wit, O(1)]. For concreteness we show
this for j = 2; the general argument is essentially the same.
Let M be a polytime Turing machine which solves Q(x, X ) by making
at most a constant q number of queries to a ΣP1 witness oracle represented
by a ΣB1 -formula
(Y ) ≡ ∃W < t (Y, W )
where  is in ΣB0 . It is straightforward to give a ΣB2 -formula ϕ(x, X , Z)
which asserts that there is some computation C of M on input x, X with
correct answers to all oracle queries such that C outputs Z. However it is
more diﬃcult to ﬁnd such a formula such that V 0 proves ∃Zϕ.
To do this we ﬁrst observe that we can ﬁnd a machine M which is
equivalent to M but such that M makes all of its queries in parallel, so
that the answer to a query does not depend on the witness answer to any
other query. The machine M makes a witness query for each of the 2q
binary strings of length q, asking whether there is an apparently-correct
computation of M on input x, X such that the YES-NO answers to the
≤ q queries correspond to the bits of the string (or an initial segment).
Here ‘apparently-correct’ means that for each query Y to (Y ) a YES
answer must be supplied with a witness W satisfying (Y, W ), although
NO answers need not be veriﬁed. Each YES answer to a query to M
must include a witness which codes an apparently-correct computation of
M. From these witnesses M can ﬁnd a truly correct computation C of M
where no initial segment S of C ending in a NO answer coincides with an
initial segment S  of another computation except S  ends in a YES answer
to the same query.
The parallel queries made by M all have the form


(Y ) ≡ ∃W < t   (x, X , Y, W )

where   is ΣB0 -formula and Y is simply a bit string of length q. Now
we describe a ΣB2 -formula αM (x, X , Z) which asserts that Z is a possible
output of a correct computation of M on input x, X , and such that V 0
proves ∃ZαM . It suﬃces to describe αM (Z) as a disjunction of two ΣB2 1
2
1
(Z) ∨ αM
, where αM
(Z) makes the assertion as just stated
formulas αM
2
and αM is false.
Let ApCor(x, X , C ) be a ΣB0 -formula which asserts that C codes an
1
(Z) asserts
apparently-correct computation of M on input x, X . Then αM
the intended meaning of αM (Z) in the obvious way:
1
(Z) ≡ ∃C ∀W, ApCor(C ) ∧ ¬Wit(W, C ) ∧ Z = Out(C )
αM

252

VIII. Theories for Polynomial Time and Beyond

where we have omitted the bounds on the quantiﬁers and suppressed the
arguments x, X , and Wit(W, C ) is a ΣB0 -formula asserting that W is a
witness for some query in C which was (incorrectly) answered NO, and
Out(C ) is the output of the computation C .
1
Presumably V 0 does not prove ∃ZαM
(Z), so we need the false disjunct
2
αM , which asserts that there is no correct computation of M on input x, X .
2
Speciﬁcally αM
is a ΣB2 -formulas which asserts that there exists a sequence
W1 , . . . , W of potential witnesses to the  = 2q parallel queries made by
a computation of M such that for all apparently-correct computations C ,
one of the NO queries in C is in fact witnessed by some Wi . It suﬃces to
prove the following:
 1

2
Claim. V 0 proves ∃Z αM
(Z) ∨ αM
.
2
2
then (since Z does not occur in αM
) we can
Reasoning in V 0 , if αM
2
conclude ∃Z αM and we are done.
2
So assume ¬αM
. For each of the  = 2q queries Yi (which are simply
strings of length q), if ∃W  (Yi , W ) then let Wi be a witness satisfying
2
  (Yi , Wi ); otherwise let Wi = ∅. Since ¬αM
there exists an apparentlycorrect computation C such that none of the NO queries in C is witnessed
by any Wi . But by the way we chose Wi , this means that all NO queries
are correct, and hence C is a correct computation. Let Z = Out(C ).
1
(Z). Hence ∃Z αM (Z).
2
Then αM

Exercise VIII.7.18. Explain what goes wrong if we try to extend the
above proof to the case that M makes more than a constant number of
witness oracle queries.
Proof of (i). The ‘only if ’ direction can be proved using the same
method as for Theorem VI.4.1 (witnessing for V 1 ); see [70, 72] for details.
For the proof of the ‘if ’ direction let M be a polytime Turing machine
which solves Q(x, X ) by making O(log n) queries to a witness oracle represented by a formula (Y ) ≡ ∃W < t (Y, W ), where  is in ΠBi−1 . It
is easy to see that there is a ΣBi+1 -formula ϕ(x, X , Z) which asserts that
Z ∈ Q(x, X ) by asserting that there is a computation of M on input x, X
with output Z such that if Y [i] codes the ith query and W [i] codes the ith
answer, then either (Y [i] , W [i] ) or ¬ (Y [i] ) and W [i] = ‘NO’.
In order to show that V i proves ∃Zϕ(x, X , Z) we use the fact that V i
proves the ΣBi -MAX axiom scheme (Corollary VI.1.4) and argue as in the
proof of Theorem VIII.7.11. Thus V i proves there is a largest n < t (for
suitable t) satisfying the ΣBi -formula α(n, x, X ), which asserts that there
exists a computation of M as above and there exists the query sequence Y
and answer sequence W such that the bits of the reverse binary notation for
n code the Boolean answers to the successive queries of the computation,
2
and for all i, if the ith query answer is positive, then (Y [i] , W [i] ).

VIII.7. More on V i and TV i

253

Exercise VIII.7.19. Show using the KPT Witnessing Theorem VIII.6.1
that for i ≥ 1 if a search problem Q is ΣBi+1 -deﬁnable in VPV i then Q is
P

in FPΣi [wit, O(1)].
VIII.7.3. Collapse of V ∞ vs Collapse of PH. It is an open question
whether V ∞ (the union of the theories V i ) collapses to some particular V i .
Since each V i is ﬁnitely axiomatizable (Theorem VIII.7.3), this question
is equivalent to asking whether V ∞ is ﬁnitely axiomatizable. As far as
we know it is possible that the polynomial hierarchy PH could collapse
without V ∞ collapsing. (For example there might be a polynomial time
algorithm for propositional satisﬁability whose correctness is not provable
in V ∞ .) However if some V i proves that PH collapses, then V ∞ collapses
to V i . That is, if for every ΣBi+1 -formula ϕ there is a ΣBi -formula ϕ  such
that V i proves ϕ ↔ ϕ  , then V i proves ΣBi+1 -COMP, so V i+1 = V i . But
the same assumption shows that V i+2 = V i+1 , and so on, so V ∞ = V i .
The following theorem is an application of KPT Witnessing, and shows
that the converse also holds: if V ∞ collapses to V i then V i proves that
P
PH collapses. (This would be obvious if a function is in FPΣi−1 iﬀ it is
ΣB1 -deﬁnable in V i , as opposed to ΣBi -deﬁnable in V i as stated in Theorem VIII.7.12.)
Theorem VIII.7.20 ([75, 26, 112]). For i ≥ 0 if TV i = V i+1 then TV i =
V and ΣPi+2 = ΠPi+2 = PH and TV i proves ΣPi+3 = ΠPi+3 = PH.
∞

Corollary VIII.7.21. V ∞ is ﬁnitely axiomatizable iﬀ some V i proves
that PH collapses.
Partial proof of Theorem VIII.7.20. For readability we treat the case
i = 0; the general case is similar. (See the remark at the end of this
proof.) Assuming TV 0 = V 1 we show that PH collapses to P/poly and
provably collapses to NP/poly, where poly refers to polynomial “advice”,
as explained below. It follows from the methods of Karp and Lipton [66]
that PH collapses to ΣP2 = ΠP2 and provably collapses to ΣP3 = ΠP3 . The
proof that TV 0 = V 1 implies TV 0 = V ∞ can be obtained from [26].
Since VPV is a conservative extension of TV 0 (Theorem VIII.7.11) and
1
V (VPV) = V 1 + VPV (Section VIII.2.1) our assumption TV 0 = V 1 is
equivalent to VPV = V 1 (VPV).
The assertion “Every sequence α1 , . . . , αm of propositional formulas
has an initial sequence of maximal length  of satisﬁable formulas” is
expressible by a formula
≡ ∀X ∃Y ∀Zϕ(X, Y, Z)
where ϕ is an open LFP -formula. Here X codes the sequence α1 , . . . , αm
and ϕ asserts that Y codes a sequence of satisfying assignments to the the
ﬁrst  formulas of X for some  ≤ m, and also that if  < m then Z codes
an assignment which falsiﬁes α+1 .

254

VIII. Theories for Polynomial Time and Beyond

by applying the ΣB1 -MAX axioms (Corollary
V 1 (VPV) proves
B
VIII.2.12) to the Σ1 (LFP )-formula expressing the condition that the ﬁrst
 formulas coded by X are satisﬁable. Hence by our assumption, VPV
proves , so by the KPT Witnessing Theorem there are polytime functions
F1 , . . . , Fk such that VPV proves
ϕ(X, F1 (X ), Z1 ) ∨ ϕ(X, F2 (X, Z1 ), Z2 ) ∨ · · · ∨
ϕ(X, Fk (X, Z1 , . . . , Zk−1 ), Zk ).

(213)

Note that each function Fi plays the role of Y , and hence should code a
sequence of assignments satisfying some initial segment of the formulas
coded by X . From these functions F1 , . . . , Fk we obtain polytime functions G1 , . . . , Gk such that VPV proves that for every sequence α1 , . . . , αk
of propositional formulas with satisfying assignments Z1 , . . . , Zk there is

) codes a satisfying assignan i, 1 ≤ i ≤ k, such that Gi (X, Z1 , . . . , Zi−1
ment for αi (we say that Gi ‘wins’ in this case).
The algorithm for evaluating G1 (X ) proceeds by computing W1 =
F1 (X ). If the sequence W1 begins with an assignment satisfying α1 , then
G1 (X ) is set to that assignment, so G1 wins. Otherwise the algorithm
for G2 (X, Z1 ) sets Z1 = Z1 , so the ﬁrst disjunct ϕ(F1 (X ), Z1 ) in (213)
is false (since by assumption Z1 satisﬁes α1 ). Now the G2 algorithm
computes W2 = F2 (X, Z1 ). If W2 includes an assignment satisfying α2 ,
then G2 (X, Z1 ) is set to that assignment, and G2 wins. Otherwise the
algorithm for G3 (X, Z1 , Z2 ) sets Z2 to either Z1 or Z2 depending on
F2 (X, Z1 ), so that the second conjunct ϕ(X, F2 (X, Z1 ), Z2 ) in (213) is
false. Then G3 is set to an assignment in F3 (X, Z1 , Z2 ) which satisﬁes α3 ,
if one exists. In general, if none of G1 , . . . , Gi−1 wins, then the algorithm
for Gi chooses Z1 , . . . , Zi−1 so the ﬁrst i − 1 disjuncts in (213) are false,
and evaluates Fi (X, Z1 , . . . , Zi−1 ), looking for an assignment that satisﬁes
αi . At least one of G1 , . . . , Gk must win, since otherwise Z1 , . . . , Zk can
be chosen so as to falsify (213).
P/poly is the class of problems solvable by a polynomial size family
of Boolean circuits, or equivalently the class of problems solvable by a
polynomial time Turing machine which is allowed a polynomial length
advice string An for each input length n. In order to show that NP ⊆
P/poly it suﬃces to deﬁne a polytime relation R(X, Y ) such that for each
n there is an advice string An of length bounded by a polynomial in n so
that for every propositional formula α of length n, R(α, An ) holds iﬀ α is
satisﬁable.
We now explain how to use the functions G1 , . . . , Gk to deﬁne R and
An . For each satisﬁable propositional formula α of length n we associate
a ﬁxed assignment Zα which satisﬁes α. We deﬁne a map H which takes
a k-tuple X = (α1 , . . . , αk ) of distinct satisﬁable propositional formulas
of length n, where the formulas in X are ordered lexicographically, to a

VIII.7. More on V i and TV i

255

(k−1)-tuple of such formulas, where H (X ) is obtained from X by deleting
the ﬁrst formula αi such that the assignment Gi (X, Zα1 , . . . , Zαi−1 ) satisﬁes
αi . The domain of H has size (the number of ordered k-tuples X )
C (C − 1) . . . (C − k + 1)
and the range of H has size
C (C − 1) . . . (C − k + 2).
Each (k − 1)-tuple has at most k preimages. Hence there is a (k − 1)tuple ( 1 , . . . , k−1 ) of formulas which is the image under H of at least
(C − k + 1)/k diﬀerent k-tuples. Part of the advice string An codes the
sequence 1 , . . . , k−1 , Z 1 , . . . , Z k−1 . Each of the k-tuples mapping to
( 1 , . . . , k−1 ) consists of ( 1 , . . . , k−1 ) with a new formula α inserted
somewhere. Further distinct such k-tuples have distinct inserted formulas
α, since the formulas in the tuples are ordered lexicographically. Hence
there are at least (C − k + 1)/k such formulas α, and each such α has a
satisfying assignment which can be computed from the advice string An
using G1 , . . . , Gk .
Now delete this set of at least (C − k + 1)/k formulas α from the set
of satisﬁable formulas of length n, and apply the above process to the
set of remaining formulas, obtaining another (k − 1)-tuple of formulas
and satisfying assignments to add to the advice string An . After O(log n)
such iterations, an advice string An of length O(n log n) is obtained which,
using the functions G1 , . . . , Gk suﬃces to compute a satisfying assignment
to any satisﬁable formula of length n. This yields the required polynomial
time procedure with advice for solving the satisﬁability problem.
The correctness proof for the above P/poly procedure seems to require
a counting argument which cannot (as far as we know) be formalized in
V ∞ . We now show how to deﬁne an advice string An which can be used to
put the satisﬁability problem in co-NP/poly, provably in V 2 . Again we use
the functions G1 , . . . , Gk described above. The idea is to ﬁnd the smallest
, 1 ≤  ≤ k, such that there exists formulas α+1 , . . . , αk of length n (not
necessarily satisﬁable) such that for all tuples (α1 , . . . , α ) of satisﬁable
formulas of length n, and all tuples (Z1 , . . . , Z ) of satisfying assignments
for α, there exists i ≤  such that Gi (α1 , . . . , αk , Z1 , . . . , Zi−1 ) codes a satisfying assignment for αi . V 2 proves the existence of  and α+1 , . . . , αk
by the ΣB2 -MIN axioms (note that k is a candidate for ). The advice
An is the tuple α+1 , . . . , αk . Then an arbitrary formula α of length n
is satisﬁable iﬀ for all tuples (α1 , . . . , α−1 ) and satisfying assignments
(Z1 , . . . , Z−1 ) there exists i ≤  such that Gi (α1 , . . . , αk , Z1 , . . . , Zi−1 )
codes a satisfying assignment for αi . (The ‘if ’ direction follows from the
minimality of .) Hence we have expressed length n satisﬁability with a ΠB1

256

VIII. Theories for Polynomial Time and Beyond

formula involving the advice An , which shows that the satisﬁability problem is in co-NP/poly, and hence PH collapses to NP/poly = co-NP/poly,
as desired.
To prove this theorem for i > 0, replace VPV by VPV i , and replace
the propositional formulas α by quantiﬁed propositional formulas with a
quantiﬁer preﬁx limited to i alternations beginning with ∃.
2

VIII.8. RSUV Isomorphism
Recall the hierarchies of single-sorted theories S2i and T2i (for i ≥ 1)
from Section III.5. In particular, S21 characterizes the class single-sorted
P in much the same way as V 1 characterizes the class (two-sorted) P
(Theorem VI.2.2 and Corollary VI.2.4). Here we will show that each
theory S2i is essentially a single-sorted version of V i (for i ≥ 1), i.e., they
are “RSUV isomorphic” (the same is true for T2i and TV i ).
This section is organized as follows. First we formally deﬁne S2i and T2i .
Then in Section VIII.8.2 we deﬁne the notion of an RSUV isomorphism as
a bijection between classes of single-sorted and two-sorted models. These
are associated with the syntactical translations of single-sorted and twosorted formulas, deﬁned in Subsections VIII.8.3 and VIII.8.4. Finally we
sketch a proof of the RSUV isomorphism between S21 and V 1 .
VIII.8.1. The Theories S2i and T2i . For this subsection it is helpful to
revisit Sections III.1, III.5, and IV.3.2. Recall that the vocabulary for S21
is
1
LS2 = [0, S, +, ·, #, |x|,  x; =, ≤]
2
where |x| is the length of the binary representation of x, and the function
x#y = 2|x|·|y| provides the polynomial growth in length for the terms of
LS2 .
The sharply bounded quantiﬁers are bounded quantiﬁers (Deﬁnition
III.1.6) which are of the form ∃x ≤ |t| and ∀x ≤ |t|. The syntactic classes
of bounded formulas of LS2 are deﬁned as follows.
Deﬁnition VIII.8.1 (Bounded Formulas of LS2 ). Δb0 = Σb0 = Πb0 is the
set of formulas whose quantiﬁers are sharply bounded. For i ≥ 0, Σbi+1
and Πbi+1 are the smallest sets of formulas that satisfy:
1) Πbi ⊆ Σbi+1 , Σbi ⊆ Πbi+1 .
2) If ϕ, ∈ Σbi+1 (or Πbi+1 ), then so are ϕ ∧ , ϕ ∨ .
3) If ϕ ∈ Σbi+1 (resp. ϕ ∈ Πbi+1 ), then ¬ϕ ∈ Πbi+1 (resp. ¬ϕ ∈ Σbi+1 ).
4) If ϕ ∈ Σbi+1 (resp. ϕ ∈ Πbi+1 ), then ∃x ≤ t ϕ and ∀x ≤ |t| ϕ are in
Σbi+1 (resp. ∀x ≤ t ϕ and ∃x ≤ |t| ϕ are in Πbi+1 ).

VIII.8. RSUV Isomorphism

257

Notice that diﬀerent from ΣBi and ΠBi (Deﬁnition IV.3.2), here the
formulas in Σbi and Πbi are not required to be in prenex form, and any
bounded quantiﬁer can occur in the scope of a sharply bounded quantiﬁer.
Nevertheless, it can be shown that for i ≥ 1, a single-sorted relation is in
the (single-sorted) class Σpi if and only if it is represented by a Σbi formula.
In particular, a single-sorted relation is in NP if and only if it is represented
by a Σb1 formula. (See Deﬁnition IV.3.3 and the ΣBi and Σ11 Representation
Theorem IV.3.7.)
The set BASIC of the deﬁning axioms for symbols in LS2 are given in
Figure 3. There 1 and 2 are the numerals S0 and SS0, respectively. Note
that BASIC is by no means optimal, i.e., it is possible to derive some of
its axioms from others. Here we are not concerned with its optimality.
1. x ≤ y ⊃ Sx ≤ Sy
18. |x| = |u| + |v| ⊃
2. x = Sx
x#y = (u#y) · (v#y)
3. 0 ≤ x
19. x ≤ x + y
4. (x ≤ y ∧ x = y) ↔ Sx ≤ y
20. x ≤ y ∧ x = y ⊃
5. x = 0 ⊃ 2 · x = 0
S(2 · x) ≤ 2 · y∧
6. x ≤ y ∨ y ≤ x
S(2 · x) = 2 · y
7. (x ≤ y ∧ y ≤ x) ⊃ x = y
21. x + y = y + y
8. (x ≤ y ∧ y ≤ z) ⊃ x ≤ z
22. x + 0 = x
9. |0| = 0
23. x + Sy = S(x + y)
10. |S0| = S0
24. (x + y) + z = x + (y + z)
11. x = 0 ⊃ (|2 · x| = S(|x|)∧
25. x + y ≤ x + z ↔ y ≤ z
|S(2 · x)| = S(|x|)) 26. x · 0 = 0
12. x ≤ y ⊃ |x| ≤ |y|
27. x · Sy = (x · y) + x
13. |x#y| = S(|x| · |y|)
28. x · y = y · x
14. 0#x = S0
29. x · (y + z) = (x · y) + (x · z)
15. x = 0 ⊃ (1#(2 · x) = 2 · (1#x) 30. 1 ≤ x ⊃ (x · y ≤ x · z ↔ y ≤ z)
∧ 1#S(2 · x)) = 2 · (1#x)) 31. x = 0 ⊃ |x| = S(| 12 x|)
16. x#y = y#x
32. x =  12 y ↔
17. |x| = |y| ⊃ x#z = y#z
(2 · x = y ∨ S(2 · x) = y)
Figure 3. BASIC.
Recall the deﬁnition of an induction scheme Φ-IND (Deﬁnition III.1.4).
For formulas of LS2 there are other kinds of induction, namely length
induction and polynomially induction, which are deﬁned below.
Deﬁnition VIII.8.2 (LIND and PIND). Let L be a vocabulary which
extends LS2 , and Φ be a set of L-formulas. Then Φ-LIND is the set of
formulas of the form



ϕ(0) ∧ ∀x(ϕ(x) ⊃ ϕ(x + 1)) ⊃ ∀zϕ(|z|)

(214)

258

VIII. Theories for Polynomial Time and Beyond

and Φ-PIND is the set of formulas of the form


ϕ(0) ∧ ∀x(ϕ( 12 x) ⊃ ϕ(x)) ⊃ ∀zϕ(z)

(215)

where ϕ is a formula in Φ, ϕ(x) is allowed to have free variables other
than x.
Deﬁnition VIII.8.3 (S2i and T2i ). For i ≥ 1, S2i is the theory axiomatized by BASIC and Σbi -PIND; T2i is the theory axiomatized by BASIC
and Σbi -IND.
We leave as an exercise the following interesting results (for (b) see also
Theorem VIII.7.4):
Exercise VIII.8.4. Show that for i ≥ 1:
(a) S2i can be axiomatized by BASIC together with Σbi -LIND.
(b) S2i ⊆ T2i ⊆ S2i+1 .
S21 and V 1 turn out to be essentially the same, as explained in the next
subsection.
VIII.8.2. RSUV Isomorphism. Here we deﬁne the notion of RSUV
isomorphism model-theoretically by deﬁning the  and  mappings between
single-sorted and two-sorted models. These (semantic) mappings are
associated with the syntactical translations between of single-sorted and
two-sorted formulas, to be deﬁned in later sections.
Recall that BIT(i, x) is the relation which holds if and only if the i-th
lower-order bit in the binary representation of x is 1. It is left as an exercise
to show that this relation is Σb1 -deﬁnable in S21 . It follows that S21 (BIT) is
a conservative extension of S21 .
Exercise VIII.8.5. Show that BIT(i, x) is Σb1 -deﬁnable in S21 , and that
S21 (BIT)  ∀x∀y, x = y ↔ (|x| = |y|∧∀i ≤ |x|, BIT(i, x) ↔ BIT(i, y)).
Now let M be a model of S21 with universe U . We can construct from
M a two-sorted L2A -structure N as follows. First, expand M to include
the interpretation of BIT. The universe U1 , U2  of N is deﬁned to be
U2 = U,

and

U1 = {|u| : u ∈ U }.

The constants 0 and 1 are interpreted as 0 and S0 respectively (which are
in U1 , by the axioms 9 and 10 of BASIC). The interpretations of the other
symbols of L2A (except for ∈) in N are exactly as in M. (Note that by this
deﬁnition, | | is clearly a function from U2 to U1 .) Finally ∈ is interpreted
as
i ∈N x ⇔ BIT(i, x) holds in M,

for all i ∈ U1 , x ∈ U2 .

Deﬁnition VIII.8.6. For a model M of S21 , denote by M the twosorted structure N obtained as described above.

VIII.8. RSUV Isomorphism

259

Conversely, suppose that N is a model of V 1 with universe U1 , U2 .
We can construct from N a (single-sorted) LS2 -structure M with universe
U = U2 where each bounded set X in U2 is interpreted as the number
bin(X ) (see (46) on page 85):
X (i)2i .

bin(X ) =
i

In order to interpret the symbols of LS2 in M, we need the fact that
the functions and predicates of LS2 when interpreted as taking string
arguments are respectively provably total and deﬁnable in V 1 .
In fact, by Exercise VI.2.7 the string multiplication function X × Y
is Σ11 -deﬁnable in V 1 . Also, using the fact that BIT(i, x) is deﬁnable in
IΔ0 (Subsection III.3.3) and that V 0 is a conservative extension of IΔ0
(Theorem V.1.9), we have BIT(i, x) is ΣB0 -deﬁnable in V 0 :
Corollary VIII.8.7. The relation BIT(i, x) is ΣB0 -deﬁnable in V 0 .
Thus the string function |X |2 whose bit-graph is
|X |2 (i) ↔ (i ≤ |X | ∧ BIT(i, |X |))
is provably total in V 0 .
The string relation X ≤ Y is deﬁned in Deﬁnition VIII.3.5. The
constant 0 is interpreted as the empty set ∅, which is deﬁned in V 0 by
Exercise V.4.19. The successor and addition functions on strings are also
deﬁnable in V 0 (Exercise V.4.19). Finally, the functions X #Y and  21 X 
can be deﬁned in V 0 using ΣB0 -COMP as follows:
(X #Y )(z) ↔ z = |X | · |Y | + 1,

 12 X (z) ↔ z ≤ |X | ∧ z + 1 ∈ X.

Deﬁnition VIII.8.8. For a model N of V 1 , let N  denote the singlesorted LS2 -structure M constructed as above.
Deﬁnition VIII.8.9 (RSUV Isomorphism). Let T1 be a single-sorted
theory over LS2 and T2 be a two-sorted theory over L2A so that S21 ⊆ T1
and V 1 ⊆ T2 . Then T1 and T2 are said to be RSUV isomorphic (denoted
RSUV

by T1 ≃ T2 ) if (i) for every model M of T1 , M |= T2 , and (ii) for every
model N of T2 , N  |= T1 .
Note that we can loosen the restrictions that S21 ⊆ T1 and V 1 ⊆ T2 by,
for example, imposing that BIT is deﬁnable in T1 , and X × Y is deﬁnable
in T2 (while maintaining that T1 extends a certain subtheory of S21 , and T2
extends V 0 ). This allows us to speak of the RSUV isomorphism between
subtheories of S21 and V 1 .
The main result of this section is stated below.
Theorem VIII.8.10. For i ≥ 1, S2i and V i are RSUV isomorphic, and

T2i and TV i are RSUV isomorphic.

260

VIII. Theories for Polynomial Time and Beyond

Associated with the  and  mappings deﬁned above are respectively
the  and  translations of formulas that we will introduce shortly. For
example, one direction of Theorem VIII.8.10 (for i = 1) requires showing
that M |= V 1 for every model M of S21 (BIT). Thus we will translate
syntactically each L2A formula ϕ into an LS2 (BIT) formula ϕ  (the 
translation) so that
M |= ∀ϕ if and only if M |= ∀ϕ  .
(Recall that ∀ϕ is the universal closure of ϕ. See Deﬁnition II.2.22.) Then
we will prove that S21 (BIT)  ϕ  for each axiom ϕ of V 1 .
The  translation is essentially the inverse of the  translation. The
RSUV isomorphism between S21 and V 1 is pictured below (Figure 4).
RSUV

≃
V1

M

ϕ

N


Figure 4. The RSUV isomorphism between S21 and V 1 .
S21
M
ϕ
N

In the next two subsections we deﬁne the  and  translations. The proof
of Theorem VIII.8.10 will be given in Subsection VIII.8.5.
VIII.8.3. The  Translation. The sharply bounded quantiﬁers in a bounded LS2 -formula are translated into bounded number quantiﬁers, and
other bounded quantiﬁers are translated into bounded string quantiﬁers.
In other words, a bound variable is translated into a bound number variable if it is sharply bounded. (Note that the bounding term of a bounded
string quantiﬁer bounds the length of the quantiﬁed variable, while in
single-sorted logic the bounding terms are for the values of the variables.)
It can be easily seen that simply translating bounded quantiﬁers as above
results in bounded (two-sorted) formulas over the vocabulary that extends
L2A by taking the functions (except 0) and predicates of LS2 to be twosorted functions and predicates whose arguments can be of either sort.
For example, there are formally four + functions: one with arity 2, 0,
two with arity 1, 1 and one with arity 0, 2. Also, it is straightforward
to determine the sorts to which these functions belong. Thus x + Y and
X + Y are string functions, while |x| is a number function.
Notation. Let L+ denote the extension of L2A described above.
The functions of L+ can be shown to be ΣB1 -deﬁnable in V 1 . In fact, the
number functions and most of the string functions of L+ (except for the
string multiplication function, or the multiplication functions of “mixed”
sorts) are respectively ΣB0 -deﬁnable (in V 0 ) and ΣB0 -bit-deﬁnable. For

261

VIII.8. RSUV Isomorphism

example, the number functions |x| and x#y are ΣB0 -bit-deﬁnable due to the
fact that the predicate BIT(i, x) is Δ0 -deﬁnable in IΔ0 (Subsection III.3.3).
For the fact that the afore-mentioned multiplication functions are ΣB1 deﬁnable in V 1 , see Exercise VI.2.7 and the discussion in the previous
subsection about the  mapping.
The next Corollary follows from Corollary VI.3.11 and Corollary
VI.3.8.
Corollary VIII.8.11. V 1 (L+ )  gΣB1 (L+ )-IND.
Now we deﬁne for each bounded LS2 formula (x, y) a bounded L+
formula  (x, Y ) (i.e., the subset y of the free variables of is selected to
be translated into the free string variables of  ) so that for every model
N of V 1 ,
N  |= ∀x∀y (|x|, y) if and only if

N [L+ ] |= ∀x∀Y



(x, Y )

(where N [L ] denote the expansion of N by including the interpretations
for L+ ). We will focus on the case where all bounding terms of are of
the form t(x, y) (i.e., they involve only the free variables of ). We need
the following result whose proof is left as an exercise.
+

Exercise VIII.8.12. Let t(x, y) be an LS2 term. Let T (x, Y ) be the
L+ term obtained from t(x, y) by replacing the variables y by new string
variables Y , and treating the functions occurring in t as the corresponding
functions of L+ . Then there is an L2A term t  (x, |Y |) so that V 1 (L+ ) 
|T (x, Y )| ≤ t  (x, |Y |).
The formula  (x, Y ) is constructed inductively as follows. First if
(x, y) is an atomic formula, then  (x, Y ) is the atomic formula obtained from (x, y) by translating the free variables y into free string
variables Y , and translating the symbols of LS2 into the appropriate symbols of L+ .
Next, if is 1 ∧ 2 (resp. 1 ∨ 2 ), then  is 1 ∧ 2 (resp. 1 ∨ 2 ).
If
≡ ¬ 1 , then  is obtained from of ¬ 1 by pushing the ¬ to the
atomic subformulas.
Now consider the case where (x, y) ≡ ∃z ≤ t 1 (z, x, y). Let T (x, Y )
and t  (x, |Y |) be as in Exercise VIII.8.12. Then



(x, Y ) ≡ ∃Z ≤ 1 + t  (x, |Y |) Z ≤ T (x, Y ) ∧ 1 (Z, x, Y ) .
Next, suppose that (x, y) ≡ ∃z ≤ |t| 1 (z, x, y). Then



(x, Y ) ≡ ∃z ≤ t  (x, |Y |) z ≤ |T (x, Y )| ∧ 1 (z, x, Y ) .
The cases where (x, y) ≡ ∀z ≤ t 1 (z, x, y) or (x, y) ≡ ∀z ≤
|t| 1 (z, x, y) are handled similarly. This completes our description of the

translation. The proof of its desired properties are left as an exercise.
Exercise VIII.8.13. Let

(x, y) be an L2A -formula.

262

VIII. Theories for Polynomial Time and Beyond

(a) Show that if is in Σbi (resp. Πbi ) for some i ≥ 0, then
gΣBi (L+ ) (resp. gΠBi (L+ )).
(b) Let N be a model of V 1 . Show that
N  |= ∀x∀y (|x|, y) if and only if


N [L+ ] |= ∀x∀Y





(Y ) is in

(x, Y ).



VIII.8.4. The Translation. The translation is essentially a syntactical
counter-part of the  mapping. In general we will translate bounded string
quantiﬁers into bounded quantiﬁers, and bounded number quantiﬁers
into sharply bounded quantiﬁers. Thus we need to ﬁnd the translation
t  for each bounding term t. This task is left as an exercise (see also
Exercise VIII.8.12).
Exercise VIII.8.14. Let t(x, |Y |) be an L2A -term, and t1 (x, |y|) be the
LS2 -term obtained from t by replacing each the string variables Y by new
variables y, and replacing each occurrence of 1 by S0. Then there is an
LS2 -term t  (x, y) so that S21  t1 (|x|, |y|) ≤ |t  (x, y)|.
We also need the following results, which follows from the fact that BIT
is Σb1 -deﬁnable in S21 .
Notation. Let L+
S2 stand for LS2 ∪ {BIT}.
Exercise VIII.8.15. Show that S21 (BIT ) proves both axiom schemes
Σb1 (BIT)-LIND and Σb1 (BIT)-IND.
As in the  translation, we will consider only those formulas whose
bounding terms involve only the free variables. Thus suppose that ϕ(x, Y )
is a bounded formula whose bounding terms are of the form t(x, |Y |) (with

all variables displayed). Then the L+
S2 formula ϕ (x, y) has the same set
of variables as that of ϕ (where each string variable Y is replaced by a new
variable y) and satisﬁes
M |= ∀x∀Y ϕ(x, Y )

if and only if

M |= ∀x∀yϕ  (|x|, y)

for any model M of S21 (BIT).
The formula ϕ  (x, y) is deﬁned inductively as follows. First, if ϕ(x, Y )
is an atomic formula, then let ϕ  (x, y) be obtained from ϕ(x, y) by
• replacing each occurrence of 1 by S0,
• replacing each occurrence of Y (t) by BIT(t, Y ), and
• replacing each occurrence of a string variable Y by the corresponding new variable y.
For the induction step, if ϕ ≡ (ϕ1 ∧ ϕ2 ) (resp. (ϕ1 ∨ ϕ2 ), ¬ϕ1 ), then
deﬁne ϕ  ≡ (ϕ1 ∧ ϕ2 ) (resp. (ϕ1 ∨ ϕ2 ), ¬ϕ1 ).
Next consider the case where ϕ(x, Y ) ≡ ∃Z ≤ t(x, |Y |) ϕ1 (x, Y , Z).
Let t  (x, y) be as in Exercise VIII.8.14. Then


ϕ  (x, y) ≡ ∃z ≤ S0 + t  (x, y) |z| ≤ t(x, |y|) ∧ ϕ1 (x, y, z) .

VIII.8. RSUV Isomorphism

263

Now consider the case where ϕ(x, Y ) ≡ ∃u ≤ t(x, |Y |) ϕ1 (u, x, Y ).
Let t  (x, y) be as before. Then deﬁne


ϕ  (x, y) ≡ ∃u ≤ |t  (x, y)| u ≤ t(x, |y|) ∧ ϕ1 (u, x, y) .
The cases where ϕ(x, Y ) ≡ ∀Z ≤ t(x, |Y |) ϕ1 (x, Y , Z) or ϕ(x, Y ) ≡
∀u ≤ t(x, |Y |) ϕ1 (u, x, Y ) are handled analogously. This completes our
description of the  translation.
The desired properties of ϕ  can be proved by structural induction on
ϕ. Details are left as an exercise.
Exercise VIII.8.16. Let ϕ(x, Y ) be an L2A -formula.
(a) Show that if ϕ is in ΣBi (resp. ΠBi ) for some i ≥ 0, then ϕ  (|x|, y) is
in Σbi (BIT) (resp. Πbi (BIT)).
(b) Let M be a model of S21 (BIT). Show that
M |= ∀x∀Y ϕ(x, Y ) if and only if

M |= ∀x∀Y ϕ  (|x|, y).

VIII.8.5. The RSUV Isomorphism between S2i and V i . In this subsection we will sketch the proof of the RSUV isomorphism between S21 and
V 1 . The proof of the RSUV isomorphism between S2i and V i for i ≥ 2 is
similar, and is left as an exercise.
First, the next theorem is useful in proving RSUV isomorphism.
Notation. We will assume that the theories mentioned here are axiomatized by set of formulas whose bounding terms do not contain any bound
variable.
Theorem VIII.8.17. Let T1 be a single-sorted theory over LS2 such that
S21 ⊆ T1 , and T2 be a two-sorted theory over L2A such that V 1 ⊆ T2 . Suppose
that (i) T1 (BIT)  ϕ  for every axiom ϕ of T2 , and (ii) T2 (L+ )   for
every axiom

RSUV

of T1 . Then T1 ≃ T2 .

Proof. We show that M |= T2 for every model M of T1 . The other
half (that N  |= T1 for every model N of T2 ) is similar.
Thus suppose that M |= T1 (BIT). Then by (i) we have M |= ϕ  for
every axiom ϕ of T2 . By Exercise VIII.8.16 (b) it follows that M |=
T2 .
2
↔ (  ) and V 1 (L+ ) 
Exercise VIII.8.18. Show that S21 (BIT ) 
 
ϕ ↔ (ϕ ) for every bounded LS2 formula and bounded L2A formula ϕ.
Notice that by Theorem VIII.8.10, if M is a model of S21 , then M is a
model of V 1 . Hence we can deﬁne (M ) . Similarly, if N is a model of
V 1 , then (N  ) is well-deﬁned. The  and  operations deﬁne a bijection
between isomorphism classes of models of S21 and V 1 , as shown in the
next corollary.

264

VIII. Theories for Polynomial Time and Beyond

Corollary VIII.8.19. Let T1 be a single-sorted theory that extends S21 .
Then (M ) and M are same for every model M of T1 . Similarly, suppose
that T2 is a two-sorted theory that extends V 1 . Then (N  ) is isomorphic to
N for every model N of T2 .
Proof sketch. First, let M be a model of T1 . Clearly M and (M )
have the same universe. Indeed, the mappings
U (M) −→ U2 (M ) −→ U ((M ) )
are all identity maps. (Here U (M) and U ((M ) ) denote respectively the
universe of M and (M ) , and U2 (M ) denotes the second-sort universe
of M .) So we need to show that the symbols of LS2 have the same
interpretations in M and (M ) . This essentially follows from the fact
that M |= V 1 , the functions and relations of L+ are deﬁnable in V 1 , and
that the “extension axiom” is provable in S21 (Exercise VIII.8.5).
The second statement is proved similarly. (Here (N  ) and N might
have diﬀerent ﬁrst-sort universes, but they are isomorphic.)
2
The next corollary is the converse of Theorem VIII.8.17 above.
Corollary VIII.8.20. Let T1 be a single-sorted theory over LS2 and T2
RSUV

be a two-sorted theory over L2A such that T1 ≃ T2 . Then
(i) T1 (BIT)  ϕ  for every axiom ϕ of T2 , and
(ii) T2 (L+ )   for every axiom of T1 .
Proof. For (i), let M be a model of T1 and ϕ be an axiom of T2 .
Then M |= T2 . Therefore by Exercise VIII.8.16 (b) (M ) |= ϕ  . Since
(M ) and M are the same structure (Corollary VIII.8.19), it follows that
M |= ϕ  . Hence T1  ϕ  .
(ii) is proved similarly using Exercise VIII.8.13 (b).
2
Theorem VIII.8.21. Suppose that T1 and T2 are RSUV isomorphic. Then
T1 is ﬁnitely axiomatizable if and only if T2 is.
Proof. Suppose that T1 is a ﬁnitely axiomatizable single-sorted theory.
Note that by the ΣB1 -Transformation Lemma VI.3.9, for each L+ formula
ϕ there is an L2A formula ϕ  so that V 1 (L+ )  ϕ ↔ ϕ  . We will use
this notation in the following deﬁnition. Let T denote the union of the
following sets:
{(

 

) :

is an axiom of T1 (BIT)}

and the set of the sentences of the form
∀x∀Y ∃!zϕ(x, z, Y )
or
∀x∀Y ∃!Zϕ(x, Z, Y )
where ϕ the the formula in the deﬁning axiom of a function symbol of L+ .
We show that T2 can be axiomatized by T . First, let be an axiom
of T1 . By Corollary VIII.8.20 (ii) above, T2 (L+ )   . Consequently

265

VIII.8. RSUV Isomorphism
(since T2 extends V 1 , and T2 (L+ ) is conservative over T2 ) T2  (
deﬁning axioms for symbols of L+ are in T2 because V 1 ⊆ T2 .
It remains to show that T  ϕ for each axiom ϕ of T2 .

 

) . The

Claim. For each model N of T , there is a model M of T1 (BIT) so that
M = N .
The Claim follows from part (a) of the exercise below and the fact that
of T1 . The latter follows from a
T  (  ) ↔  for every axiom
careful examination of the proof of part (c) of the ΣB1 -Transformation
Lemma VI.3.9. (Here we do not require that T proves the Replacement
axiom scheme.)
Now let ϕ be an axiom of T2 . Let N be any model of T , and let M be as
in the Claim. Since M |= T1 (BIT) and T1 (BIT) |= ϕ  we have M |= ϕ  .
By Exercise VIII.8.16 (b) we have N |= ϕ.
2
Exercise VIII.8.22. (a) Suppose that T1 is a single-sorted theory that
extends S21 . Show that for every two-sorted model N of the set
{  : is an axiom of T1 } there is a model M of T1 so that M = N .
(b) Similarly, let T2 be a two-sorted theory that extends V 1 , and T2 =
{ϕ  : ϕ is an axiom of T2 }. Show that for every model M of T2
there is a model N of T2 so that M = N  .
RSUV

Proof sketch of S21 ≃ V 1 . We need to show that V 1 (L+ ) proves
the  translations of the axioms in BASIC as well as Σb1 -LIND (see Exercise VIII.8.4). The former is straightforward and is left as an exercise.
Exercise VIII.8.23. Show that V 1 (L+ ) proves the  translations of the
BASIC axioms.
Now we consider the Σb1 -LIND axiom scheme. We will show that N
satisﬁes the  translations of the following bounded length induction for Σb1
formulas, which logically imply Σb1 -LIND:
[ϕ(0) ∧ ∀x ≤ |z|, ϕ(x) ⊃ ϕ(x + 1)] ⊃ ∀zϕ(|z|)

(216)

(where ϕ is a Σb1 formula).
Using Exercise VIII.8.13 (a) it is easy to see that instances of (216)
translate into gΣB1 (L+ )-IND. Hence the conclusion follows from Corollary VIII.8.11.
Consider the next half of the RSUV isomorphism. By Theorem VI.4.8
it suﬃces to show that S21 (BIT) satisﬁes the  translations of the 2-BASIC
axioms and ΣB1 -IND axioms. The ΣB1 -IND axioms translate into Σb1 (BIT)LIND which is provable in S21 (BIT) by Exercise VIII.8.15. Thus the
following simple exercise completes our proof of the RSUV isomorphism
between S21 and V 1 .
2
Exercise VIII.8.24. Show that S21 (BIT ) proves the  translation of the
2-BASIC axioms.

266

VIII. Theories for Polynomial Time and Beyond

Exercise VIII.8.25. Complete the proof of Theorem VIII.8.10 by showRSUV

ing that S2i ≃ V i for i ≥ 2.

VIII.9. Notes
 is new.
The theory VP in Section VIII.1 is from [82], but the theory VP
The theory VPV deﬁned in Section VIII.2 is based on the single-sorted
equational theory PV [39]. The results in Section VIII.2.1 were ﬁrst
proved in single-sorted versions in Chapter 6 of [20].
In Section VIII.3 the TV i hierarchy for i ≥ 1 is the two-sorted version
of Buss’s [20] T2i hierarchy. The theory TV 0 was introduced in [42] where
the results of Section VIII.3 are outlined, except Theorem VIII.3.10 is
from [82].
The theory V 1 -HORN was introduced in [43], where versions of the
results of Section VIII.4 are proved.
The PLS problems were introduced in [65]. The results in Section VIII.5
are mostly two-sorted versions of results from [30]. However our Witnessing Theorem VIII.5.13 is stronger than the one in [30], in that our
0
witnessing function G is in the small class FAC 0 , and the weak theory V ,
as opposed to TV 1 , proves the witnessing.
The results from Section VIII.6.1 are from [47].
Results and deﬁnitions in Section VIII.7 have single-sorted precursors
as follows. Theorem VIII.7.4 is from [20]. The theories VPV i are (for
i ≥ 2) two-sorted versions of the theories PV i introduced in [75]. Theorems VIII.7.12 and VIII.7.13 are from [20, 23, 75]. Theorem VIII.7.14 is
from [30, 33]. Deﬁnition VIII.7.16 (witness oracles) is from [31]. Theorem VIII.7.17 (i) is from [70] and (ii) is from [93] and [80].
Table 3 is inspired by Table 2.1 in [80].
Theorem VIII.7.20 is recently improved in [61] (under the same assumption, TV i proves that PH collapses to the Boolean closure of ΣPi+1 ).
Buss [20] introduced the hierarchies S2 , T2 , and more generally, Sk ,
Tk (for k ≥ 2). (The index k indicates the presence of the function
#k , where #2 = #, and x#k+1 y = 2|x|#k |y| .) He also introduced the
hierarchy U2 , V2 , where U21 and V21 capture PSPACE and EXPTIME,
respectively. (The theories V i in this book is sometimes called V1i .) The
i
and Vki was ﬁrst realized in [69, 107]. The name
equivalence between Sk+1
“RSUV isomorphism” was introduced by Takeuti in [108], where he also
introduced the hierarchies Rk , and proved the equivalences between Rik+1
i
and Uki and between Sk+1
and Vki . The S – V equivalence was also proved
in [95]. The syntactic translations  and  are called interpretations in
[107, 95] (the symbols  and  were introduced in [95]).

Chapter IX

THEORIES FOR SMALL CLASSES

In this chapter we develop subtheories of VP that are associated with the
following subclasses of P:
AC 0 (m) ⊆ TC 0 ⊆ NC 1 ⊆ L ⊆ NL ⊆ NC.
For each class C we obtain a minimal theory VC in the style of VP
(Section VIII.1). Here each theory VC is axiomatized by the axioms
of V 0 and a single axiom that asserts the existence of a solution for a
complete problem of C. Thus VC is ﬁnitely axiomatizable, since V 0 is
ﬁnitely axiomatizable. Our theories VC are minimal in the sense that
they are axiomatized by some ΣB0 and ΣB1 formulas which appear to be
necessary to establish the basic properties of the functions in the associated
class C. In contrast V 1 appears not to be a minimal theory for FP, since
by Theorem VIII.7.20 it has ΣB2 axioms which are not provable in VP
(assuming that the polynomial hierarchy does not collapse).
In this chapter completeness is with respect to AC 0 -Turing reductions,
which are more general than the AC 0 -many-one reductions used in Section VIII.1 (see Proposition VIII.1.7). Therefore our results apply to
classes such as TC 0 that are not known to have any AC 0 -many-one complete problem.
The theory VP in Section VIII.1 can be seen as a member of the family
VC here. In general we consider classes C that are the AC 0 -closure of
a polytime function FC . Together with VC we will obtain two universal
 and VC whose classes of provably total functions both are
theories VC
equal to FC. Following the development in Section VIII.1, after deﬁning
 and show that it is a conservative extension of VC.
VC we introduce VC
 is LFAC 0 ∪ {FC }, and the terms of VC
 represent
The vocabulary of VC
precisely the functions in FC. Using the Herbrand Theorem it follows
 are FC (and hence
that both the ΣB1 -deﬁnable functions of VC and of VC
B
all relations in C are Δ1 -deﬁnable in both theories). Then the theory VC
 by including symbols for all string functions in FC,
is obtained from VC
0
similar to the way in which V 0 is extended to V in Section V.6. The
deﬁning axioms for functions in VC are based on the AC 0 -reductions to
267

268

IX. Theories for Small Classes

the function FC . We will show that VC is indeed a conservative extension
 and conclude from this that VC characterizes FC as mentioned.
of VC,
For some subclasses C of L we are able to obtain universal theories VCV
using recursion schemes similar to the limited recursion scheme given in
Deﬁnition VI.2.11 used to obtain VPV. Here VCV has symbols for all
string functions in FC, but their deﬁning axioms are based on a particular
recursion scheme rather than on AC 0 reductions as in the case of VC. We
will prove that in each case VCV is conservative over VC, giving evidence
of the robustness of our deﬁnition of VC. The conservativity results
also justify the “minimality” of our theories for characterizing C: The
axioms consist essentially of 2-BASIC (page 96) and axioms deﬁning the
functions in FC (either using AC 0 -reductions to the complete problem of
C or using the recursion scheme that characterizes FC).
The fact that a theory VCV is a universal conservative extension of
VC also implies that our theory VC proves the recursion scheme for the
functions in FC. We will formalize in our theories proofs of a number
of other mathematical theorems, such as the Pigeonhole Principle (PHP),
the discrete version of Jordan Curve Theorem (JCT), and Bondy’s Theorem. Some other theorems are of the form C1 ⊆ C2 ; for these we need to
show that the deﬁning axioms of VC 1 are provable in VC 2 . We identify
the research area of formalizing mathematical results in theories (preferably the weakest possible theories) of Bounded Arithmetic as “Bounded
Reverse Mathematics”, and we mention some open problems in this area
in Section IX.7.
Part of the interest in establishing the provability of a principle such
as PHP and JCT in a theory VC is that this implies the existence of
polynomial size propositional proofs, in the proof system corresponding
to the complexity class C, of the propositional tautologies expressing these
principles (Section X.1).
This chapter is organized as follows. We start by formally deﬁning the
notion of AC 0 reduction in Section IX.1. Then in Section IX.2 we intro and VC. In the subsequent sections we deﬁne
duce the families VC, VC
the theories for the classes mentioned above and carry out several formalizations in these theories: theories for TC 0 are presented in Section IX.3,
theories for AC 0 (m) are presented in Section IX.4, theories for the NC
hierarchy are presented in Section IX.5, and theories for NL and L are
given in Section IX.6. For each of these sections it is helpful to specialize
 and VC in Section IX.2.
the meta-theorems that we prove for VC, VC
Finally some open problems are listed in Section IX.7.

IX.1. AC 0 Reductions

269

IX.1. AC 0 Reductions
Roughly speaking a function F is AC 0 -reducible to a collection L of
functions if F can be computed by a uniform polynomial size constant
depth family of circuits which have unbounded fan-in gates computing
functions from L, in addition to Boolean gates (see for example [10]).
This is a Turing style reduction, and generalizes the more restrictive manyone style. The class P and all classes that we consider in this chapter are
closed under AC 0 reductions. Below we will formalize the notion of AC 0 reducible and show that in standard settings the FAC 0 closure of a set of
functions is the same as closure under composition and a comprehension
operator.
Recall that a function F (resp. f) is ΣB0 -deﬁnable from L if it is polynomially bounded, and its bit graph (resp. graph) is represented by a
ΣB0 (L) formula (Deﬁnition V.4.12). The following deﬁnition generalizes
the notion of ΣB0 -deﬁnability.
Deﬁnition IX.1.1 (AC 0 Reduction). We say that a string function F
(resp. a number function f) is AC 0 -reducible to L if there is a sequence
of string functions F1 , . . . , Fn (n ≥ 0) such that
Fi is ΣB0 -deﬁnable from L ∪ {F1 , . . . , Fi−1 }, for i = 1, . . . , n;

(217)

and F (resp. f) is ΣB0 -deﬁnable from L ∪ {F1 , . . . , Fn }. A relation R is
AC 0 -reducible to L if there is a sequence F1 , . . . , Fn as above, and R is
represented by a ΣB0 (L ∪ {F1 , . . . , Fn }) formula.
Exercise IX.1.2. Show that a number function f is AC 0 -reducible to L
if and only if f = |F | for some string function F which is AC 0 -reducible
to L.
If in the above deﬁnition L consists only of functions in FAC 0 , then a
single iteration (n = 1) is enough to obtain any function in FAC 0 , and
by Corollary V.4.16 no more functions are obtained by further iterations.
However, as we shall see in the next section, if we start with a function
such as numones, then repeated iterations generate the complexity class
TC 0 . It is an open question whether there is a bound on the number of
iterations needed.
Deﬁnition IX.1.3 (FAC 0 - and AC 0 -Closure). For a vocabulary L, the
FAC 0 closure of L is the class of functions which are AC 0 -reducible to
L. The AC 0 closure of L is the class of relations which are AC 0 -reducible
to L.
All complexity classes of interest here are closed under AC 0 reductions, because the corresponding function classes are closed under ΣB0 deﬁnability. For the case of FAC 0 , this follows from Corollary V.4.16.

270

IX. Theories for Small Classes

Corollary IX.1.4. The FAC 0 closure of FAC 0 is FAC 0 . The AC 0 closure of AC 0 is AC 0 .
For a complexity class C, recall that FC is the corresponding function
class (Deﬁnition V.2.3). The following lemma is straightforward consequence of the deﬁnitions involved.
Lemma IX.1.5. Suppose that a complexity class C is the AC 0 closure of
a vocabulary L. Then FC is the FAC 0 closure of L.
The composition of two functions is AC 0 reducible to the functions,
because a term representing the composition can be used in a ΣB0 (L)formula deﬁning the composition. We now deﬁne another operation
which preserves AC 0 reducibility and which will be used together with
composition to give a characterization of AC 0 reducibility. The new
operation takes a number function and collects a bounded number of its
values in a set to form a string function. This notion and Theorem IX.1.7
below will be useful in Section IX.3.3.
Deﬁnition IX.1.6 (String Comprehension). For a number function
f(x) (which may contain other arguments), the string comprehension
of f is the string function F (y) such that
F (y) = {f(x) : x ≤ y}.
(See (49) on page 96 for this set-theoretic notation.) Note that if f is
polynomially bounded, then so is F .
For example, recall that the ΣB0 formula ϕparity (X, Y ) (80) on page 118
asserts that for 0 ≤ i < |X |, bit Y (i + 1) is 1 iﬀ the number of 1’s among
bits X (0), . . . , X (i) is odd. Here Y can be expressed as a function of X
by Y = F (|X |, X ), where F is obtained from the following function f by
string comprehension:
⎧
⎪
if x > 0 and the number of 1 bits in
⎨x
f(x, X ) =
X (0), . . . , X (x − 1) is odd,
⎪
⎩
|X | + 1 otherwise.
Theorem IX.1.7. Suppose that L is a class of polynomially bounded functions that includes FAC 0 . Then a function is AC 0 -reducible to L iﬀ it can
be obtained from L by ﬁnitely many applications of composition and string
comprehension.
Proof. For the IF direction, it suﬃces to prove that a function obtained
from input functions by either of the operations composition or string
comprehension is ΣB0 -deﬁnable from the input functions.
For composition, suppose
F (x, X ) = G(h1 (x, X ), . . . , hk (x, X ), H1 (x, X ), . . . , Hm (x, X ))
where G and h1 , . . . , hk , H1 , . . . , Hm are polynomially bounded. Then F
is also polynomially bounded, and its bit graph F (x, X )(z) is represented

IX.1. AC 0 Reductions

271

by the open formula
G(h1 (x, X ), . . . , hk (x, X ), H1 (x, X ), . . . , Hm (x, X ))(z).
(A similar argument works for a number function f.)
For string comprehension, suppose that f(x) is a polynomially bounded number function. As noted before, the string comprehension F (y) of
f is also polynomially bounded, and it has bit graph
F (y)(z) ↔ z < t ∧ ∃x ≤ y z = f(x)
where t is the bounding term for F . Hence F is also ΣB0 -deﬁnable from f.
For the ONLY IF direction, it suﬃces to show that if L ⊇ FAC 0 and F
(or f) is ΣB0 -deﬁnable from L, then F (resp. f) can be obtained from L
by composition and string comprehension.
Claim. If L ⊇ FAC 0 and ϕ(z, X ) is a ΣB0 (L) formula, then the characteristic function cϕ deﬁned by
cϕ (z, Z) =

1
0

if ϕ(z, Z),
otherwise

can be obtained from L by composition.
The Claim is holds because c (x, X ) is in FAC 0 for every ΣB0 (L2A )formula , and (by structural induction on ϕ) it is clear that for every
ΣB0 (L)-formula ϕ(z, Z) there is a ΣB0 (L2A )-formula (x, X ) such that
ϕ(z, Z) ↔

(s , T )

for some L-terms s and T . Hence
cϕ (z, Z) = c (s , T ).
Now suppose that F is ΣB0 -deﬁnable from L, so
F (z, X )(x) ↔ x < t ∧ ϕ(x, z, X )
where t = t(z, X ) is an L2A term and ϕ is a ΣB0 (L) formula.
Deﬁne the number function f by cases as follows:

x if ϕ(x, z, X ),
f(x, z, X ) =
t if ¬ϕ(x, z, X ).
Then by the Claim, f can be obtained from L by composition as follows.
Deﬁne the FAC 0 function g by
g(x, y, z, w) = x · y + z · w.
Thus
f(x, z, X ) = g(x, cϕ , t, c¬ϕ ).
Now
F (z, X ) = Cut(t, G(t, z , X ))

272

IX. Theories for Small Classes

where G(y, z, X ) is the string comprehension of f(x, z, X ), and Cut (see
(97) on page 139) is the FAC 0 function deﬁned by
Cut(x, X )(z) ↔ z < x ∧ X (z).
It remains to show that if a number function f is ΣB0 -deﬁnable from L
then f can be obtained from L by composition and string comprehension.
Suppose f satisﬁes
y = f(z, X ) ↔ y < t ∧ ϕ(y, z, X )
where t = t(z, X ) is a L2A term and ϕ is a ΣB0 (L) formula. Use the Claim
to deﬁne cϕ (y, z, X ) by composition from L, and deﬁne g by
g(x, z, X ) = x · cϕ (x, z, X ).
Then

f(z, X ) = |G(t, z, X )| −· 1

where G(y, z, X ) is the string comprehension of g(x, z, X ).

2

IX.2. Theories for Subclasses of P
In this section, we show how to develop ﬁnitely axiomatizable theories
for a number of uniform subclasses of P in the style of VP (Section VIII.1).
Recall that VP is obtained from the base theory V 0 by adding the axiom
MCV which states the existence of a value for FMCV , a function which is
AC 0 -many-one complete for P. Here we obtain a theory VC for any class
C which is the AC 0 closure of a polytime function FC . The provably total
functions of VC are precisely the functions in FC and the ΔB1 -deﬁnable
relations in VC are precisely the relations in C. Thus the function FMCV
plays the role of FC when C = P.
In Section IX.2.1 we deﬁne VC and state the deﬁnability theorems
for VC. In Section IX.2.2 we follow the discussion in Section VIII.1
 in the same style as VP.
 The
and introduce the universal theory VC

vocabulary LVC
c of VC is LFAC 0 together with the new function FC . We
 is a conservative extension of VC. We also prove that the
show that VC
terms in LVC
c represent precisely functions in FC and hence the relations
in C are represented by open formula of LVC
c . Consequently we derive

our deﬁnability theorems for both VC and VC.
In Section IX.2.3 we introduce a universal theory VC. The vocabulary
LFC of VC contains all string functions of FC. (Note that by Exercise
IX.1.2 the number functions in FC are represented by LFC -terms of the
form |G|, for string functions G in LFC .) We show that VC is a conserva and VC, and therefore it also characterizes C.
tive extension of both VC
In Section IX.2.4 we discuss a general way of applying our results above
to the subclasses of P mentioned at the beginning of this chapter.

IX.2. Theories for Subclasses of P

273

IX.2.1. The Theories VC. In the following discussion the intended
function FC will be simply denoted by F . So suppose that F is a polytime
function with a ΣB0 graph:
Y = F (X ) ↔ (|Y | ≤ t ∧ F (X, Y ))

(218)

for some L2A term t and ΣB0 (L2A ) formula F . Suppose further that V 0
proves the uniqueness of the value of F :


V 0  ∀Y1 ∀Y2 (|Y1 | ≤ t ∧ |Y2 | ≤ t ∧ F (X, Y1 ) ∧ F (X, Y2 )) ⊃ Y1 = Y2 .
Let C be the class of two-sorted relations which are AC 0 -reducible to
F . By Lemma IX.1.5, the class FC (Deﬁnition V.2.3) can be equivalently
deﬁned as the FAC 0 closure of F (Deﬁnition IX.1.3).
Our functions FC introduced later in this chapter often have more
than one argument, but they can be easily deﬁned using a one argumentfunction as above. For example, we can easily encode the arguments
(a, G, E) of FMCV into a single string argument X and let F be the resulting
function:
F (X ) = FMCV (a, G, E)

whenever X encodes (a, G, E).

Then we have C = P.
Deﬁnition IX.2.1 (VC). The theory VC has vocabulary L2A and is axiomatized by the axioms of V 0 and the following axiom:
∃Y ≤ b∀i < b F (X [i] , Y [i] ).

(219)

The notation X [i] technically involves the function Row (Deﬁnition
V.4.26). But according to the Row Elimination Lemma V.4.27, F (X [i] ,
Y [i] ) is easily equivalent to a ΣB0 -formula F (i, X, Y ), so we will interpret
this axiom to be ∃Y ≤ b∀i < b F (i, X, Y ), which is a formula over L2A .
Note that VC is a polynomial-bounded ﬁnitely axiomatizable theory,
because V 0 is, and the new axiom is bounded.
Recall the notion of aggregate function (Deﬁnition VIII.1.9). Notice that (219) states the existence of the value for the aggregate function F  of F . Even though MCV (157) (page 202) is only the graph of
∗
∗
FMCV (as opposed to FMCV
), the fact that FMCV
is ΣB1 -deﬁnable in VP
(Lemma VIII.1.10) shows that VP is equivalent to a theory VC deﬁned as
above. In Section IX.2.4 we explain how to design theories for the other
classes mentioned at the beginning of this chapter. In each case, we will
be able to use the (simpler) deﬁning axiom for F instead of the axioms of
the form (219). This is because we can prove that for each of our theories
F  (for the F associated with the theory) is deﬁnable (although the proofs
are diﬀerent for each theory).
The next lemma is straightforward:

274

IX. Theories for Small Classes

Lemma IX.2.2. The functions F and F  are ΣB0 -deﬁnable in VC, and
VC(F, F  )  ∀b∀X ∀i < b F  (b, X )[i] = F (X [i] ).
Our ﬁrst goal is to prove the following theorem (recall from Corollary
V.4.4 that a function is provably total in VC iﬀ it is ΣB1 -deﬁnable in VC):
Theorem IX.2.3. A function is provably total in VC iﬀ it is in FC.
Corollary IX.2.4. A relation is in C iﬀ it is ΔB1 -deﬁnable in VC iﬀ it is
1
Δ1 -deﬁnable in VC.
Proof. From Theorems IX.2.3 and V.4.35.
2
We prove Theorem IX.2.3 by introducing the universal conservative
 of VC, an analog of VP.
 The proof is given on page 278.
extension VC
 Here we deﬁne the universal theory VC
 and
IX.2.2. The Theory VC.
show that it is a conservative extension of VC. We start by obtaining a
quantiﬁer-free deﬁning axiom for F . For this we need a quantiﬁer-free
formula that is equivalent to F (X, Y ). So let F (X, Y ) be the quantiﬁer0
free formula over LFAC 0 which V proves equivalent to F (X, Y ) (by
Lemma V.6.3). Formally, we will not change the deﬁning axiom for
F . Therefore let F  be the function with the same value as F but has the
following quantiﬁer-free deﬁning axiom:
Y = F  (X ) ↔ (|Y | ≤ t ∧ F (X, Y )).

(220)

 VC
 is the universal theory over the vocabuDeﬁnition IX.2.5 (VC).
0

lary LVC
c = LFAC 0 ∪ {F }, and is axiomatized by the axioms of V and
(220) for F  .
The next theorem is proved in the same way as Theorem VIII.1.13 using
Lemma IX.2.2 above.
 is a universal conservative extension
Theorem IX.2.6. The theory VC
of VC.
The next corollary follows from Theorem VIII.1.15 in the same way as
Corollary VIII.1.16:
 proves the axiom schemes:
Corollary IX.2.7. The theory VC
B
B
ΣB0 (LVC
c )-COMP, Σ0 (LVC
c )-IND, and Σ0 (LVC
c )-MIN.
The following theorem generalizes Theorem VIII.1.12.
Theorem IX.2.8. (a) A function is in FC if and only if it is represented
by a term in LVC
c.
(b) A relation is in C if and only if it is represented by an open formula of
B
LVC
c iﬀ it is represented by a Σ0 (LVC
c ) formula.

Proof. It is straightforward to prove (b) from (a). So below we will
only prove (a). Here FC is the FAC 0 -closure of F . First we prove
by induction based on Deﬁnition IX.1.1 that the functions in FC are

IX.2. Theories for Subclasses of P

275

represented by LVC
c terms. The base case is obvious: F is represented by
the term F (x, X ). For the induction step, by Exercise IX.1.2 it suﬃces
to consider the case of a string function. Suppose that G(x, X ) is ΣB0 deﬁnable from L = {F1 = F, F2 , . . . , Fn }, and that each Fi is represented
B
by a term Ti in LVC
c . By deﬁnition there is a Σ0 (L) formula ϕ(z, x, X )
that represents the bit graph of G, i.e.,
G(x, X )(z) ↔ z ≤ t ∧ ϕ(z, x, X )
for some L2A -term t.
Let ϕ  (z, x, X ) be the LVC
c -formula obtained from ϕ(z, x, X ) by substituting Ti (s, S) for all occurrences of Fi (s, S). Let F (s1 , S1 ), . . . , F (sm ,
Sm ) be all maximal occurrences of F in ϕ  . Thus
ϕ  (x, X ) ≡ ϕ  (x, X , F (s1 , S1 ), . . . , F (sm , Sm ))
where ϕ  (x, X , Y1 , . . . , Ym ) is a ΣB0 (LFAC 0 )-formula. Then G is represented by the LVC
c -term H (x, X , F (s1 , S1 ), . . . , F (sm , Sm )), where H is
the AC 0 function with bit graph
H (x, X , Y1 , . . . , Ym )(z) ↔ z ≤ t ∧ ϕ  (z, x, X , Y1 , . . . , Ym ).
For the other direction, we prove by induction on the nesting depth
of an LVC
c -term that it represents a function in FC. The base case (the
nesting depth is 0) is obvious, so consider the induction step. Let T (x, X )
be an LVC
c string term of nesting depth d ≥ 1. (The case of a number
term is similar.) Then
T (x, X ) = H (s1 (x, X ), . . . , sn (x, X ), T1 (x, X ), . . . , Tm (x, X ))
for LVC
c -terms si , Tj of nesting depth at most d − 1, and H = F or H
is an AC 0 function. By the induction hypothesis, si and Tj represent
C functions fi and Gj , respectively (for 1 ≤ i ≤ n, 1 ≤ j ≤ m). For
1 ≤ i ≤ n let the string functions Fi in FC be such that fi = |Fi | (see
Exercise IX.1.2). Then T represents the function K which is ΣB0 -deﬁnable
from H, F1 , . . . , Fn , G1 , . . . , Gm as follows:
K(x, X )(z) ↔
z ≤ t ∧ H (|F1 (x, X )|, . . . , |Fn (x, X )|, G1 (x, X ), . . . , Gm (x, X ))(z)
for some appropriate L2A -term t. This shows that T represents a function
in FC.
2

Corollary IX.2.9. (a) A function is ΣB1 (LVC
c )-deﬁnable in VC iﬀ it is
in FC.

(b) A relation is C iﬀ it is ΔB1 (LVC
c )-deﬁnable in VC.

276

IX. Theories for Small Classes

Proof. (a) This follows from Theorem IX.2.8 (a) and the Herbrand
Theorem (see the proof of Corollary VIII.1.14).
(b) Follows from (a) and Theorem V.4.35.
2
B
The next result is important for replacing the ΣB1 (LVC
c ) (and Π1 (LVC
c)
B
B
2
formulas from Corollary IX.2.9 above by just Σ1 (i.e., Σ1 (LA )) (and ΠB1 )
formulas. (In Corollary IX.3.20 we will prove similar theorem for number
functions f, f  .)

Theorem IX.2.10 (First Elimination Theorem). Let T be a theory with
vocabulary L which extends V 0 (Row) and proves ΣB0 (L)-COMP. Suppose
that F and F  are ΣB1 -deﬁnable in T (Deﬁnition V.4.1) and T (F, F  ) proves
(166):
∀i < b, F  (b, Z, X )[i] = F ((Z1 )i , . . . , (Zk )i , X1[i] , . . . , Xn[i] ).
Suppose also that every ΣB0 (L) formula is equivalent in T to a ΣB1 (L2A )
formula. Then every ΣB1 (L ∪ {F }) formula is equivalent in T (F ) to a
ΣB1 (L2A ) formula.
Proof. It suﬃces to prove the the last statement for ΣB0 -formulas. Let
ϕ + ≡ Q1 z1 ≤ r1 . . . Qn zn ≤ rn (z)
be a ΣB0 (L, F ) formula, where Q1 , . . . , Qn ∈ {∃, ∀} and is a quantiﬁerfree formula. We show that there is a ΣB1 (L2A ) formula ϕ so that
T (F )  ϕ + ↔ ϕ.
As in the base case in the proof of Theorem VIII.1.15, the idea here
is to replace every occurrence of a term F (s , T ) in
by a new string
variable W which has the intended value of F (s, T ). We need to state the
existence of such strings, and this contributes to the string quantiﬁers in
the resulting ΣB1 formula.
So suppose that F (s1 , T1 ), . . . , F (sk , Tk ) are all occurrences of F in .
Note that the terms si , Ti may contain z as well as nested occurrences of
F . Assume further that these F -terms are ordered by depth so that s1 , T1
do not contain F , and for 1 < i ≤ k, any occurrence of F in si , Ti must
be of the form F (sj , Tj ), for some j < i.
−
→
−
→
Let W1 , . . . , Wk be new string variables. Let s1 = s1 , T1 = T1 , and for
−
→
−
→
2 ≤ i ≤ k, si and Ti be obtained from si and Ti respectively by replacing
every maximal occurrence of any F (sj , Tj ), for j < i, by Wj[z] . Thus F
−
→
−
→
−
→
−
→
does not occur in any si and Ti , but for i ≥ 2, si and Ti may contain
W1 , . . . , Wi−1 .

277

IX.2. Theories for Subclasses of P

Let  (z, W1 , . . . , Wk ) be obtained from (z) by replacing each maximal occurrence of F (si , Ti ) by Wi[z] , for 1 ≤ i ≤ k. Obviously,


−
→ −
→
[z]
T (F )  ∃W1 . . . ∃Wk (∀z1 ≤ r1 . . . ∀zn ≤ rn
Wi = F ( si , Ti )) ∧

Q1 z1 ≤ r1 . . . Qn zn ≤ rn  (z, W ) ⊃ Q1 z1 ≤ r1 . . . Qn zn ≤ rn (z).
Notice that Wi = F  (r, Ui , Vi ) satisfy
∀z1 ≤ r1 . . . ∀zn ≤ rn

−
→ −
→
Wi[z] = F ( si , Ti )

where Ui,j and Vi, are unique strings such that

,
|Ui,j | ≤ t ∧ ∀z1 ≤ r1 . . . ∀zk ≤ rk (Ui,j )z = si,j

(221)

[z]

= Ti,
|Vi, | ≤ t ∧ ∀z1 ≤ r1 . . . ∀zk ≤ rk Vi,

(222)
−
→
−
→
and t is an L2A -term such that t ≥ r, max{|Ti |, si } for all 1 ≤ i ≤ k.
Denote the conjunction of (221) and (222) for all i, j,  by (U , V ).
Then


T (F, F  )  ∃U ∃V ∃W (U , V ) ∧
Wi = F  (r, Ui , Vi ) ∧

Q1 z1 ≤ r1 . . . Qn zn ≤ rn  (z, W ) ⊃ Q1 z1 ≤ r1 . . . Qn zn ≤ rn (z).
On the other hand, since F  is deﬁnable in T and since T  ΣB0 (L)COMP, we have


Wi = F  (r, Ui , Vi ) . (223)
T (F, F  )  ∃U ∃V ∃W (U , V ) ∧
Therefore


T (F, F  )  Q1 z1 ≤ r1 . . . Qn zn ≤ rn (z) ⊃ ∃U ∃V ∃W (U , V ) ∧

Wi = F  (r, Ui , Vi ) ∧ Q1 z1 ≤ r1 . . . Qn zn ≤ rn  (z, W ) .
As a result,


T (F, F  )  Q1 z1 ≤ r1 . . . Qn zn ≤ rn (z) ↔ ∃U ∃V ∃W (U , V ) ∧

Wi = F  (r, Ui , Vi ) ∧ Q1 z1 ≤ r1 . . . Qn zn ≤ rn  (z, W ) .
Finally the strings in (223) are bounded by some L2A -terms and are provably unique in T (F  ). Therefore (223) is equivalent in T (F  ) to a ΣB1 (L2A )
formula. Also, by the hypothesis,
Q1 z1 ≤ r1 . . . Qn zn ≤ rn
is equivalent in T

∃U ∃V ∃W (U , V ) ∧



(z, W )

to a ΣB1 (L2A ) formula. As a result,
Wi = F  (r, Ui , Vi ) ∧
Q1 z1 ≤ r1 . . . Qn zn ≤ rn




(z, W )

278

IX. Theories for Small Classes

is equivalent in T (F, F  ) to a ΣB1 formula. The conclusion follows from
the fact that T (F, F  ) is conservative over T (F ).
2
B
B
Corollary IX.2.11 (Σ1 (LVC
c ) Elimination). For each Σ1 (LVC
c ) formu  ϕ + ↔ ϕ.
la ϕ + there is a ΣB1 (L2A ) formula ϕ such that VC
0

Proof. We apply Theorem IX.2.10 for T = VC + V and L = LFAC 0 .
0
The hypothesis that every ΣB0 (LFAC 0 ) formula is equivalent in V to a
B

Σ1 formula is from Lemma V.6.7, the facts that F and F are both
0
ΣB1 -deﬁnable in VC, and that VC + V proves (166) are established in
Lemma IX.2.2.
2
The next corollary follows from Corollaries IX.2.9 and IX.2.11.
Corollary IX.2.12. (a) A function is in FC iﬀ it is ΣB1 (L2A )-deﬁnable

in VC.

(b) A relation is in C iﬀ it is ΔB (L2 )-deﬁnable in VC.
1

A

Now we are able to prove Theorem IX.2.3.
Proof of Theorem IX.2.3. The proof is straightforward using Theorem IX.2.6 and Corollary IX.2.12.
2
IX.2.3. The Theory VC. Here we introduce VC, another universal con Its vocabulary LFC contains symbols
servative extension of VC and VC.
for all string functions in FC. The deﬁning axioms for functions in LFC
are based on their AC 0 -reductions to the function FC . Recall the function
F  and its quantiﬁer-free deﬁning axiom (220).
Deﬁnition IX.2.13 (VC). LFC is the smallest set containing LFAC 0 ∪
{F  } and satisfying the following condition: for each open formula
ϕ(z, x, X ) over LFC and L2A -term t = t(x, X ), there is a string function
Fϕ(z),t in LFC with deﬁning axiom (86)
Fϕ(z),t (x, X )(z) ↔ z < t(x, X ) ∧ ϕ(z, x, X ).

(224)

VC is the universal theory over LFC whose axioms consist of the axioms of
0
V , (220) for F  , and the above deﬁning axioms for the functions Fϕ(z),t .
Note that Lemma VIII.2.3 and Theorem VIII.2.4 (Witnessing) apply
to VC.
The proof of the next theorem uses the property of aggregates stated in
Theorem VIII.1.15.
 and VC.
Theorem IX.2.14. VC is a conservative extension of VC

Proof. It suﬃces to show that VC is a conservative extension of VC,

because VC is a conservative extension of VC.
 because all axioms of VC
 are axioms
First, VC is an extension of VC
of VC. Thus VC is the union

VC =
Ti
i≥0

IX.2. Theories for Subclasses of P

279

 and for i ≥ 0 each Ti+1 is obtained from Ti by adding a
where T0 = VC
new function Fi+1 of the form Fϕ(z),t with deﬁning axiom (224), where ϕ
is a quantiﬁer-free formula in the vocabulary of Ti . We will show that Fi+1
is deﬁnable in Ti , which implies that Ti+1 is a conservative extension of Ti ,
 We need the following
and hence VC is a conservative extension of VC.
lemma, whose proof is straightforward.
Lemma IX.2.15. Let T be an extension of V 0 (Row) with vocabulary L
such that T proves ΣB0 (L)-COMP. Let Fϕ(z),t be the function with deﬁning

axiom (224) where ϕ is any ΣB0 (L) formula. Then both Fϕ(z),t and Fϕ,t
are
B


:
Σ0 (L)-deﬁnable in T , and T (Fϕ(z),t , Fϕ,t ) proves (166) for Fϕ(z),t and Fϕ,t

(b, Z, X )[i] = Fϕ(z),t ((Z1 )i , . . . , (Zk )i , X1[i] , . . . , Xn[i] ).
∀i < b, Fϕ,t

Let Li denote the vocabulary of Ti . It follows by induction on i ≥ 0,
using the above lemma and the Aggregate Function Theorem VIII.1.15,
that Ti proves ΣB0 (Li )-COMP. Then the fact that Fi+1 is deﬁnable (in fact,
ΣB0 (Li )-deﬁnable) in Ti follows from Lemma IX.2.15.
2
Lemma IX.2.16. The theory VC proves the axiom schemes
ΣB0 (LFC )-COMP, ΣB0 (LFC )-IND and ΣB0 (LFC )-MIN.
Proof. By Corollary V.1.8 it suﬃces to show that VC proves the
ΣB0 (LFC )-COMP axioms. This follows from the proof of Theorem IX.2.14
above, but it also has simple proof as follows.
Let ϕ(z, x, X ) be a ΣB0 (LFC ) formula. By Lemma VIII.2.3 there is a
quantiﬁer-free LFC -formula ϕ + (z, x, X ) so that
VC  ϕ + (z, x, X ) ↔ ϕ(z, x, X ).
Let Y = Fϕ + ,y (x, X ), where Fϕ + ,y is the string function of LFC with
deﬁning axiom
Fϕ + ,y (x, X )(z) ↔ z < y ∧ ϕ + (z, x, X ).
Then



VC  |Y | ≤ y ∧ ∀z < y Y (z) ↔ ϕ(z, x, X ) .

2
Hence VC proves the comprehension axiom for ϕ.
Theorem IX.2.17. (a) A string function is in FC if and only if it is
represented by a string function symbol in LFC .
(b) A relation is in C iﬀ it is represented by an open formula of LFC , iﬀ it
is represented by a ΣB0 (LFC ) formula.
Proof. Part (b) follows from (a), so below we will prove (a). First, we
prove by induction using Deﬁnition IX.1.1 that every string function in
FC is represented by a string function in LFC . The base case is simple
because F and every function in LFAC 0 are in LFC . For the induction step,
suppose that G(x, X ) is ΣB0 -deﬁnable from L = {F1 = F  , F2 , . . . , Fn },

280

IX. Theories for Small Classes

and that each Fi ∈ LFC , for 1 ≤ i ≤ n. By deﬁnition, there is a ΣB0 (L)
formula ϕ and an L2A -term t such that
G(x, X )(z) ↔ z ≤ t ∧ ϕ(z, x, X ).
By Lemma VIII.2.3 there is a quantiﬁer-free LFC -formula ϕ + (z, x, X )
that is equivalent (in VC) to ϕ(z, x, X ). Hence
G(x, X )(z) ↔ z ≤ t ∧ ϕ + (z, x, X ).
So G is equal to the function Fϕ + ,t in LFC .
For the other direction, we prove by induction (using Deﬁnition
IX.2.13) that every string function in LFC represents a string function in
FC. For the base case, the functions in LFAC 0 ∪ {F  } obviously represent
functions in FC. For the induction step, let Fϕ(z),t be a function in LFC ,
where all functions F1 , F2 , . . . , Fn in ϕ represent functions in FC. Then
Fϕ(z),t is AC 0 -reducible to F1 , F2 , . . . , Fn , hence Fϕ(z),t also represents a
function in FC.
2
The next result is a corollary of Theorem IX.2.10.
Corollary IX.2.18 (ΣB1 (LFC ) Elimination). Every ΣB1 (LFC ) formula
+
ϕ is equivalent in VC to a ΣB1 (L2A ) formula ϕ.
Proof. Let the theories Ti and their vocabularies Li be as in the proof
of Theorem IX.2.14. It suﬃces to prove by induction on i that for each
ΣB0 (Li ) formula ϕ + there is a ΣB1 (L2A ) formula ϕ such that Ti proves
equivalent to ϕ + .
The base case is Corollary IX.2.11. For the induction step, suppose
that the statement is true for some i ≥ 0. The statement for i + 1 is proved
by applying Theorem IX.2.10 for T = Ti and L = Li . The hypothesis
of Theorem IX.2.10 is satisﬁed by Lemma IX.2.15 and the fact (from the
2
proof of Theorem IX.2.14) that Ti proves ΣB0 (Li )-COMP.
The characterization of C by VC follows from Theorem IX.2.17, Corollary IX.2.18, the Herbrand Theorem, and Theorem V.4.35.
Corollary IX.2.19. (a) A function is in FC iﬀ it is ΣB1 (LFC )-deﬁnable
in VC iﬀ it is ΣB1 (L2A )-deﬁnable in VC.
(b) A relation is in C iﬀ it is ΔB1 (LFC )-deﬁnable in VC iﬀ it is ΔB1 (L2A )deﬁnable in VC.
Note that Theorem IX.2.3 also follows from Theorem IX.2.14 (that
VC is a universal conservative extension of VC), Theorem IX.2.17 and
Corollary IX.2.18.
IX.2.4. Obtaining Theories for the Classes of Interest. The results so
far in this chapter show how to obtain a theory VC for each class C
mentioned in the introduction to this chapter. In fact, for each class C of
interest, there is a polytime Turing machine M such that the function
F (X ) = “the computation of M on input X ”

IX.3. Theories for TC 0

281

is AC 0 complete for C. For example, for C = P we can take the machine
that computes FMCV (a, G, E) by computing inductively the bits of Y that
satisﬁes (157) on page 202.
The ΣB0 (L2A ) deﬁning axiom (218) for F can be obtained using the
following AC 0 functions (which can be eliminated by Lemma V.6.7):
• InitM (X ) is the initial conﬁguration of M given input X ,
• NextM (U ) is the next conﬁguration of the conﬁguration U , and
• Cut(t, Z) is the set of all elements of Z that are less than t with
deﬁning axiom (97) (page 139):
Cut(t, Z) = {z : z ∈ Z ∧ z < t}.
Let t be an L2A term that bounds the running time of M. We have

F (X ) = Y ↔ |Y | ≤ t, t ∧ Y [0] = Cut(t, InitM (X )) ∧


∀x < t, Y [x+1] = Cut(t, NextM (Y [x] )) .

By eliminating InitM , NextM and Cut, the above formula has the required
form (218) and it is easy to prove in V 0 the uniqueness for Y (by proving
by induction on x ≤ t that the rows Y [x] are unique).
Although the axiom (219) states the existence of the value for the
function F  , for each class C that we consider we are able to simplify
(219) so that it only states the existence of the value for F . Thus we will
need to prove the analogue of Lemma VIII.1.10, i.e., that F  is deﬁnable
using the simpliﬁed axiom and V 0 . It turns out that the proof is diﬀerent
for each class that we consider.
In the remaining of this chapter we will develop instances of VC as discussed here without referring to any speciﬁc machine M; they are implicit
in the additional deﬁning axioms of the instances that we introduce.

IX.3. Theories for TC 0
The class TC 0 (see deﬁnition in Section IX.3.1 below) is the smallest
class with nice closure properties that contains problems such as sorting,
integer multiplication and division (when the input integer arguments
0 and VTC 0 (Secare presented in binary). Here we deﬁne VTC 0 , VTC

 and VC in Section IX.2. In
tion IX.3.2) in the style of the theories VC, VC
Section IX.3.3 we deﬁne the bounded number recursion (BNR). Then in
Section IX.3.4 we use number summation, a special case of BNR, to characterize TC 0 and develop VTC 0 V in the style of VPV (see Section VIII.2).
This is another universal conservative extension of VTC 0 . We formalize
a proof of the Pigeonhole Principle in VTC 0 in Section IX.3.5. We deﬁne
the string multiplication function X × Y and prove its properties in VTC 0
in Section IX.3.6. Finally in Section IX.3.7 we show that VTC 0 proves

282

IX. Theories for Small Classes

the ﬁnite case of Szpilrajn’s Theorem (every ﬁnite partial order can be
extended to a total order).
In Chapter X we will prove the Propositional Translation Theorem
for VTC 0 .
IX.3.1. The Class TC 0 . The class nonuniform TC 0 (or TC 0 /poly) consists of languages that are accepted by a family of polynomial-size constant-depth circuits whose gates can be Boolean gates or the majority
gates. A majority gate has unbounded fan-in and which outputs 1 if and
only if the number of 1 inputs is more than the number of 0 inputs. We
are interested in FO-uniform TC 0 (or just TC 0 ) where the family can be
described by an FO-formula (Section IV.1). A formal deﬁnition is given
in Appendix A.5.
Instead of the majority gates, TC 0 can be equivalently deﬁned using
counting gates or threshold gates. A counting gate Ck (for k ∈ N) has
unbounded fan-in, and Ck (x1 , x2 , . . . , xn ) is true if and only if there are
exactly k inputs xi that are true. Similarly, for k ∈ N, the threshold gate
Thk has unbounded fan-in, and Thk (x1 , x2 , . . . , xn ) is true if and only if
there are at least k inputs that are true.
There are several equivalent characterizations of TC 0 in descriptive
complexity theory [10] (see also Section IV.1 for the descriptive characterization of AC 0 ). They are obtained by augmenting the ﬁrst-order logic FO
with quantiﬁers that correspond to the majority, counting or threshold
gates described above. For example, let LFO(M) denote the set of formulas
over the vocabulary LFO (41):
[0, max; X, BIT , ≤, =]
where a new quantiﬁer M is allowed. The meaning of this quantiﬁer is as
follows: for a ﬁnite structure M and a LFO(M) formula Mxϕ(x),
M |= Mxϕ(x)
iﬀ M |= ϕ(a) for at least half of the elements a in the universe of M. Let
FO(M) = {L : L = L(ϕ) for some LFO(M) -sentence ϕ}
and deﬁne FO(COUNT), FO(THRESHOLD) similarly. Then it can be
shown that
TC 0 = FO(M) = FO(COUNT) = FO(THRESHOLD).
TC 0 can also be deﬁned using other computation models, such as the
so-called Threshold Turing machines, but we will not go into detail here.
The proposition below uses the notion of AC 0 -reducibility deﬁned in
Section IX.1 and is based on the fact that TC 0 = FO(COUNT), or in
other words, numones is AC 0 -complete for TC 0 . (Recall the function
numones(y, X ) deﬁned on page 149: numones(y, X ) is the number of
elements of X that are < y.)

IX.3. Theories for TC 0

283

Proposition IX.3.1 ([10]). TC 0 is the AC 0 closure of numones. FTC 0
is the FAC 0 closure of numones.
0 and VTC 0 . The
Below we will introduce the theories VTC 0 , VTC
above proposition will be used to justify the association between these
theories and TC 0 .
0 , and VTC 0 . Here we specialize the
IX.3.2. The Theories VTC 0 , VTC
general treatment of VC given in Section IX.2 to the case C = TC 0 . The
theory VTC 0 is similar to VP (Deﬁnition VIII.1.1) in the sense that it is
axiomatized by V 0 and a deﬁning axiom for the function numones (which
is AC 0 complete for TC 0 ). The following deﬁning axiom for numones is
given in (108) on page 149:
numones(y, X ) = z ↔ z ≤ y ∧ ∃Z ≤ 1 + y, y, (Z)0 = 0 ∧
(Z)y = z ∧ ∀u < y, (X (u) ⊃ (Z)u+1 = (Z)u + 1) ∧
(¬X (u) ⊃ (Z)u+1 = (Z)u ).

(225)

(Recall that (Z)u denotes seq(u, Z), the u-th element of the bounded
sequence of numbers coded by Z, see Deﬁnition V.4.31.) We want to
deﬁne the theory VTC 0 by introducing an axiom which deﬁnes a string
function Numones(y, X ) = Z, where Z is the string asserted to exist in
the above formula (225) deﬁning numones.
However there is a technical diﬃculty here because not all of the bits
of Z are uniquely determined when we simply specify the values (Z)u .
To solve this problem, we introduce a formula SEQ(y, Z) which asserts
that Z is the lexicographically ﬁrst string which codes a given sequence of
numbers.
SEQ(y, Z) ≡


∀w < |Z| Z(w) ↔ ∃i ≤ y∃j < |Z|(w = i, j ∧ j = (Z)i ) . (226)
Let NUM (y, X, Z) be the ΣB0 (L2A ) formula obtained from (227) below by
eliminating seq as described in Lemmas V.4.15 and V.6.7:

SEQ(y, Z) ∧ (Z)0 = 0 ∧ ∀u < y (X (u) ⊃ (Z)u+1 = (Z)u + 1) ∧

(¬X (u) ⊃ (Z)u+1 = (Z)u ) . (227)
Informally, we can think of Z as a “counting sequence” for X :
(Z)u = z ↔ numones(u, X ) = z

for u ≤ y.

Deﬁnition IX.3.2 (VTC 0 ). Let NUMONES denote
∃Z ≤ 1 + y, yNUM (y, X, Z).
The theory VTC has vocabulary L2A and is axiomatized by the axioms of
V 0 and NUMONES.
0

284

IX. Theories for Small Classes

Note that V 0 (like VC in general) is a polynomial-bounded ﬁnitely
axiomatizable theory.
0 , we will use the “string version” of numones, denoted
To develop VTC
by Numones, that has the deﬁning axiom:
Numones(y, X ) = Z ↔ |Z| ≤ 1 + y, y ∧ NUM (y, X, Z).
By the above discussion for SEQ, Numones is uniquely speciﬁed by its
deﬁning equation, and hence (using the axiom NUMONES) it is ΣB1 deﬁnable in VTC 0 .
Since numones and Numones are AC 0 -deﬁnable from each other, Proposition IX.3.1 remains true if we replace numones by Numones.
Recall the notion of aggregate functions in Deﬁnition VIII.1.9. The
next lemma shows that VTC 0 is indeed an instance of the family VC
(because it shows that the existence of the value of Numones is provable
in VTC 0 ).
Lemma IX.3.3. The functions numones, Numones, and Numones are ΣB1 deﬁnable (and hence also Σ11 -deﬁnable) in VTC 0 , and the theory V 0 (Row,
Numones, Numones ) proves
∀i < b, Numones (b, Y, X )[i] = Numones((Y )i , X [i] ).

(228)

Proof. The fact that numones and Numones are provably total in VTC 0
is obvious. We will show that Numones is ΣB1 -deﬁnable in VTC 0 . The fact
that V 0 (Row, Numones, Numones ) (which extends VTC 0 ) proves (228)
will be clear from the proof below.
For convenience, we use the functions Row and seq in the deﬁning axiom
for Numones described below; it is straightforward to eliminate Row and
seq from the axiom (Lemmas V.4.27 and V.6.7).
Intuitively we need to show that VTC 0 (Row, seq) proves the existence
of Z such that for all i < b, Z [i] is the “counting sequence” for X [i] :
VTC 0 (Row, seq)  ∃Z∀i < b NUM ((Y )i , X [i] , Z [i] ).
The idea is to (i) concatenate the ﬁrst (Y )i bits of the rows X [i] , for
i < b, to form a “big” string X  , (ii) obtain the counting sequence Z  for
X  , and (iii) extract the desired array of counting sequences Z [i] from Z  .
We will use |Y | as an upper bound for (Y )i , for i < b. Thus, let X  be
deﬁned by
X  (i|Y | + x) ↔ x < (Y )i ∧ X [i] (x), for i < b.
In other words, for i < b, the bit string
X  (i|Y |) X  (i|Y | + 1) . . . X  (i|Y | + (Y )i − 1)
is a copy of
X [i] (0) X [i] (1) . . . X [i] ((Y )i − 1)

IX.3. Theories for TC 0

285

and X  (i|Y | + (Y )i ), . . . , X  ((i + 1)|Y | − 1) are all 0. Therefore, for
u ≤ (Y )i ,
numones(u, X [i] ) = numones(i|Y | + u, X  ) − numones(i|Y |, X  ).
Let Z  be such that NUM (b|Y |, X  , Z  ) holds, i.e., Z  is the “counting
sequence” for X  . Then
·
numones(u, X [i] ) = z ↔ (Z  )i|Y |+u −
(Z  )i|Y | = z.

Thus,
Numones (b, Y, X ) = Z ⊃



∀i < b∀u ≤ (Y )i (Z [i] )u = (Z  )i|Y |+u −· (Z  )i|Y | .

Although the RHS does not uniquely specify all the bits in Z, we can add
clauses which set all the undeﬁned bits to 0 using the method in (226) used
to deﬁne SEQ. It follows easily that Numones (b, Y, X ) is provably total
2
in VTC 0 .
Exercise IX.3.4. Similar to the aggregate of a string function, we can
deﬁne the aggregate of a number function as follows. Suppose that
f(x1 , . . . , xk , X1 , . . . , Xn ) is a polynomially bounded number function,
i.e., for some L2A term t,
f(x, X ) ≤ t(x, |X |).
Then f  (b, Z, X ) is the polynomially bounded string function that satisﬁes
|f  (b, Z, X )| ≤ b, 1 + t
and
f  (b, Z, X )(w) ↔ ∃u < b, w = u, f((Z1 )u , . . . , (Zk )u , X1[u] , . . . , Xn[u] ).
(229)
Show that numones is provably total in VTC 0 .
0 we need a quantiﬁer-free
Following Section IX.2.2, to deﬁne VTC
deﬁning axiom for Numones. (Formally we will not change the deﬁning
axiom for Numones but will introduce a function Numones that has the
same value as Numones and has a quantiﬁer-free deﬁning axiom.) So

let NUM
(y, X, Z) be a quantiﬁer-free LFAC 0 -formula (from Lemma V.6.3)
0
which V proves equivalent to NUM (y, X, Z).
Let Numones (y, X ) be deﬁned by

Numones (y, X ) = Z ↔ |Z| ≤ 1 + y, y ∧ NUM
(y, X, Z).


(230)

Thus Numones (y, X ) = Numones(y, X ), but they have diﬀerent deﬁning
axioms.

286

IX. Theories for Small Classes

0 is the universal theory over the vo0 ). VTC
Deﬁnition IX.3.5 (VTC

cabulary LVTC
0 = LFAC 0 ∪ {Numones } and is axiomatized by the axioms
0

of V and (230).
0

We deﬁne VTC using the number function numones instead of the
string function Numones . Here numones has the same value as numones
but it has the following quantiﬁer-free deﬁning axioms:
numones (0, X ) = 0,

(231)









X (z) ⊃ numones (z + 1, X ) = numones (z, X ) + 1,
¬X (z) ⊃ numones (z + 1, X ) = numones (z, X ).

(232)
(233)

Deﬁnition IX.3.6. LFTC 0 is the smallest set that contains LFAC 0 ∪
{numones } such that for every quantiﬁer-free LFTC 0 -formula ϕ(z, x, X )
and every L2A -term t = t(x, X ), there is a string function Fϕ(z),t in LFTC 0
with deﬁning axiom (86):
Fϕ(z),t (x, X )(z) ↔ z < t(x, X ) ∧ ϕ(z, x, X ).

(234)

0

0

VTC is the theory over LFTC 0 and is axiomatized by the axioms of V
together with (231), (232) and (233) for numones , and (234) for each
function Fϕ(z),t .
It is easy to see that Numones = Fϕ(z),t for some Fϕ(z),t ∈ LFTC 0 . On
the other hand, it is also easy to see that numones = |T | for some term
0 and
T ∈ L
. Therefore the results in Section IX.2 apply for VTC
0

0
VTC

VTC . We summarize the Deﬁnability Theorems for these theories as
follows:
0 , or L is L 0
and T is VTC
Theorem IX.3.7. Assume either L is L
0

0
VTC

FTC

and T is VTC . Then
(a) A function is in FTC 0 iﬀ it is represented by a term in LVTC
0 . A string

function is in FTC 0 iﬀ it is in LFTC 0 . A relation is in TC 0 iﬀ it is
represented by an open (or a ΣB0 ) formula in L.
(b) For every ΣB1 (L) formula ϕ + there is a ΣB1 -formula ϕ such that T 
ϕ + ↔ ϕ.
(c) T proves ΣB0 (L)-COMP, ΣB0 (L)-IND, and ΣB0 (L)-MIN.
0
0 , which is in turn
(d) VTC is a universal conservative extension of VTC
a universal conservative extension of VTC 0 .
(e) A function is in FTC 0 iﬀ it is ΣB1 -deﬁnable in VTC 0 iﬀ it is ΣB1 -deﬁnable
in T .
(f) A relation is in TC 0 iﬀ it is ΔB1 -deﬁnable in VTC 0 iﬀ it is ΔB1 -deﬁnable
in T .

IX.3. Theories for TC 0

287

Corollary IX.3.8. VTC 0 is a proper extension of V 0 . In fact, VTC 0 is
not ΣB0 -conservative over V 0 .
Proof. The ﬁrst sentence follows from the second, which is true because
VTC 0 proves the Pigeonhole Principle (Section IX.3.5 below), while this
principle is not provable in V 0 (Corollary VII.2.4).
Another way of proving the the ﬁrst sentence is to use Theorem IX.3.7
(e) above. Recall that the number function parity(X ), which is the parity
of the total number of elements in X (Section V.5.1), is not in FAC 0 .
Hence V 0 does not prove the deﬁning axiom for parity. On the other
hand, parity is in FTC 0 , since it can be easily computed using numones:
parity(X ) = numones(|X |, X )

mod 2.

So VTC 0 proves the deﬁning axiom for parity.

2

The problem of sorting a given sequence of natural numbers into nondecreasing order is complete for TC 0 [32]. Let (y, Z) encode a sequence
of (y + 1) numbers as in (226). For x ≤ y let rank(x, y, Z) be the number
that appears at the x-th position when X is sorted in nondecreasing order
(positions start from 0), and let rank(x, y, Z) = 0 if x > y. The next
exercise shows that rank is provably total in VTC 0 .
Exercise IX.3.9. Give a ΣB1 deﬁning axiom ϕ(x, y, z, Z) for rank(x, y,
Z), i.e., for y, Z such that SEQ(y, Z) holds:


∀x rank(x, y, Z) = z ⇔ ϕ(x, y, z, Z)
and show that
VTC 0  ∀x∀y∀Z∃!z ≤ |Z|ϕ(x, y, z, Z).
Hint: For each v deﬁne
V [v] = {u : u is a value in Z and u < v}.
Now let c(v) be the cardinality of V [v] . Show that for x ≤ y, rank(x, y, Z)
is precisely the smallest value v in the sequence Z such that x ≤ c(v).
IX.3.3. Number Recursion and Number Summation. The number recursion operation produces a new number function from existing number functions. This operation is similar to limited recursion (Deﬁnition VI.2.11) but the latter deﬁnes new string functions from existing string
functions. It is useful in characterizing FL and a number of its subclasses
(later we will use this to develop the theory VTC 0 V, an analogue of VPV
(Section VIII.2). See Sections IX.4.4, IX.4.8, IX.5.5, IX.6.4 and IX.3.4
below). The number summation operation is a special instance of number
recursion and is useful in characterizing FTC 0 .

288

IX. Theories for Small Classes

Deﬁnition IX.3.10 (Number Recursion). A number function f(y, x,
X ) is obtained by number recursion from g(x, X ) and h(y, z, x, X ) if
f(0, x, X ) = g(x, X ),
f(y + 1, x, X ) = h(y, f(y, x, X ), x, X ).

(235)
(236)

If further f(y, x, X ) < t(y, x, X ), then we also say that f is obtained by
t-bounded number recursion (t-BNR) from g and h. In particular, if f
is polynomially bounded then we say that f is obtained from g and h by
polynomial-bounded number recursion (pBNR).
Deﬁnition IX.3.11 (Number Summation). For a number function
f(y, x, X ), deﬁne the number function sumf (y, x, X ) by
y

sumf (y, x, X ) =

f(z, x, X ).
z=0

The function sumf is said to be deﬁned from f by number summation, or
just summation.
Theorem IX.3.12. A function is in FTC 0 iﬀ it is obtained from FAC 0
functions by ﬁnitely many application of composition, string comprehension,
and number summation iﬀ it is obtained from FAC 0 by AC 0 reduction and
number summation.
Proof. By Theorem IX.1.7 it suﬃces to prove that a function is in FTC 0
iﬀ it is obtained from FAC 0 by AC 0 reduction and number summation.
For the ONLY IF direction, by Proposition IX.3.1 we need only show
that numones can be obtained by number summation from AC 0 functions.
This fact is straightforward:
y

numones(y, X ) =

fX (z, X )
z=0

where fX (the “characteristic function of X ”) is the AC 0 function deﬁned
by


(237)
fX (z, X ) = w ↔ (X (z) ⊃ w = 1) ∧ (¬X (z) ⊃ w = 0) .
We prove the other direction by induction on the number of applications
of the number summation operation. The base case (number summation
is not used) is obvious. For the induction step, it suﬃces to show that
sumf is AC 0 reducible to f and numones. Thus we AC 0 -deﬁne a string
function Wf (y) from f that contains the right number of bits; namely if
W = Wf (y) then
W (xa + v) ↔ x ≤ y ∧ v < f(x)
where a = max({f(x) : x < y}). Then it is easy to verify that sumf (y) =
numones((y + 1)a, W ).
2

IX.3. Theories for TC 0

289

IX.3.4. The Theory VTC 0 V. We deﬁne here the theory VTC 0 V, another universal conservative extension of VTC 0 . The vocabulary of
VTC 0 V contains a symbol for each functions in FTC 0 , but here, except
for the FAC 0 functions, they are deﬁned using the number summation
scheme (based on Theorem IX.3.12).
Deﬁnition IX.3.13 (LVTC 0 V ). The vocabulary LVTC 0 V is the smallest
set that contains LFAC 0 such that:
1) For every number function f(y, x, X ) in LVTC 0 V the function
sumf (y, x, X ) is also in LVTC 0 V with deﬁning axioms
sumf (0, x, X ) = 0 ∧
sumf (y + 1, x, X ) = sumf (y, x, X ) + f(y, x, X ).

(238)

2) For every L2A -term t and quantiﬁer-free LVTC 0 V -formula ϕ the function Fϕ(z),t is in LVTC 0 V with deﬁning axiom (86):

Fϕ(z),t (x, X )(z) ↔ z < t(x, X ) ∧ ϕ(z, x, X ).

(239)

3) For every string function F (x, X ) in LVTC 0 V the number function
fF (x, X ) is also in LVTC 0 V with deﬁning axiom
fF (x, X ) = |F (x, X )|.

(240)

Corollary IX.3.14. (a) A function is in FTC 0 iﬀ it is represented by
a function symbol in LVTC 0 V .
(b) A relation is in TC 0 iﬀ it is represented by an open (or a ΣB0 ) formula
in LVTC 0 V .
Proof. Part (b) follows from part (a), and part (a) follows from Theorem IX.3.12. Note that closure of LVTC 0 V under string comprehension
(Deﬁnition IX.1.6) follows from item 2) in Deﬁnition IX.3.13 and closure
under composition follows from items 2) and 3).
2
Deﬁnition IX.3.15. The theory VTC 0 V has vocabulary LVTC 0 V and
0
axioms those of V and (238), (239), and (240) for the functions sumf ,
Fϕ(z),t , and fF , respectively.
The following Lemma is proved in the same way as Lemma V.6.4.
Lemma IX.3.16. VTC 0 V proves
ΣB0 (LVTC 0 V )-COMP, ΣB0 (LVTC 0 V )-IND and ΣB0 (LVTC 0 V )-MIN.
The next result is proved in the same way as Theorem IX.2.14.
Theorem IX.3.17. VTC 0 V is a universal conservative extension of VTC 0.
0

Proof. First, by deﬁnition, VTC 0 V extends V . As noted in the proof
of Theorem IX.3.12 (the ONLY IF direction), numones = sumfX where
fX is deﬁned in (237):


fX (z, X ) = w ↔ (X (z) ⊃ w = 1) ∧ (¬X (z) ⊃ w = 0) .

290

IX. Theories for Small Classes

It is easy to see that VTC 0 V proves the deﬁning axioms (231), (232), (233)
for numones . It follows that VTC 0 V extends VTC 0 .
Now we show that VTC 0 V is conservative over VTC 0 . Since VTC 0 V
extends VTC 0 , we have

Ti
VTC 0 V =
i≥0

where T0 = VTC and each Ti+1 is obtained from Ti by adding the
deﬁning axiom for a new function sumf , Fϕ(z),t , or fF . We show that
Ti+1 is conservative over Ti by showing that the new function of Ti+1 is
deﬁnable in Ti .
Let Li denote the vocabulary of Ti . Consider the case where the new
function in Ti+1 has the form Fϕ(z),t for some quantiﬁer-free Ti -formula ϕ
and L2A -term t. It is easy to see that Fϕ(z),t is deﬁnable in Ti if
0

Ti  ΣB0 (Li )-COMP.

(241)

Similarly suppose that the new function in Ti+1 has the form sumf for
some number function f ∈ Li . Following the IF direction of the proof of
Theorem IX.3.12, the fact that sumf is deﬁnable in Ti also follows from
(241). In fact using (241) above it can be shown that sumf is ΣB1 -deﬁnable
in Ti . This is left as an exercise. Recall the notion of aggregate function
for a number function in Exercise IX.3.4.
Exercise IX.3.18. Suppose that (241) holds. Show that both sumf and
sumf are deﬁnable in Ti .
It remains to prove (241). The proof is by induction on i. The
base case is Theorem IX.3.7 (c). The induction step follows from Theorem VIII.1.15 (using Lemma IX.2.15) and Corollary IX.3.19 below (using
Exercise IX.3.18).
2
The next result refers to number aggregates (Exercise IX.3.4) and is a
corollary of the Aggregate Function Theorem VIII.1.15.
Corollary IX.3.19 (Aggregate Number Function Theorem). Let T
be a theory with vocabulary L which extends V 0 (Row) and proves ΣB0 (L)COMP. Suppose that f and f  are deﬁnable in T (Deﬁnition V.4.1) and
T (f, f  ) proves (229). Then T (f) proves ΣB0 (L ∪ {f})-COMP.
Proof. Let F be the string function that contains at most one element
and |F | = f:
(f = 0 ⊃ |F | = 0) ∧ (f > 0 ⊃ (|F | = f ∧ ∀z < f(F (z) ↔ z + 1 = f))).
Then both F and F  are deﬁnable in T . So the corollary follows easily
from Theorem VIII.1.15.
2
The above proof method can be used to show that the next corollary
follows from the First Elimination Theorem IX.2.10.

IX.3. Theories for TC 0

291

Corollary IX.3.20 (Second Elimination Theorem). Let T be a theory
with vocabulary L which extends V 0 (Row) and proves ΣB0 (L)-COMP. Suppose that f and f  are ΣB1 -deﬁnable in T and T (f, f  ) proves (229).
Suppose also that every ΣB0 (L) formula is equivalent in T to a ΣB1 (L2A ) formula. Then every ΣB0 (L ∪ {f}) formula is equivalent in T (f) to a ΣB1 (L2A )
formula.
Corollary IX.3.21 (ΣB1 (LVTC 0 V ) Elimination). For each ΣB1 (LVTC 0 V )
formula ϕ + there is a ΣB1 formula ϕ so that VTC 0 V  ϕ + ↔ ϕ.
Proof. The argument is similar to the proof of Corollary IX.2.18 from
the First Elimination Theorem IX.2.10 (for string functions) but now we
also need to use the Second Elimination Theorem IX.3.20 (for number
functions). Let Ti and Li be as in the proof of Theorem IX.3.17. It suﬃces
to prove the statement of the present corollary with LVTC 0 V and VTC 0 V
replaced by Li and Ti . The proof is by induction on i as in the proof of
Corollary IX.2.18, but now we have the extra case of sumf to consider,
using Exercise IX.3.18 and Corollaries IX.3.19 and IX.3.20.
2
The deﬁnability theorems for VTC 0 V are as follows.
Corollary IX.3.22. (a) A function is in FTC 0 iﬀ it is ΣB1 -deﬁnable in
VTC 0 V.
(b) A relation is in TC 0 iﬀ it is ΔB1 -deﬁnable in VTC 0 V.
Proof. The corollary follows either from Theorems IX.3.7(e) and
IX.3.17, or directly from Theorem IX.3.12 and Lemma IX.3.16 using
the Herbrand Theorem.
2
IX.3.5. Proving the Pigeonhole Principle in VTC 0 . We present a proof
of the Pigeonhole Principle (Section VII.1.2) in VTC 0 . As mentioned in
the proof of Corollary VII.2.4 this implies that VTC 0 is a proper extension
of V 0 . In Chapter X we show that each ΣB0 theorem of VTC 0 translates
into a family of tautologies having polysize bounded depth PTK proofs
(Corollary X.4.19). It follows that the family PHP (Deﬁnition VII.1.12)
has polysize bounded depth PTK proofs. This separates bounded depth
PK from bounded depth PTK. Furthermore we show in Section IX.5.4
that VNC 1 extends VTC 0 . Therefore PHP is also provable in VNC 1 .
The Propositional Translation Theorem for VNC 1 (Theorem X.3.1 and
Corollary X.3.4) thus allow us to derive a theorem of Buss [21] that PHP
has polysize Frege proofs.
The formula PHP(a, X ) is deﬁned in Example VII.2.1 as follows:
∀x ≤ a∃y < aX (x, y) ⊃
∃x ≤ a∃z ≤ a∃y < a(x = z ∧ X (x, y) ∧ X (z, y)).
Theorem IX.3.23. VTC 0  PHP(a, X ).

(242)

292

IX. Theories for Small Classes

Proof. Since VTC 0 (numones) is conservative over VTC 0 , it suﬃces to
show that
VTC 0 (numones)  PHP(a, X ).
We prove by contradiction, so assume that
∀x ≤ a∃y < aX (x, y)

(243)

and
∀x ≤ a∀z ≤ a∀y < a((x = z ∧ X (x, y)) ⊃ ¬X (z, y)).

(244)

Let P be the set of pigeons:
P = {0, 1, 2, . . . , a}.
Let ϕ(x, y) be the following formula which asserts that y is the ﬁrst hole
that pigeon x occupies:
ϕ(x, y) ≡ x ≤ a ∧ y < a ∧ X (x, y) ∧ ∀v < y¬X (x, v).
Then by (243) and (244) ϕ deﬁnes an injective function from P into the
set of holes {0, 1, 2, . . . , a − 1}, i.e., VTC 0 proves
∀x ≤ a∃!y < aϕ(x, y) ∧ ∀x ≤ a∀z ≤ a∀y < a((x = z ∧ ϕ(x, y)) ⊃
¬ϕ(z, y)).
Let H be the image of P (deﬁned using ΣB0 -COMP):
|H | ≤ a ∧ ∀y < a(H (y) ↔ ∃x ≤ aϕ(x, y)).
Then it is easy to see that ϕ deﬁnes a bijection between P and H (i.e., ϕ
satisﬁes the premise of (245) below for b = a + 1). Lemma IX.3.24 below
shows that P and H have the same cardinality:
VTC 0 (numones)  numones(a + 1, P) = numones(a + 1, H ).
However, it is easy to show in VTC 0 that numones(a + 1, P) = a + 1 and
numones(a + 1, H ) ≤ a, a contradiction.
2
For the following lemma, informally we show that if there is a bijection
between two sets P and H that is described by a ΣB0 formula ϕ(x, y), then
provably in VTC 0 (numones) the sets have the same cardinality.
Lemma IX.3.24. For any ΣB0 (numones) formula ϕ(x, y), the following is
a theorem of VTC 0 (numones):

∀x < b(P(x) ⊃ ∃!y < b(ϕ(x, y) ∧ H (y)) ∧ ∀y < b(H (y) ⊃

∃!x < a(ϕ(x, y) ∧ P(x)) ⊃ numones(b, P) = numones(b, H ). (245)
Proof. Let Z be the array whose rows Z [i] are the images of the initial
segments Cut(i, P) of P under the bijection, i.e.,


∀i < b∀y < b Z [i] (y) ↔ ∃x < i(ϕ(x, y) ∧ P(x)) .

IX.3. Theories for TC 0

293

Since ϕ is ΣB0 (numones) and VTC 0 (numones)  ΣB0 (numones)-COMP (by
Theorem IX.3.7 (c)), VTC 0 (numones) proves the existence of such Z.
Now we prove by induction on i < b that
numones(i, P) = numones(b, Z [i] ).

(246)

It will follow that numones(b, P) = numones(b, Z [b] ), and since Z [b] =
Cut(b, H ) we have numones(b, P) = numones(b, Cut(b, H )), so
numones(b, P) = numones(b, H ).
The base case (i = 0) is obvious. For the induction step, assume that
(246) is true for some i ≥ 0. We show that it is also true for i + 1. There
are two cases: either i ∈ P or i ∈ P.
First, suppose that i ∈ P, then numones(i + 1, P) = numones(i, P) + 1.
Let j ∈ Z [i+1] be such that ϕ(i, j) holds. Then j ∈ Z [i] , and it can be
shown by induction on y that

numones(y, Z [i] )
if y ≤ j,
numones(y, Z [i+1] ) =
numones(y, Z [i] ) + 1 if y ≥ j + 1.
Hence numones(b, Z [i+1] ) = numones(b, Z [i] ) + 1, and we are done.
The other case is similar.
2
0
IX.3.6. Deﬁning String Multiplication in VTC . Recall that bin(X ) is
the integer value associated with a string X (46) (page 85):
X (i)2i .

bin(X ) =
i∈X

The string multiplication function, X ×2 Y (or simply X × Y ) is deﬁned
so that
bin(X × Y ) = bin(X ) × bin(Y ).
Exercise VI.2.7 shows that this function is ΣB1 -deﬁnable in V 1 . Here we
will show that it is actually ΣB1 -deﬁnable in VTC 0 by formalizing in VTC 0
a TC 0 algorithm that computes X × Y . Furthermore, VTC 0 proves the
usual properties of this function, such as commutativity, distributivity
over X + Y , etc.
Notice that the “school” algorithm described in Exercise VI.2.7 is a
polytime algorithm. The main component of this algorithm is the polytime process that computes the sum of all rows of the table X ⊗ Y . The
TC 0 algorithm for X × Y is obtained by replacing this polytime process
by a uniform family of TC 0 circuits. First, we outline this TC 0 algorithm
and formalize it in VTC 0 by showing that the function Sum deﬁned below
is ΣB1 -deﬁnable in VTC 0 .
For the formalizations, recall the string functions ∅, S(X ), X + Y given
in Example V.4.17, Cut(x, X ) on page 139, and the number function
log(x + 1) in Exercise III.3.30.

294

IX. Theories for Small Classes

IX.3.6.1. Adding n Strings. Suppose that we are to add n integers written as n binary strings, each of length m. The idea is to write these
binary strings as rows in a table of n rows and m columns, then divide the
columns of the table into blocks of  columns each (for some parameter
 to be determined later) so that the sum of the rows in each block can
be easily computed in TC 0 , and the desired result can be computed from
these sums by a TC 0 circuit.
More precisely let  = log2 (n + 1). Then in each block Bi , each row
can be seen as a number with value ≤ 2 − 1. Therefore the sum of the
rows in Bi is at most
n(2 − 1) < 22
and hence has a binary representation of length at most 2. It is important
that this sum can be deﬁned as the number of 1-bits in a long string easily
obtained from Bi .
Now let bi be the sum of the rows in the block Bi . Then the required
sum is
2i bi .

(247)

i

Write each bi as a binary string of length exactly 2 (add preceding 0’s if
necessary). Then
b0 + 22 b2 + 24 b4 + . . .

(248)

is simply the concatenation of the strings b0 , b2 , b4 , . . . , and similarly for
2 b1 + 23 b3 + 25 b5 + . . . .

(249)

As a result, (247) can be computed in AC 0 by adding the above two sums.
IX.3.6.2. Formalization. For the formalization, we will use the function
numones and some AC 0 functions such as the length function for numbers
|x| = log2 (x + 1) (see Exercise III.3.30, Section III.3.3). It will be clear
that the functions deﬁned here belong to LFTC 0 .
Suppose that the n input strings are given as the rows Z [0] , . . . , Z [n−1]
in an array Z. We will deﬁne in VTC 0 the function Sum(n, m, Z) that
satisﬁes
Sum(0, m, Z) = ∅,

(250)
[n]

Sum(n + 1, m, Z) = Sum(n, m, Z) + Cut(m, Z )
where Cut(x, X ) is the ﬁrst x bits of X (97):
Cut(x, X )(z) ↔ z < x ∧ X (z).

(251)

IX.3. Theories for TC 0

295

We deﬁne the columns of Z as strings using the function Transpose
deﬁned as follows:

Transpose(n, m, X ) = Y ↔ |Y | ≤ m, n ∧


∀z < m, n Y (z) ↔ ∃i < m∃j < n(z = i, j ∧ X (j, i)) . (252)
Let V = Transpose(n, m, Z). Then the sum of the bits in column i of Z is
ci = numones(n, V [i] ).
Let
 = |n|,

k = m/2.

0

Note that  is an AC function of n (Exercise III.3.30). We want the
sequence B: (B)0 = b0 , (B)1 = b1 , . . . , (B)2k = b2k (see (247)) so that
−1

(B)i =

2j ci+j .
j=0

We show below how to deﬁne each (B)i by a ΣB1 formula. It follows from
Exercise IX.3.4 that B is also ΣB1 -deﬁnable in VTC 0 .
To deﬁne (B)i , it suﬃces to deﬁne a string U that contains exactly (B)i
1-bits. Then
(B)i = numones(|U |, U ).
Notice that ci ≤ n for 0 ≤ i < m. The string U consists of
1 + 21 + 22 + · · · + 2−1 = 2 − 1
substrings and each has n bits, so that for j < , 2j substrings contain
exactly ci+j 1-bits. Thus U can be deﬁned as follows:


|U | ≤ 2 n ∧ ∀j < ∀u < 2j ∀v < n U ((2j − 1)n + un + v) ↔ v < ci+j .
Now the sum (248) is formally deﬁned as a string L with bit deﬁnition:

|L| ≤ 2k ∧ ∀x < 2k L(x) ↔ ∃i < k∃y < 2(x = 2i + y ∧

BIT(y, (B)2i ))
(where BIT is the Δ0 formula deﬁned in Section III.3.3). Similarly, the
sum (249), denoted by H , is deﬁned as follows:

|H | ≤ 2k ∧ ∀x < 2k H (x) ↔ ∃i < k∃y < 2(x = (2i + 1) + y ∧

BIT (y, (B)2i+1 )) .
Finally
Sum(n, m, Z) = L + H.

296

IX. Theories for Small Classes
0

Lemma IX.3.25. The theory VTC proves (250) and (251).
0

Proof. We reason in VTC . If n = 0 then  = 0, so it is easy to see
that Sum(0, m, Z) = ∅. This establishes (250).
We prove (251) by induction on m. The base case (m = 0) is obvious.
For the induction step, we need the exercise below. Here Shift(x, y) is the
string obtained by shifting all bits of the binary representation of y by x
positions to the left:
Shift(x, y) = U ↔


|U | ≤ x + |y| ∧ ∀z < x + |y|(U (z) ↔ ∃i < |y|BIT (i, y)) .
0

Example IX.3.26 (Provable in V ).
Shift(x, y + z) = Shift(x, y) + Shift(x, z).
0

Exercise IX.3.27. Show that it is provable in VTC that
Sum(n, m + 1, Z) = Sum(n, m, Z) + Shift(m, cm )
where cm is the sum of the ﬁrst n bits in column m of Z:
cm = numones(n, V [m] )

where V = Transpose(n, m + 1, Z).

0

Reasoning in VTC , the induction step follows from Exercise IX.3.27
as follows. Suppose that we need to prove (251) for m + 1. Let cm be the
sum of the ﬁrst (n + 1) bits in column m of Z:
cm = numones(n + 1, Transpose(n + 1, m, Z)[m] ).
Then
cm = cm + Z [n] (m).

(253)

By Exercise IX.3.27 we need to prove
Sum(n + 1, m, Z) + Shift(m, cm ) =
Sum(n, m, Z) + Shift(m, cm ) + Cut(m + 1, Z [n] ).
By the induction hypothesis,
Sum(n + 1, m, Z) = Sum(n, m, Z) + Cut(m, Z [n] ).
Also,
Cut(m + 1, Z [n] ) = Cut(m, Z [n] ) + Shift(m, Z [n] ).
So we need to show that
Shift(m, cm ) = Shift(m, cm ) + Shift(m, Z [n] (m)).
This follows from Example IX.3.26 and (253).

2

IX.3. Theories for TC 0

297

IX.3.6.3. Deﬁning X × Y . To deﬁne X × Y we use the table X ⊗ Y
given in Exercise VI.2.7 and can be equivalently deﬁned as follows:

X ⊗ Y = Z ↔ |Z| ≤ |Y |, |X | + |Y | ∧

∀i < |Y |((¬Y (i) ⊃ Z [i] = ∅) ∧ (Y (i) ⊃ Z [i] = Shift(i, X )))
where Shift(x, Y ) is the string obtained from Y by shifting all bits x
positions to the left
Shift(x, Y ) = Z ↔
|Z| ≤ x + |Y | ∧ ∀z < x + |Y |(Z(z) ↔ ∃u < |Y |, Y (u) ∧ z = x + u).
(Notice that Shift(x, y) and Shift(x, Y ) have diﬀerent arity, so even though
they have the same name, their meaning will be clear from context.)
We deﬁne
X × Y = Sum(|Y |, |X | + |Y |, X ⊗ Y ).
0

Lemma IX.3.28. VTC  X × Y = Y × X .
Proof. By deﬁnition, we need to show that
Sum(|Y |, |X | + |Y |, X ⊗ Y ) = Sum(|X |, |X | + |Y |, Y ⊗ X ).
Therefore it suﬃces to show that the columns of X ⊗ Y and Y ⊗ X have
the same number of 1-bits:
numones(|Y |, V [i] ) = numones(|X |, W [i] )

(254)

for i < |X | + |Y | and
V = Transpose(|X |, |X | + |Y |, X ⊗ Y ),
W = Transpose(|Y |, |X | + |Y |, Y ⊗ X ).
Notice that there is a bijection between V [i] and W [i] deﬁned by
·
z)
V [i] (z) ↔ W [i] (i −

for z ≤ i

because
V [i] (z) ↔ Y (z) ∧ X (i −· z) and W [i] (z) ↔ X (z) ∧ Y (i −· z).
So the conclusion follows from Lemma IX.3.24.
0
Lemma IX.3.29. VTC  X × (Y + Z) = X × Y + X × Z.
Proof. We will prove by induction on i ≤ |X | that

2

Cut(i, X ) × (Y + Z) = Cut(i, X ) × Y + Cut(i, X ) × Z.

(255)

The lemma follows by letting i = |X |.
For the base case, i = 0, we have Cut(0, X ) = ∅. So this case follows
from Exercise IX.3.31 (a) below and Lemma IX.3.28.
For the induction step, suppose that (255) holds for some i ≥ 0. We
prove it for i + 1. There are two cases: either i ∈ X or i ∈ X . In the

298

IX. Theories for Small Classes

second case Cut(i + 1, X ) = Cut(i, X ) so the conclusion if obvious. Thus
we consider the case where i ∈ X . We have
Cut(i + 1, X ) = Cut(i, X ) + {i}.
We need the following results:
0

Exercise IX.3.30. Show that the following are theorems of VTC :
(a) |X | ≤ i ⊃ (X + {i}) × Y = X × Y + {i} × Y .
(b) {i} × X = {x + i : x ∈ X }.
(c) {i} × (Y + Z) = {i} × Y + {i} × Z.
Now |Cut(i, X )| ≤ i. Using Exercises IX.3.30 and V.4.19 and the
induction hypothesis we have
Cut(i + 1, X ) × (Y + Z)
= (Cut(i, X ) + {i}) × (Y + Z)
= Cut(i, X ) × (Y + Z) + {i} × (Y + Z)
= (Cut(i, X ) × Y + Cut(i, X ) × Z) + ({i} × Y + {i} × Z)
= (Cut(i, X ) × Y + {i} × Y ) + (Cut(i, X ) × Z + {i} × Z)
= (Cut(i, X ) + {i}) × Y + (Cut(i, X ) + {i}) × Z
= Cut(i + 1, X ) × Y + Cut(i + 1, X ) × Z.
2

So (255) holds for i + 1.
0

Exercise IX.3.31. Show that the following are theorems of VTC :
(a) X × ∅ = ∅.
(b) X × S(Y ) = (X × Y ) + X .
Exercise IX.3.32. Show that
0

VTC  (X × Y ) × Z = X × (Y × Z).
Hint: First prove the equation for Z of the form {i}. Then prove by
induction on i that
(X × Y ) × Cut(i, Z) = X × (Y × Cut(i, Z)).
IX.3.7. Proving Finite Szpilrajn’s Theorem in VTC 0 . One version of
Szpilrajn’s Theorem states that every partial order can be extended to a
total order. Here we show that VTC 0 proves this for ﬁnite partial orders.
A partial order is a binary relation on a set S which is reﬂexive, antisymmetric, and transitive. A partial order is total if every two elements
are comparable. We represent a partial order ' on {0, 1, . . . , n − 1} by an
array X , where X (i, j) holds iﬀ i ' j. The above properties are expressed

IX.3. Theories for TC 0

299

by the following four ΣB0 -formulas:
Reﬂex(n, X ) ≡ ∀x < nX (x, x),


Anti(n, X ) ≡ ∀x, y < n (X (x, y) ∧ X (y, x)) ⊃ x = y ,


Trans(n, X ) ≡ ∀x, y, z < n (X (x, y) ∧ X (y, z)) ⊃ X (x, z) ,
Total(n, X ) ≡ ∀x, y < n(X (x, y) ∨ X (y, x)).
Thus X represents a partial order on {0, 1, . . . , n − 1} if it satisﬁes the
formula Partial(n, X ), where
Partial(n, X ) ≡ Reﬂex(n, X ) ∧ Anti(n, X ) ∧ Trans(n, X ).
Finite Szpilrajn’s Theorem can be expressed by the formula

Partial(n, X ) ⊃ ∃Z ∀x, y < n(X (x, y) ⊃ Z(x, y)) ∧


Partial(n, Z) ∧ Total (n, Z) . (256)

Theorem IX.3.33. VTC 0 proves (256).
Proof. Assume Partial(n, X ), and deﬁne an array Y which stores the
sums of the columns of X (interpreted as a 0-1 matrix). That is, (Y )x =
numones(n, X̂ [x] ), where X̂ = Transpose(n, n, X ). Now we deﬁne Z(x, y)
to hold iﬀ


x < n ∧ y < n ∧ (Y )x < (Y )y ∨ ((Y )x = (Y )y ∧ X (x, y)) .
The following exercise completes the proof.

2

0

Exercise IX.3.34. Show that VTC (and hence VTC 0 ) proves (256)
when Z is deﬁned as above.
IX.3.8. Proving Bondy’s Theorem. Consider a 2 × 2 0-1 matrix whose
rows are distinct, e.g.:
0

1

0

0

It is easy to see that there is always a column whose removal from the
matrix results in a column of two distinct bits. On the other hand if we
start with a 3 × 2 0-1 matrix of distinct rows, then after removing any
column there is always a pair of rows that contain the same bit.
Bondy’s Theorem [16] states more generally that for any n × n 0-1
matrix whose rows are distinct we can always delete a column so that
the remaining n × (n − 1) matrix still has n distinct rows. (It is easy to
construct a (n + 1) × n matrix with (n + 1) distinct rows such that deleting
any column results in a pair of identical row.)
Frankl’s Theorem [51] generalizes further by specifying a maximal value
for m such that any m × n matrix with distinct rows contains a column

300

IX. Theories for Small Classes

whose deletion results in a m × (n − 1) matrix that contains at least
m − 2t−1 + 1 distinct rows. Here we will formalize Bondy’s Theorem (i.e.,
the case t = 1) and show that V 0 proves its equivalence to PHP. It can be
shown that the case t = 2 is also equivalent to PHP over V 0 . Thus these
cases are provable in VTC 0 . However, it is not known whether the same
is true for other cases.
To formulate Bondy’s Theorem, an m × n 0-1 matrix will be encoded by
a string X : X (i, j) holds iﬀ the entry with indices (i, j) is 1, for 0 ≤ i < m,
0 ≤ j < n. We will also write X (i, j) = 1 for X (i, j) and X (i, j) = 0
for ¬X (i, j). The following ΣB0 formula states that the rows of the m × n
matrix X are distinct:
DISTINCT(m, n, X ) ≡ ∀i1 < m∀i2 < i1 ∃j < n(X (i1 , j) ↔ ¬X (i2 , j)).
(257)
Let BONDY(n, X ) denote
DISTINCT(n, n, X ) ⊃
∃j < n∀i1 < n∀i2 < i1 ∃k < n(k = j ∧ (X (i1 , k) ↔ ¬X (i2 , k))).
Let BONDY (resp. PHP) denote the universal closure of BONDY(n, X )
(resp. PHP(y, X )).
Theorem IX.3.35 ([17]). V 0  BONDY ↔ PHP.
To prove the theorem we use the following principle, called the surjective
(or also dual) Pigeonhole Principle, which says that there is no surjective
(single-valued) mapping from n “holes” to (n + 1) “pigeons” (S stands
for surjective):
SPHP(n, X ) ≡ ∀i < n∃!j ≤ nX (i, j) ⊃ ∃j ≤ n∀i < n¬X (i, j).
By considering inverse maps the following fact is easy to prove.
Exercise IX.3.36. Show that V 0  SPHP ↔ PHP (where SPHP is the
universal closure of SPHP(n, X )).
(In Section IX.4.3 we will deﬁne OPHP, a weaker version of the Pigeonhole Principle and show that it is provable in the theory V 0 (2) (Section IX.4). On the other hand, it is not known whether PHP is provable
in V 0 (2).)
Proof of Theorem IX.3.35. By Exercise IX.3.36 it suﬃces to show that
V 0  SPHP ↔ BONDY.
First we show that
V 0  SPHP ⊃ BONDY.
Given an n × n matrix X with distinct rows we need to show that there
exists a column j that can be removed without creating identical rows. A
key observation is as follows. Suppose that we order the rows (regarded

IX.3. Theories for TC 0

301

as binary strings) lexicographically in increasing order (comparing the
left-most bits ﬁrst). Associate each row i of the ﬁrst (n − 1) rows (i.e.,
i < n − 1) with the left-most column ji that distinguishes row i and row
(i + 1). Then the columns {j0 , j1 , . . . , jn−2 } suﬃce to distinguish all n
rows. By SPHP there is at least one column not listed in the set, and
hence it can be removed without creating any identical rows.
This observation can be proved as follows. By the lexicographical
ordering of the rows we must have
X (i, ji ) = 0 ∧ X (i + 1, ji ) = 1.
It suﬃces to show that for any i = i  (i, i  < n − 1) there is i  so that rows
i and i  are diﬀerent on column ji  . Suppose without loss of generality
that i < i  , and let j be the left-most position where rows i and i  diﬀer.
(See Figure 5.) Then we must have
X (i, j) = 0 ∧ X (i  , j) = 1.
Let i  be the largest number such that row i  agrees with row i up to
(including) column j. Then it can be seen that ji  = j, so rows i and i 
diﬀer on column ji  .
i

A

0

i 

A

0

i +1

A

1

i

A

1



j
Figure 5. An i  such that rows i and i  diﬀer on column
ji  . From the top down, the rows are ordered lexicographically.
In other words, the set {j0 , j1 , . . . , jn−2 } already distinguishes all rows
of the given matrix. By SPHP, the map
{0, 1, . . . , n − 2} → {0, 1, . . . , n − 1} : i %→ ji
is not surjective. Therefore there is k ≤ n − 1 such that k ∈ {j0 , j1 , . . . ,
jn−2 }. Then we can remove column k without creating identical rows.

302

IX. Theories for Small Classes

For the formalization, the main task is to deﬁne the map i %→ ji and
to show the existence of ji  as above. The rows of X can be compared
by the following ΣB0 formula (notice we do not need the actual position of
the rows in this ordering):
i ≺m,n,X k

(or just i ≺ k)

(258)

which is true iﬀ row i is lexicographically less than row k:


i ≺ k ≡ ∃j < n∀ < j ¬X (i, j) ∧ X (k, j) ∧ (X (i, ) ↔ X (k, )) .
Then we can deﬁne a ΣB0 formula PRED(i, k, m, n, X ) which is true iﬀ k
is the next row of i in the lexicographical ordering:
PRED(i, k, m, n, X ) ≡ i ≺ k ∧ ∀k  (i ≺ k  ⊃ k ' k  ).
(Here k ' k  stands for k = k  ∨ k ≺ k  .)
We also need the fact that there is a ≺-maximal index i0 (so that the map
i %→ ji is not deﬁned for i0 and we can apply the SPHP). For this, observe
that BONDY(n, X ) is equivalent to BONDY(n, X  ) where X  is obtained
from X by simultaneously ﬂipping all bits in some columns. Therefore
we can assume that row (n − 1) of X contains all 1’s, and hence n − 1 is
≺-maximum.
Now using ΣB0 -MIN it can be shown in V 0 that every row i, where
i < n − 1, has a unique “next” row:
∀i < n − 1∃!k PRED(i, k, m, n, X ).
Exercise IX.3.37. Formally deﬁne using ΣB0 -COMP the mapping ji as
a string Y : for i < n − 1
Y (i, j) ≡ j = ji .
Then use SPHP(n − 1, Y ) to derive BONDY(n, X ).
Now we show
V 0  ¬SPHP ⊃ ¬BONDY.
Consider the following (n + 1) × n matrix (which can be deﬁned using
ΣB0 -COMP):
⎛
⎞
0 0 ... 0
⎜ 1 0 ... 0 ⎟
⎜
⎟
⎜
⎟
A = ⎜ 0 1 ... 0 ⎟.
⎜ .. .. . .
.. ⎟
⎝ . .
. . ⎠
0 0 ... 1
It is easy to see that the rows of A are distinct, and removing any column
j from A will result in two rows 0 and j + 1 being identical.
Suppose that ¬SPHP(n, Y ) holds for some (n, Y ), i.e., Y speciﬁes a
surjective mapping
Y : {0, 1, . . . , n − 1} → {0, 1, . . . , n}.

IX.4. Theories for AC 0 (m) and ACC

303

We deﬁne a n × n matrix X as follows. For i < n, row X [i] is the same
as row A[k] , where k is the image of i under Y , i.e., k is the unique value,
k ≤ n, such that Y (i, k) holds. Since the rows of A are distinct, the
rows of X are also distinct. Moreover, removing a column j from X will
make rows i0 and i1 identical, where i0 and i1 are such that Y (i0 , 0) and
Y (i1 , j + 1) hold. Hence ¬BONDY(n, X ).
2

IX.4. Theories for AC 0 (m) and ACC
In this section we develop the theories associated with the classes
AC 0 (m), m ≥ 2 and their union ACC. These classes lie between AC 0
and TC 0 . In Section IX.4.1 we deﬁne the classes. In Section IX.4.2 we

0 (2) and V 0 (2) for AC 0 (2). Functions in
deﬁne the theories V 0 (2), V
0
FAC (2) can be characterized by a bounded number recursion (BNR)
scheme (see Section IX.3.3) and in Section IX.4.4 we use this to develop
VAC 0 (2)V, another universal conservative extension of V 0 (2). A discrete
version of the Jordan Curve Theorem can be proved in V 0 (2) and we
present the formalization in Section IX.4.5. Then in Section IX.4.6 we
deﬁne theories for other classes AC 0 (m). Finally, the class FAC 0 (6) also
has a recursion characterization using the BNR scheme, and we use this
to develop VAC 0 (6)V in Section IX.4.8.
IX.4.1. The Classes AC 0 (m) and ACC. For each m ∈ N, m ≥ 2,
the classes nonuniform/uniform AC 0 (m) are deﬁned just as nonuniform/uniform TC 0 but using modulo m gates instead of majority gates.
A modulo m gate has unbounded fan-in and outputs 1 if and only if the
total number of 1 inputs is exactly 1 modulo m. Also,

AC 0 (m).
ACC =
i≥2

See Appendix A.5 for a formal deﬁnition.
Obviously AC 0 ⊆ AC 0 (m). Furthermore, the relation PARITY (Sections IV.1 and V.5.1):
PARITY (X ) iﬀ X contains an odd number of elements
is in AC (2). Since PARITY ∈ AC 0 , it follows that AC 0  AC 0 (2).
It is easy to show that for 2 ≤ m1 < m2 ∈ N, if m1 : m2 then
0

AC 0 (m1 ) ⊆ AC 0 (m2 ).
On the other hand, let MODULOp (X ) be the relation
MODULOp (X ) iﬀ the number of elements of X is = 1 mod(p).
Then
MODULOp (X ) ∈ AC 0 (p).

304

IX. Theories for Small Classes

A major result in complexity theory due to Razborov and Smolensky (see
[19]) states that for any prime p and any m ≥ 2 which is not a power of p,
MODULOm ∈ AC 0 (p).
As a result,
AC 0 (m) ⊆ AC 0 (p).
Also modulo m gates can be easily simulated by threshold gates. Thus
AC 0  AC 0 (p)  ACC ⊆ TC 0
(the last inclusion is because counting gates can simulate a modulo m
gate, for any m). On the other hand, it is an open problem whether
AC 0 (m)  ACC for composite m ∈ N. In fact, it is not known whether
AC 0 (6)  NP.
In descriptive complexity, uniform AC 0 (m) (or just AC 0 (m)) can be
characterized using the mod(m) quantiﬁer [10]. Here we use the fact that
the following function is (Turing) AC 0 complete for AC 0 (m):
mod m (x, Y ) = numones(x, Y ) mod m.

(259)

The “string version” of this function, called Mod m (x, Y ), is the sequence of the values of mod m (z, Y ) for z ≤ x:
Mod m (x, Y ) = Z ↔ SEQ(x, Z) ∧


|Z| ≤ 1 + x, m ∧ ∀z ≤ x((Z)z = mod m (z, Y ))

(260)

where SEQ is deﬁned in (226).
We use the following result (based on [10]) to deﬁne our theories
for AC 0 (m).
Proposition IX.4.1. A relation is in AC 0 (m) iﬀ it is AC 0 -reducible to
mod m iﬀ it is AC 0 -reducible to Mod m . A function is in FAC 0 (m) iﬀ it is
AC 0 -reducible to mod m iﬀ it is AC 0 -reducible to Mod m .
The next section treats the case m = 2, and Section IX.4.6 treats theories
for AC 0 (m) for m ≥ 3.

0 (2), and V 0 (2). For m = 2 the function
IX.4.2. The Theories V 0 (2), V
Mod m as deﬁned in (260) has a simpler version which we call Parity(x, Y ).
The graph of this function is deﬁned by the ΣB0 -formula parity (x, Y, Z)
which asserts that for 1 ≤ z ≤ x, Z(z) holds iﬀ there is an odd number
of ones in Y (0)Y (1) . . . Y (z −· 1):
parity (x, Y, Z) ≡ ¬Z(0) ∧ ∀z < x(Z(z + 1) ↔ (Z(z) ⊕ Y (z))).
Thus Parity is deﬁned by



Parity(x, Y ) = Z ↔ |Z| ≤ x + 1 ∧ parity (x, Y, Z) .

(261)

IX.4. Theories for AC 0 (m) and ACC

305

Deﬁnition IX.4.2 (V 0 (2)). The theory V 0 (2) has vocabulary L2A and
axioms those of V 0 and
∃Z ≤ x + 1 parity (x, Y, Z).
Since parity (x, Y, Z) uniquely determines Z as a function of x, Y it
follows from (261) that Parity(x, Y ) is ΣB1 -deﬁnable in V 0 (2).
The next lemma shows that the aggregate Parity of Parity (see Deﬁnition VIII.1.9) is deﬁnable in V 0 (2), and hence V 0 (2) is indeed an instance
of the family VC.
Lemma IX.4.3. The function Parity is ΣB1 -deﬁnable in V 0 (2), and the
theory V 0 (Row, Parity, Parity ) proves
∀i < b, Parity (b, Y, X )[i] = Parity((Y )i , X [i] ).
Proof. The argument is very similar to the proof of Lemma IX.3.3
(showing that Numones is ΣB1 -deﬁnable in VTC 0 ).
2
Exercise IX.4.4. Carry out the above proof.

0 (2) we need a quantiﬁer-free
Following Section IX.2.2, to deﬁne V
deﬁning axiom for Parity. Instead of appealing to Lemma V.6.3 to ﬁnd
a quantiﬁer-free version of parity (x, Y, Z) we will give an explicit deﬁning
axiom for Parity by introducing a new free variable u in the deﬁnition.
Parity (x, Y ) = Z ⊃ |Z| ≤ x + 1 ∧ ¬Z(0) ∧


u < x ⊃ (Z(u + 1) ↔ (Z(u) ⊕ Y (u))) . (262)
Note that Parity satisﬁes this deﬁning axiom for Parity , and V 0 (Parity,
Parity ) proves Parity(y, X ) = Parity (y, X ).

0 (2) is deﬁned to be V 0 (Parity ) with the deﬁning
The universal theory V
axiom (262) for Parity . Its vocabulary LFAC 0 ∪ {Parity } is denoted by
LV
. The theory V 0 (2) is deﬁned as follows. Its vocabulary, LFAC 0 (2)
0 (2)

is the smallest set that contains LV
such that for every L2A -term t and
0 (2)
LFAC 0 (2) -formula ϕ, there is a string function Fϕ(z),t with deﬁning axiom
0

(86). Then V 0 (2) is axiomatized by the axioms of V together with (262)
for Parity and (86) for each function Fϕ(z),t .
The results of Section IX.2 apply to the theories just deﬁned, so the
following statements are corollaries of that section.

0 (2), or L is
Theorem IX.4.5. Assume either L is L
and T is V

0 (2)
V

LFAC 0 (2) and T

is V 0 (2).

(and
(a) A function is in FAC 0 (2) iﬀ it is represented by a term in LV
0 (2)
for string functions) iﬀ it is represented by a symbol in LFAC 0 (2) . A
relation is in AC 0 (2) iﬀ it is represented by an open (or ΣB0 ) formula
in L.

306

IX. Theories for Small Classes

(b) Every ΣB1 (L) formula is equivalent in T to a ΣB1 (L2A ) formula.
(c) T proves ΣB0 (L)-COMP, ΣB0 (L)-IND, and ΣB0 (L)-MIN.

0 (2), which is in turn
(d) V 0 (2) is a universal conservative extension of V
a universal conservative extension of V 0 (2).
(e) A function is in FAC 0 (2) iﬀ it is ΣB1 -deﬁnable in V 0 (2) iﬀ it is ΣB1 deﬁnable in T .
(f) A relation is in AC 0 (2) iﬀ it is ΔB1 -deﬁnable in V 0 (2) iﬀ it is ΔB1 deﬁnable in T .
IX.4.3. The “onto” PHP and Parity Principle. The onto pigeonhole
principle, OPHP, states that there is no bijection between (a+1) “pigeons”
and a “holes”. Formally, OPHP is the ΣB0 formula
OPHP(a, X ) ≡ (∀x ≤ a∃!z < a X (x, z)) ⊃
(¬INJ(a, X ) ∨ ¬SUR(a, X ))
where
INJ(a, X ) ≡ ∀x ≤ a∀y ≤ a∀z < a((X (x, z) ∧ X (y, z)) ⊃ x = y),
SUR(a, X ) ≡ ∀z < a∃x ≤ aX (x, z).
We will also use OPHP to denote the family of propositional tautologies translated from OPHP(a, X ) (as described in Section VII.2). We
mentioned in Section VII.1.2 that this family does not have polynomial
size bPK proofs (as shown by Ajtai [5]). We state this result formally
below.
Theorem IX.4.6 (Ajtai). The family OPHP does not have polynomial
size bPK proofs.
Corollary IX.4.7. The theory V 0 does not prove the true ∀ΣB0 sentence
∀a∀X OPHP(a, X ).
On the other hand, it is relatively easy to show that OPHP is provable in
V 0 (2). In fact we will show that OPHP is implied by the Parity Principle
(also called the Modulo 2 Counting Principle) which asserts that a set of
odd cardinality cannot be partitioned into subsets of two elements each.
Formally, let

Count2 (a, X ) ≡ ¬∀x ≤ 2a∃!y ≤ 2a (x < y ∧ X (x, y)) ∨

(y < x ∧ X (y, x)) .
Here X (x, y) holds iﬀ {x, y} is a partition and x < y, and thus Count2 (a,
X ) states that X is not a partitioning of the set {0, 1, . . . , 2a}.
This principle is stronger than OPHP in the following sense:
Exercise IX.4.8. Show that V 0 proves
∀a∀X Count2 (a, X ) ⊃ ∀a∀X OPHP(a, X ).

(263)

IX.4. Theories for AC 0 (m) and ACC

307

Corollary IX.4.9. The Parity Principle does not have polynomial size
bPK proofs.
Proof Sketch. A prenex form of (263) is


∀a∀X ∃b∃Y Count2 (b, Y ) ⊃ OPHP(a, X ) .
By the above exercise and Theorem V.5.1 (witnessing for V 0 ) there are
FAC 0 functions f, F such that
V 0 (f, F )  Count2 (f(a, X ), F (a, X )) ⊃ OPHP(a, X ).
By the FAC 0 Elimination Lemma V.6.7 there is a ΣB0 formula Count2 (a, X )
such that
V 0 (f, F )  Count2 (f(a, X ), F (a, X )) ↔ Count2 (a, X ).
Since V 0 (f, F ) is a conservative extension of V 0 we conclude
V 0  Count2 (a, X ) ⊃ OPHP(a, X ).
The idea now is to apply the proof of the V 0 Translation Theorem VII.2.3
to the above theorem of V 0 and argue that there are polynomial size bPK
proofs of the translations of Count2 (a, X ) from substitution instances of
translations of Count2 (b, Y ). Thus if the Parity Principle has polynomial size bPK proofs then so does OPHP, contradicting Ajtai’s Theorem
IX.4.6.
2
*Exercise IX.4.10. Formulate and prove a generalization of the V 0
Translation Theorem VII.2.3 so that it applies to ΣB0 (LFAC 0 ) theorems of
0

V and justiﬁes the above proof of Corollary IX.4.9.
Another theorem of Ajtai [4] states a stronger result. Here an instance
of OPHP is a formula obtained from a member of the family OPHP by
substituting polynomial size constant depth formulas for the variables.
Theorem IX.4.11 (Ajtai). The family Count2 does not have polynomial
size bPK proofs even when instances of OPHP are allowed as axioms.
As a result, V 0 does not prove the reverse direction of the implication
in Exercise IX.4.8.
The next corollary follows from the above exercise and the previous
corollary.
Corollary IX.4.12. The theory V 0 does not prove the true ∀ΣB0 sentence
∀a∀X Count2 (a, X ).
By Exercise IX.4.8, to show that V 0 (2) proves OPHP it suﬃces to show
that V 0 (2) proves Count2 . This is left as an exercise.
Exercise IX.4.13. Show that
V 0 (2)  ∀a∀X Count2 (a, X ).
(Hint: Deﬁne the sets Y [0] , Y [1], . . . , Y [2a] such that Y [i] contains all and
only elements x such that either x ≤ i or x is coupled with some y ≤ i.)

308

IX. Theories for Small Classes

Corollary IX.4.14. The theory V 0 (2) is a proper extension of V 0 . In
fact, V 0 (2) is not ΣB0 -conservative over V 0 .
Proof. This is similar to Corollary IX.3.8. The ﬁrst sentence follows
from the second, which is true because (by Corollary IX.4.7) V 0 does not
prove ∀a∀X OPHP(a, X ), but (by Exercises IX.4.8 and IX.4.13) V 0 (2)
does. The ﬁrst sentence also follows directly from the fact that the function
Parity is deﬁnable in V 0 (2) but not in V 0 (because it is not in FAC 0 ). 2
IX.4.4. The Theory VAC 0 (2)V. The universal theory VAC 0 (2)V is deﬁned in the same way as VTC 0 V and VPV. Its vocabulary has symbols
for every function in FAC 0 (2). Their deﬁning axioms are based on the recursion theoretic characterization of FAC 0 (2) using the bounded number
recursion scheme 2-BNR scheme as shown in Theorem IX.4.15 below.
Here 2-BNR refers to the number recursion scheme in Deﬁnition
IX.3.10, where t = 2 (t is the bound on the function f deﬁned by the
recursion).
Theorem IX.4.15. FAC 0 (2) is equal to the closure of FAC 0 under AC 0
reductions and 2-BNR and also equal to the closure of FAC 0 under composition, string comprehension and 2-BNR.
Proof. By Theorem IX.1.7 it suﬃces to show that a function is in
FAC 0 (2) iﬀ it can be obtained from FAC 0 functions by ﬁnitely many
applications of AC 0 reduction and 2-BNR.
The ONLY IF direction follows easily from the fact that the function
mod 2 (x, Y ) (259) is obtained from the characteristic function fX ((237)
on page 288) by 2-BNR.
For the IF direction, we prove by induction on the number of the applications of 2-BNR. The base case (no application of 2-BNR) is obvious.
For the induction step, suppose that f(y, x, X ) is obtained from FAC 0 (2)
functions g, h by 2-BNR as in Deﬁnition IX.3.10:
f(0, x, X ) = g(x, X ),
f(y + 1, x, X ) = h(y, f(y, x, X ), x, X )
and for all y, x, X , f(y, x, X ) < 2.
For y ≥ 1, let (we drop mention of x, X )
z = max({0} ∪ {u < y : h(u, 0) = h(u, 1)}),
n = mod 2 (y, {u : z < u < y ∧ h(u, 0) = 0}),

g
if z = 0,
v=
h(z, 0) otherwise.
Then f(y) = 0 iﬀ either (i) v = 0 and n = 0, or (ii) v = 1 and n = 1. In
other words, f can be obtained from g, h and mod 2 by AC 0 reduction. 2
The next deﬁnition is analogous to Deﬁnition IX.3.13.

IX.4. Theories for AC 0 (m) and ACC

309

Deﬁnition IX.4.16. The vocabulary LVAC 0 (2)V is the smallest set that
includes LFAC 0 such that for every L2A -term t and open LVAC 0 (2)V -formula
ϕ the function Fϕ(z),t with deﬁning axiom (86) is in LVAC 0 (2)V , and for
every string function F in LVAC 0 (2)V there is a number function fF in
LVAC 0 (2)V with deﬁning axiom fF (x, X ) = |F (x, X )|, and for every two
number functions g(x, X ), h(y, z, x, X ) in LVAC 0 (2)V there is a number
function fg,h in LVAC 0 (2)V with deﬁning axioms (omitting x, X ):
(g < 2 ⊃ fg,h (0) = g) ∧ (g ≥ 2 ⊃ fg,h (0) = 0) ∧
(h(y, fg,h (y)) < 2 ⊃ fg,h (y + 1) = h(y, fg,h (y))) ∧
(h(y, fg,h (y) ≥ 2 ⊃ fg,h (y + 1) = 0). (264)
It follows from Theorem IX.4.15 that semantically the functions in
LVAC 0 (2)V represent precisely the functions in FAC 0 (2). We have:
Corollary IX.4.17. (a) A function is in FAC 0 (2) iﬀ it is represented
by a function in LVAC 0 (2)V .
(b) A relation is in AC 0 (2) iﬀ it is represented by an open formula in
LVAC 0 (2)V iﬀ it is represented by a ΣB0 (LVAC 0 (2)V ) formula.
Deﬁnition IX.4.18. The theory VAC 0 (2)V has vocabulary LVAC 0 (2)V
0

and is axiomatized by the axioms of V together with (86) for the functions
Fϕ(z),t and (240) for the functions fF and (264) for the functions fg,h .
Theorem IX.4.19. (a) The theory VAC 0 (2)V is a universal conservative extension of V 0 (2).
(b) For every ΣB0 (LVAC 0 (2)V ) formula ϕ + there is a ΣB1 (L2A ) formula ϕ that
is equivalent in VAC 0 (2)V to ϕ + .
Proof sketch. Part (a) of the following theorem can be proved by
formalizing the proof of Theorem IX.4.15 (see also Theorem IX.3.17).
Part (b) follows from Theorem IX.2.10 and Corollary IX.3.20 (see also
Corollary IX.3.21).
2
0
0
The characterization of AC (2) by VAC (2)V can be proved as in Section IX.3.4 (for the class TC 0 and the theory VTC 0 V).
Corollary IX.4.20. (a) A function is in FAC 0 (2) iﬀ it is ΣB1 -deﬁnable
in VAC 0 (2)V.
(b) A relation is in AC 0 (2) iﬀ it is ΔB1 -deﬁnable in VAC 0 (2)V.
IX.4.5. The Jordan Curve Theorem and Related Principles. The Jordan
Curve Theorem (JCT) asserts that any simple, closed curve divides the
plane into exactly two connected components. Here we consider the
setting where the curve lies on a grid graph and consists of only horizontal
or vertical edges. The notions of grid vertex and edge can be deﬁned
using the pairing function. To state the theorem, one way is to represent

310

IX. Theories for Small Classes

the curve as a sequence of edges that form a simple cycle. To show that
there are exactly two connected components we can show that (i) any path
(represented by a sequence of edges) that connect two points on diﬀerent
sides of the curve must intersect the curve, and (ii) any two points on the
same side of the curve can be connected by a path without intersecting
the curve.
Suppose that instead of representing the curve as a sequence of edges
we have a set of edges such that every grid vertex has degree either 0 or 2.
So there may be multiple simple closed curves, and we can only show that
there are at least two connected components. We will refer to this as the
set setting of JCT, as opposed to the above sequence setting.
Surprisingly the sequence setting is a theorem of V 0 [84], but the proof
of this is diﬃcult and will not be presented here. In this section we will
show that the set JCT is a theorem of V 0 (2).
We start by deﬁning the notions of grid vertex (or just vertex, or point)
and edge, and certain sets of edges which include closed curves, or connect
grid points. All of these notions are deﬁnable by ΣB0 -formulas, and their
basic properties can be proved in V 0 .
We assume a parameter n which bounds the x and y coordinates of
points on the curve in question. Thus a point p is a pair (x, y) which
is encoded by the pairing function x, y (see (69) on page 113), where
0 ≤ x, y ≤ n. The x and y coordinates of a point p are denoted by x(p)
and y(p) respectively. Thus if p = i, j then x(p) = i and y(p) = j. An
(undirected) edge is a pair (p1 , p2 ) (represented by p1 , p2 ) of adjacent
points; i.e. either |x(p2 ) − x(p1 )| = 1 and y(p2 ) = y(p1 ), or x(p2 ) =
x(p1 ) and |y(p2 ) − y(p2 )| = 1. For a horizontal edge e, we also write
y(e) for the (common) y-coordinate of its endpoints.
Let E be a set of edges (represented by a set of numbers representing
those edges). The E-degree of a point p is the number of edges in E that
are incident to p.
Deﬁnition IX.4.21. A curve is a nonempty set E of edges such that the
E-degree of every grid point is either 0 or 2. A set E of edges is said to
connect two points p1 and p2 if the E-degrees of p1 and p2 are both 1 and
the E-degrees of all other grid points are either 0 or 2. Two sets E1 and
E2 of edges are said to intersect if there is a grid point whose Ei -degree is
≥ 1 for i = 1, 2.
As noted before, a curve in the above sense is actually a collection of
one or more disjoint closed curves. Also if E connects p1 and p2 then
E consists of a path connecting p1 and p2 together with zero or more
disjoint closed curves.
We also need to deﬁne the notion of two points being on diﬀerent sides
of a curve. We are able to consider only points which are “close” to the
curve. It suﬃces to consider the case in which one point is above and one

IX.4. Theories for AC 0 (m) and ACC

311

point is below an horizontal edge in E. (Note that the case in which one
point is to the left and one point is to the right of a vertical edge in E can
be reduced to this case by rotating the (n + 1) × (n + 1) array of all grid
points by 90 degrees.)
Deﬁnition IX.4.22. Two points p1 , p2 are said to be on diﬀerent sides
of E if
(i) x(p1 ) = x(p2 ) ∧ |y(p1 ) − y(p2 )| = 2,
(ii) the E-degree of pi = 0 for i = 1, 2, and
(iii) the E-degree of p is 2, where p is the point with x(p) = x(p1 ) and
y(p) = 12 (y(p1 ) + y(p2 )). (See Figure 6.)

.
.
.

p2
E

p
p1

x=m
Figure 6. p1 , p2 are on diﬀerent sides of E.
Now we show that any set of edges that forms at least one simple curve
must divide the plane into at least two connected components.
Theorem IX.4.23. The theory V 0 (2) proves the following: Suppose that
B is a set of edges forming a curve, p1 and p2 are two points on diﬀerent
sides of B, and that R is a set of edges that connects p1 and p2 . Then B and
R intersect.


0 (2) is conservative over V 0 (2), it suﬃces to give a V
0 (2)
Proof. Since V
proof of the theorem. By Theorem IX.4.5 we can use ΣB0 (Parity)-COMP
and hence also ΣB0 (Parity)-IND and ΣB0 (Parity)-MIN (Theorem V.1.8).
In the following discussion we also refer to the edges in B as “undashed” edges, and the edges in R as “dashed” edges.

0 (2), and prove the theorem by contradiction. Suppose
We argue in V
to the contrary that B and R satisfy the hypotheses of the theorem, but
do not intersect.
Notation. A horizontal edge is said to be on column k (for k ≤ n − 1)
if its endpoints have x-coordinates k and k + 1.
Let m = x(p1 ) = x(p2 ). W.l.o.g., assume that 2 ≤ m ≤ n − 2. Also, we
may assume that the dashed path comes to both p1 and p2 from the left,
i.e., the two dashed edges that are incident to p1 and p2 are both horizontal
and on column m−1 (see Figure 7). (Note that if the dashed path does not
come to both points from the left, we could ﬁx this by eﬀectively doubling
the density of the points by doubling n to 2n, replacing each edge in B or

312

IX. Theories for Small Classes

R by a double edge, and then extending each end of the new path by three
(small) edges forming a “C” shape to end at points a distance 1 from the
un-dashed curve, approaching from the left.)

.
.

r2 p2
b1

r1 p1
m−1 m
Figure 7. The dashed path must cross the un-dashed curve.
We say that edge e1 lies below edge e2 if e1 and e2 are horizontal and
in the same column and y(e1 ) < y(e2 ). For each horizontal dashed edge
r we consider the parity of the number of horizontal un-dashed edges b
that lie below r. We say that an edge is “odd” if it is dashed and there
are an odd number of un-dashed edges below it. Recall that PARITY (X )
holds iﬀ X contains an odd number of elements:
PARITY (X ) ↔ Parity(|X |, X )(|X | −· 1).
Formally we have:
Notation. For each edge r let Zr denote the set of all horizontal undashed edges that lie below r. An edge r is said to be an odd edge if it is
dashed and horizontal and PARITY (Zr ).
For example, it is easy to show in V 0 (2) that exactly one of r1 , r2 in
Figure 7 is an odd edge.
For each k ≤ n − 1, deﬁne using ΣB0 (Parity)-COMP the set
Xk = {r : r is an odd edge in column k}.
Lemma IX.4.24. It is provable in V 0 (2) that
(a) PARITY (Xm−1 ) ↔ ¬PARITY (Xm ).
(b) For 0 ≤ k ≤ n − 2, k = m, PARITY (Xk ) ↔ PARITY (Xk+1 ).
Using this lemma the proof of the theorem is completed as follows. We
may assume that there are no edges in either B or R in columns 0 and
(n − 1), so ¬PARITY (X0 ) ∧ ¬PARITY (Xn−1 ). On the other hand, it follows by ΣB0 (LV
)-IND using Lemma IX.4.24 (b) that PARITY (X0 ) ↔
0 (2)

PARITY (Xm−1 ) and PARITY (Xm ) ↔ PARITY (Xn−1 ), which contradicts (a).
2
It remains to prove Lemma IX.4.24.

IX.4. Theories for AC 0 (m) and ACC

313

Proof of Lemma IX.4.24. First we prove (b). For k ≤ n − 1 and
0 ≤ j ≤ n, let ek,j be the horizontal edge on column k with y-coordinate
j. Fix k ≤ n − 2. Deﬁne the ordered lists (see Figure 8)
L0 = ek,0 , ek,1 , . . . , ek,n ;

Ln+1 = ek+1,0 , ek+1,1 , . . . , ek+1,n

and for 1 ≤ j ≤ n:
Lj = ek+1,0 , . . . , ek+1,j−1 , (k + 1, j − 1), (k + 1, j), ek,j , . . . , ek,n .
4
3
2
1
0

0

1

2

3

4

Figure 8. L2 (for n = 4, k = 1).
A dashed edge r ∈ Lj is said to be odd in Lj if there are an odd number
of un-dashed edges in Lj preceding r. Formally, for each dashed edge
r ∈ Lj let W be the set of un-dashed edges in Lj that precede r. Then r
is odd in Lj just in case PARITY (W ) is true. In particular, Xk and Xk+1
consist of odd edges in L0 and Ln+1 , respectively.
For 0 ≤ j ≤ n + 1, let
Yj = {r : r is an odd edge in Lj }.
Thus Y0 = Xk and Yn+1 = Xk+1 .
Claim. If k = m − 1 then PARITY (Yj ) ↔ PARITY (Yj+1 ) for j ≤ n.
This is because the symmetric diﬀerence of Yj and Yj+1 has either no
dashed edges, or two dashed edges with the same parity.
Thus by ΣB0 (LV
)-IND on j we have PARITY(Y0 ) ↔ PARITY (Yn+1 ),
0 (2)
and hence PARITY (Xk ) = PARITY (Xk+1 ).
The proof of (a) is similar. The only change here is that PARITY (Lj )
and PARITY (Lj+1 ) must diﬀer for exactly one value of j: either j =
y(p1 ) or j = y(p2 ) (because either r1 is odd in Ly(p1 ) or r2 is odd in Ly(p2 ) ,
but not both).
2
IX.4.6. The Theories for AC 0 (m) and ACC. Now we present theories
associated with AC 0 (m), for m ≥ 3. They are deﬁned in the same way as
B
2

0 (2) and V 0 (2). Let 
the theories V 0 (2), V
MODm (x, Y, Z) be the Σ0 (LA )

314

IX. Theories for Small Classes

equivalent (by Lemma V.6.7) of the following formula:
SEQ(x, Z) ∧ Z(0, 0) ∧ ∀z < x, (Y (z) ⊃
(Z)z+1 = ((Z)z + 1) mod m)) ∧ (¬Y (z) ⊃ (Z)z+1 = (Z)z ).
Thus MODm (x, Y, Z) states that Z = Mod m (x, Y ), the “counting modulo
m sequence” for Y (see (260) on page 304). Indeed, we take the following
as the deﬁning axiom for Mod m :


Mod m (x, Y ) = Z ↔ |Z| ≤ 1 + x, m ∧ MODm (x, Y, Z) .
Let
MODm ≡ ∃Z ≤ 1 + x, m MODm (x, Y, Z).
Deﬁnition IX.4.25. For each m ≥ 3, the theory V 0 (m) has vocabulary

L2A and is axiomatized by V 0 and the axiom MODm .

The next exercise can be proved in the same way as Lemma IX.3.3.
Exercise IX.4.26. For each m ≥ 3 the function Mod m is ΣB1 -deﬁnable
in V 0 (m), and V 0 (m)(Row, Mod m , Mod m ) proves
∀i < b, Mod m (b, X, Y )[i] = Mod m ((X )i , Y [i] ).

0 (m). To deﬁne V
0 (m) we use the string
Now we deﬁne V 0 (m) and V

function Mod m (x, Y ) deﬁned by



Mod m (x, Y ) = Z ↔ |Z| ≤ 1 + x, m ∧ MOD
(x, Y, Z)
(265)
m

(x, Y, Z) is the quantiﬁer-free LFAC 0 -formula that is equivawhere MOD
m
0

lent to MODm (x, Y, Z) over V (see Lemma V.6.3).

0 (m)). For each m ≥ 3, the theory V
0 (m) has
Deﬁnition IX.4.27 (V
0

vocabulary LV
= LFAC 0 ∪ {Mod m } and axioms that of V and (265).
0 (m)
For V 0 (m) we start with the function mod m which is equal to mod m (see
(259) on page 304) but has the following quantiﬁer-free deﬁning axioms
(we identify the natural number m with the corresponding numeral m):
mod m (0, Y ) = 0,

(266)

(Y (x) ∧ mod m (x, Y ) + 1 < m) ⊃ mod m (x + 1, Y ) = mod m (x, Y ) + 1,
(267)
(Y (x) ∧ mod m (x, Y ) + 1 = m) ⊃ mod m (x + 1, Y ) = 0,
¬Y (x) ⊃ mod m (x + 1, Y ) = mod m (x, X ).

(268)
(269)

Deﬁnition IX.4.28. For each m ≥ 2, LFAC 0 (m) is the smallest set
that contains LFAC 0 ∪ {mod m } such that for each quantiﬁer-free formula

IX.4. Theories for AC 0 (m) and ACC

315

ϕ(z, x, X ) of LFAC 0 (m) and term t(x, X ) of L2A , there is a string function
Fϕ(z),t with deﬁning axiom (86):
Fϕ(z),t (x, X )(z) ↔ z < t(x, X ) ∧ ϕ(z, x, X ).
The theory V 0 (m) has vocabulary LFAC 0 (m) and is axiomatized by the
0

axioms of V , (266), (267), (268) and (269) for mod m , and (86) for each
function Fϕ(z),t .
The following Deﬁnability Theorem follows from the results in Section IX.2:
0 (m), or L is
and T is V
Corollary IX.4.29. Here either L is LV
0 (m)
LFAC 0 (m) and T is V 0 (m).
(and
(a) A function is in FAC 0 (m) iﬀ it is represented by a term in LV
0 (m)

for string function) iﬀ it is represented by a symbol in LFAC 0 (m) . A
relation is in AC 0 (m) iﬀ it is represented by an open (or a ΣB0 ) formula
of L.
(b) Every ΣB1 (L) formula is equivalent in T to a ΣB1 (L2A ) formula.
(c) T proves ΣB0 (L)-COMP, ΣB0 (L)-IND, and ΣB0 (L)-MIN.
0 (m), which is in turn
(d) V 0 (m) is a universal conservative extension of V
a universal conservative extension of V 0 (m).
(e) A function is in FAC 0 (m) iﬀ it is ΣB1 -deﬁnable in V 0 (m) iﬀ it is ΣB1 deﬁnable in T .
(f) A relation is in FAC 0 (m) iﬀ it is ΔB1 -deﬁnable in V 0 (m) iﬀ it is ΔB1 deﬁnable in T .
Corollary IX.4.30. Let p, q be two distinct prime numbers. Then
V 0  V 0 (p) ⊆ V 0 (q).
Proof. Both facts follow from Corollary IX.4.29 (f) and the results of
Razborov and Smolensky mentioned in Section IX.4.1 (that
2
MODULOm ∈ AC 0 (p) if p is a prime number not divisible by m).
Theories for ACC are as follows:

Deﬁnition IX.4.31. VACC = m≥2 V 0 (m),


LFAC 0 (2) ,
VACC =
V 0 (m),
LFACC =
m≥2

LVACC
 =



m≥2

LV
,
0 (m)

 =
VACC

m≥2



0 (m).
V

m≥2

The next Deﬁnability Theorems for the theories associated with ACC
follow from Corollary IX.4.29.
 or L is
Corollary IX.4.32. Here either L is L  and T is VACC,

LFACC and T is VACC.

VACC

316

IX. Theories for Small Classes

(a) A function is in FACC iﬀ it is represented by a term in LVACC
 (and for
string function) iﬀ it is represented by a symbol in LFACC . A relation
is in ACC iﬀ it is represented by an open (or a ΣB0 ) formula of L.
(b) Every ΣB1 (L) formula is equivalent in T to a ΣB1 (L2A ) formula.
(c) T proves ΣB0 (L)-COMP, ΣB0 (L)-IND, and ΣB0 (L)-MIN.
 which in turn is
(d) VACC is a universal conservative extension of VACC,
a universal conservative extension of VACC.
(e) A function is in FACC iﬀ it is ΣB1 -deﬁnable in VACC iﬀ it is ΣB1 deﬁnable in T .
(f) A relation is in FACC iﬀ it is ΔB1 -deﬁnable in VACC iﬀ it is ΔB1 deﬁnable in T .
Exercise IX.4.33. Show that for all integers m, n ≥ 2, if m|n then
AC 0 (m) ⊆ AC 0 (n) and V 0 (m) ⊆ V 0 (n).
The next result is analogous to Corollary VIII.7.21 (relating the ﬁnite
axiomatizability of V ∞ to the provable collapse of PH), but the proof is
much easier.
Theorem IX.4.34. VACC is ﬁnitely axiomatizable iﬀ for some m ≥ 2,
V 0 (m) proves AC 0 (m) = ACC.
Proof. Since each theory AC 0 (m) is ﬁnitely axiomatizable, it follows
from Exercise IX.4.33 and compactness that VACC is ﬁnitely axiomatizable iﬀ VACC = V 0 (m) for some m ≥ 2. If VACC = V 0 (m) then
VACC and V 0 (m) have the same ΣB1 -theorems, so by Corollaries IX.4.29
and IX.4.32 every relation in ACC is ΔB1 -deﬁnable in VACC and hence also
in V 0 (m) by the same formulas. Thus every relation in ACC is provably
in AC 0 (m).
Conversely if V 0 (m) proves AC 0 (m) = ACC then V 0 (m) proves the
axiom MODn for every n ≥ 2, so V 0 (n) ⊆ V 0 (m), so VACC = V 0 (m).
To justify the conclusion V 0 (m) proves MODn we could argue as follows.
If V 0 (m) proves AC 0 (m) = ACC, then by Corollary IX.4.29(f) it follows that AC 0 (m) ΔB1 -deﬁnes MODULOn , so by the witnessing theorem,
V 0 (m) ΣB1 -deﬁnes the characteristic function of MODULOn , which in
turn can be used to prove MODn by Corollary IX.4.29.
2
Exercise IX.4.35. VACC ⊆ VTC 0 , and V 0 (p)  VACC for any prime
p.
IX.4.7. The Modulo m Counting Principles. Recall the Parity Principle
(or also Modulo 2 Counting Principle) from Section IX.4.3. Generally, for m ∈ N, m ≥ 2, the Modulo m Counting Principle, denoted by
Countm , states that a set of cardinality which is (1 mod m) cannot be
partitioned into disjoint subsets of exactly m elements each. The formula
Countm (a, X ) below expresses the fact that the m-dimensional array X
does not encode a partition of the set {0, 1, . . . , ma} into m-element subsets. Here the encoding of the partition is such that X (x1 , x2 , . . . , xm )

IX.4. Theories for AC 0 (m) and ACC

317

holds iﬀ {x1 , x2 , . . . , xm } is a subset in the partition and x1 < x2 < · · · <
xm .
Countm (a, X ) ≡ ¬∀x ≤ ma∃!ym−1 ≤ ma∃!ym−2 < ym−1 . . . ∃!y1 < y2
m−2


(yt < x ∧ x < yt+1 ∧ X (y1 , . . . , yt , x, yt+1 , . . . , ym−1 )) ∨

t=1

 


x < y1 ∧ X (x, y1 , . . . , ym−1 ) ∨ ym−1 < x ∧ X (y1 , . . . , ym−1 , x) .
We will also write Countm for the family of tautologies
{Countm (a, X )[n, n, n, . . . , n + 1] : n ≥ 1}.
Recall the onto Pigeonhole Principle OPHP from Section IX.4.3. The
following exercise generalizes Exercise IX.4.8.
Exercise IX.4.36. Let m ∈ N, m ≥ 2. Show that V 0 proves
∀a∀X Countm (a, X ) ⊃ ∀a∀X OPHP(a, X ).
Ajtai’s Theorem IX.4.11 holds for Countm in general and shows that
V 0 does not prove the reverse implication. (See the summary in Theorem IX.4.39 and Corollary IX.4.40 below.)
Another theorem of Ajtai [6] is that the family Countp does not have
polynomial size bPK proofs even when instances of Countq1 , Countq2 , . . . ,
Countqk are used as axioms, for distinct prime numbers p, q1 , q2 . . . , qk . It
follows that the ∀ΣB0 sentence ∀a∀X Countp (a, X ) is not provable from V 0
and the sentences
{∀a∀X Countqt (a, X ) : 1 ≤ t ≤ k}.
On the other hand, it can be shown that Countm is provable in V 0 (m).
(This generalizes Exercise IX.4.13.) The proofs of this and some other
facts are left as an exercise.
Exercise IX.4.37. Let m ∈ N, m ≥ 2. Show that
V 0 (m)  ∀a∀X Countm (a, X ).
Exercise IX.4.38.
V 0 proves

(a) Show that if m, m  ∈ N, m ≥ 2 and m|m  , then

∀a∀X Countm (a, X ) ⊃ ∀a∀X Countm (a, X ).
(b) Let m, m  ∈ N and m, m have a common divisor p > 1. Show that
V 0 (m)  Countm (a, X ).
Now we summarize some of Ajtai’s Theorems and their corollaries.
Theorem IX.4.39 (Ajtai [5, 4, 6]). (a) For m ≥ 2, the family Countm
does not have polynomial size bPK proof even when instances of OPHP
are used as axioms.

318

IX. Theories for Small Classes

(b) For distinct prime numbers p, q1 , q2 , . . . , qk , the family Countp does
not have polynomial size bPK proof even when instances of {Countqt :
1 ≤ t ≤ k} are used as axioms.
As a result, we have the following independence results:
Corollary IX.4.40. (a) For m ≥ 2, the theory V 0 does not prove
∀a∀X OPHP(a, X ) ⊃ ∀a∀X Countm (a, X ).
(b) Let p, q1 , q2 , . . . , qk be distinct prime numbers. The theory V 0 does
not prove the following implication:
 k


∀a∀X Countqt (a, X ) ⊃ ∀a∀X Countp (a, X ).

t=1

The next corollary is proved in the same way as Corollary IX.4.14.
Corollary IX.4.41. For m ≥ 2, the theory V 0 (m) is a proper extension
of V 0 . In fact, V 0 (m) is not ΣB0 -conservative over V 0 .
See Section IX.7.4 for an open problem regarding V 0 (m) and the counting principles.
IX.4.8. The Theory VAC 0 (6)V. Here we develop VAC 0 (6)V in the
same way as VAC 0 (2)V, using Theorem IX.4.42 below. Recall the bounded number recursion (BNR) from Section IX.3.3. The following result
if from [82].
Theorem IX.4.42. A function is in FAC 0 (6) iﬀ it is obtained from FAC 0
by ﬁnitely many applications of AC 0 reduction and 3-BNR iﬀ it is obtained
from FAC 0 by ﬁnitely many applications of AC 0 reduction and 4-BNR.
Thus, the functions in LVAC 0 (6)V deﬁned below represent precisely the
functions in FAC 0 (6).
Deﬁnition IX.4.43. The vocabulary LVAC 0 (6)V is the smallest set that
includes LFAC 0 such that for every L2A -term t and open LVAC 0 (6)V -formula
ϕ the function Fϕ(z),t with deﬁning axiom (86) (page 125) is in LVAC 0 (6)V ,
and for every string function F in LVAC 0 (6)V there is a number function
fF in LVAC 0 (6)V with deﬁning axiom fF (x, X ) = |F (x, X )|, and for every
two number functions g(x, X ), h(y, z, x, X ) ∈ LVAC 0 (6)V there is a number
function fg,h in LVAC 0 (6)V with deﬁning axiom (omitting x, X ):
(g < 3 ⊃ fg,h (0) = g) ∧ (g ≥ 3 ⊃ fg,h (0) = 0) ∧
(h(y, fg,h (y)) < 3 ⊃ fg,h (y + 1) = h(y, fg,h (y))) ∧
(h(y, fg,h (y) ≥ 3 ⊃ fg,h (y + 1) = 0). (270)
The next corollary follows from Theorem IX.4.42. It states that semantically the functions in LVAC 0 (6)V represent precisely the functions
in FAC 0 (6).

IX.5. Theories for NC 1 and the NC Hierarchy

319

Corollary IX.4.44. (a) A function is in FAC 0 (6) iﬀ it is represented
by an LVAC 0 (6)V -term.
(b) A relation is in AC 0 (6) iﬀ it is represented by an open formula in
LVAC 0 (6)V iﬀ it is represented by a ΣB0 (LVAC 0 (6)V ) formula.
Deﬁnition IX.4.45. The theory VAC 0 (6)V has vocabulary LVAC 0 (6)V
0

and is axiomatized by the axioms of V together with (86) for the functions
Fϕ(z),t and (240) for the functions fF and (270) for the functions fg,h .
Theorem IX.4.46. (a) The theory VAC 0 (6)V is a universal conservative extension of V 0 (6).
(b) Every ΣB0 (LVAC 0 (6)V ) formula ϕ + is equivalent in VAC 0 (6)V to a ΣB1
formula ϕ.
Proof sketch. Part (a) is proved by formalizing both directions of the
proof of Theorem IX.4.42 in appropriate theories (V 0 (6) or VAC 0 (6)V).
Part (b) is proved in the same way as Corollary IX.3.21.
2
0
0
The characterization of AC (6) by VAC (6)V can be proved as in Section IX.3.4 (for the class TC 0 and the theory VTC 0 V).
Corollary IX.4.47. (a) A function is in FAC 0 (6) iﬀ it is ΣB1 -deﬁnable
in VAC 0 (6)V.
(b) A relation is in AC 0 (6) iﬀ it is ΔB1 -deﬁnable in VAC 0 (6)V.

IX.5. Theories for NC 1 and the NC Hierarchy
The classes NC k and AC k form a hierarchy inside P as follows:
AC 0  NC 1 ⊆ AC 1 ⊆ NC 2 ⊆ · · · .
We have already developed the theory V 0 for AC 0 . Here we develop
theories for the other classes in the hierarchy, with a focus on NC 1 .
The class NC 1 plays an important role in propositional logic because
the NC 1 relations can be characterized as those that can be expressed
by a uniform polynomial size family of propositional formulas. The ΣB0
theorems of the theory VNC 1 translate into families of tautologies with
polynomial size PK proofs (Section X.3).
In Section IX.5.1 we deﬁne the classes and characterize them in terms
of alternating Turing machines. In Section IX.5.2 we deﬁne the Boolean
Sentence Value Problem, which is complete for NC 1 . In Section IX.5.3 we
1 and VNC 1 that characterize NC 1 foldevelop the theories VNC 1 , VNC
lowing the method presented in Section IX.2. In Section IX.5.4 we show
that VNC 1 extends VTC 0 . In Section IX.5.5 we use the bounded number recursion (BNR) operation (see Section IX.3.3) to develop VNC 1 V,
and use the fact that this theory can formalize the proof of Barrington’s

320

IX. Theories for Small Classes

Theorem to prove that it is a universal conservative extension of VNC 1 .
Finally, the theories for other classes in the NC hierarchy are deﬁned in
Section IX.5.6.
In Section X.3.1 we will prove the Propositional Translation Theorem
for VNC 1 .
IX.5.1. Deﬁnitions of the Classes. (See also Appendix A.5.) Recall the
deﬁnition of AC 0 using uniform families of circuits in Section IV.1. In
general for k ≥ 0, uniform AC k (or just AC k ) is the class of problems
decidable using a uniform family Cn  of polynomial size Boolean circuits,
where each circuit Cn has n input bits and O((log n)k ) depth, and the gates
in Cn have unbounded fan-in. The class uniform NC k (or simply NC k ) is
deﬁned in the same way, except the gates have fan-in two.
It is easy to see that for k ≥ 0:
AC k ⊆ NC k+1 ⊆ AC k+1 .
Furthermore AC 0  NC 1 because PARITY (X ) is in NC 1 but not in AC 0 .
These classes form the NC hierarchy:


NC k =
AC k ⊆ P.
NC =
k>0

k≥0

Ruzzo [100] discusses at length alternative notions of uniformity that can
be used to deﬁne these classes. For k ≥ 1 the classes AC k and NC k+1
remain the same under a wide choice of uniformity conditions, from AC 0
to log space. However NC 1 appears to be more sensitive to the notion of
uniformity used. The standard deﬁnition is quite strong, and requires that
the extended connection language (ECL) be recognizable in time O(log n)
(where n is the number of input bits for the circuit). Here ECL speciﬁes
for each gate g and each string p ∈ {L, R}∗ of length log n the gate
that is reached by following the path speciﬁed by p starting from g and
proceeding to the left input for L and the right input for R.
Fortunately under the standard notions of uniformity these classes are
robust in the sense that they can be characterized using a diﬀerent model
of computation, namely alternating Turing machines (ATMs) (see Appendix A.4). Let ASpace-Alt(s, r) denote the class of languages accepted
by ATMs in space s with r alternations. Then for k ≥ 1 [40, 110]
AC k = ASpace-Alt(O(log n), O((log n)k )).

(271)

(Recall Theorem IV.1.2 states that AC 0 consists of languages accepted by
ATMs working in time O(log n) and constant alternations.)
Similarly, let ASpace-Time(s, t) denote the class of languages accepted
by ATMs in simultaneous space s and time t. Then for k ≥ 1 [100]
NC k = ASpace-Time(O(log n), O((log n)k ))

(272)

IX.5. Theories for NC 1 and the NC Hierarchy

321

and in particular
NC 1 = ATime(O(log n)).

(273)

For this reason NC 1 is also called ALogTime in the literature.
Here we take the above three equations as deﬁnitions of the classes AC k
and NC k .
IX.5.2. BSVP and NC 1 . The Boolean Sentence Value Problem (BSVP)
is to decide the truth value of a Boolean sentence given its inﬁx representation. In Section X.3.2 we will show that that BSVP is AC 0 -many-one
complete for NC 1 . In fact, the problem remains AC 0 -many-one complete
for NC 1 even for monotone formulas that have a “balanced” structure
when viewed as a binary tree. We use this fact here to deﬁne the function
Fval (Fval stands for “formula value”) whose AC 0 closure is NC 1 .
Consider the following encoding of a balanced monotone Boolean sentence using the heap data structure. We view the sentence as a balanced
binary tree with (2a − 1) nodes, including a leaves numbered
a, (a + 1), . . . , (2a − 1)
and (a − 1) inner nodes numbered
1, 2, . . . , (a − 1).
Each inner node (or gate) is either an ∧-gate or an ∨-gate, and each leaf
is labeled with a Boolean value. The two children (inputs) of an inner
node x are 2x and (2x + 1) (as in the heap data structure). Therefore
the sentence can be encoded by (a, G, I ), where G(x) speciﬁes the label of
node x: for 1 ≤ x < a,
if G(x) holds then node x is an ∧-gate, otherwise x is an ∨-gate,
and I speciﬁes the values at the leaves: for x < a,
I (x) is the value labeling leaf (a + x).
We will also refer to the binary tree (a, G) as a tree-like circuit and refer
to I as its inputs.
The function Fval(a, G, I ) gives the value of the sentence encoded by
(a, G, I ) as well as the values of all nodes in the associated tree. The
function is computed by a polytime procedure which evaluates these nodes
inductively, starting with the leaves. In the formula MFV (a, G, I, Y ) below
Y (0) always holds, and Y (x) is the value of gate x for 0 < x < 2a. (MFV
stands for “monotone formula value”.)

MFV (a, G, I, Y ) ≡ ∀x < a (Y (x + a) ↔ I (x)) ∧ Y (0) ∧

0 < x ⊃ Y (x) ↔ ((G(x) ∧ Y (2x) ∧ Y (2x + 1)) ∨

(¬G(x) ∧ (Y (2x) ∨ Y (2x + 1)))) . (274)
Figure 9 depicts a computation of (the bits of) Y for a = 6. Here
Y (1), . . . , Y (5) are the values of gates G(1), . . . , G(5).

322

IX. Theories for Small Classes
Y (1)

Y (2)

Y (3)

Y (4)

Y (5)

Y (8)

Y (9)

Y (10)

Y (11)

I (2)

I (3)

I (4)

I (5)

Y (6)

Y (7)

I (0)

I (1)

Figure 9. Computing Y which satisﬁes MFV (a, G, I, Y )
for a = 6.
Deﬁnition IX.5.1.
RMFV (a, G, I ) ↔ ∃Y ≤ 2a(MFV (a, G, I, Y ) ∧ Y (1)).
The following proposition shows that RMFV is AC 0 -many-one complete
for NC 1 . For a proof see [22] and [10, Lemma 6.2,page 287].
Proposition IX.5.2. A Relation R(x, X ) is in NC 1 iﬀ there are AC 0
functions a0 , G0 , I0 such that
R(x, X ) ↔ RMFV (a0 (x, X ), G0 (x, X ), I0 (x, X )).
Theorem IX.5.3. NC 1 is the AC 0 closure of RMFV .
Proof. It follows from Proposition IX.5.2 that NC 1 is included in the
AC 0 closure of RMFV . Thus it suﬃces to show that NC 1 is closed under
AC 0 reductions, and for this it suﬃces to show that FNC 1 is closed under
AC 0 reductions. By (273) and Theorem IX.1.7 our task is to show that
the class of functions computed by alternating Turing machines (ATMs)
in time O(log n) is closed under composition and string comprehension.
We use the restricted form of log time ATMs given in Section 6 of [10].
In particular only one input bit is queried on any one computation path,
and that query occurs at the end of that path. Further, although inputs
of number sort are presented in unary, an ATM can easily write on its
work tape the binary notation of a unary input x in time O(log x) and
constant alternations, simply by guessing that notation and verifying it
with a couple of queries using its index tape.
For composition, for notational simplicity consider the case
F (x, X ) = G(x, X , H (x, X ))

IX.5. Theories for NC 1 and the NC Hierarchy

323

where G and H are computed by ATMs in time O(log n). The machine
M computing F actually computes the bit graph F (x, X )(i) of F . On
input (x, X , i) M simulates the machine computing the ith bit of G.
Whenever a computation path of that machine ends with an input query
for a bit j of H (x, X ), M simply simulates the machine computing H on
input (x, X , j).
For string comprehension, suppose
F (y) = {f(x) : x ≤ y}
(where F and f may contain other arguments) and suppose f is computed
by an ATM in time O(log n). Then to compute F (y)(i) (where as above
we may assume binary notation for y and i) a machine M guesses x,
veriﬁes x ≤ y, then for each bit number j (using universal states) M
computes bit j of f(x) and veriﬁes that it is the same as bit j of i.
2
1
1 1
IX.5.3. The Theories VNC , VNC , and VNC . We deﬁne the theories

1 and VNC as in Section IX.2 using the formula 
VNC 1 , VNC
MFV above.
In Section IX.5.5 we will deﬁne VNC 1 V, another universal conservative
extension of VNC 1 using number recursion.
1

Deﬁnition IX.5.4 (VNC 1 ). Let
MFV ≡ ∃Y ≤ 2a + 1 MFV (a, G, I, Y ).

(275)

The theory VNC has vocabulary L2A and is axiomatized by MFV and the
axioms of V 0 .
1

Deﬁnition IX.5.5. The function Fval(a, G, I ) is deﬁned as follows:
Fval(a, G, I ) = Y ↔ |Y | ≤ 2a ∧ MFV (a, G, I, Y ).

(276)

Note that Fval is ΣB1 -deﬁnable in VNC 1 .
The next result is an immediate consequence of Theorem IX.5.3 and
Lemma IX.1.5.
Corollary IX.5.6. FNC 1 is the closure of Fval under AC 0 reducibility.
Details of the proof of the next result are easier to carry out after later
technical developments (see Exercise IX.5.15). Here we outline the proof.
Lemma IX.5.7. The aggregate Fval of Fval is ΣB1 -deﬁnable in VNC 1 ,
and VNC 1 (Fval, Fval  ) proves
∀i < b, Fval  (b, A, G, I )[i] = Fval((A)i , G [i] , I [i] ).
Proof sketch. This is an exercise in circuit design similar to the proof
of Lemma VIII.1.10, which shows a similar result for the theory VP. Since
the set of ΣB1 -deﬁnable functions in any theory extending V 0 is closed under
composition it suﬃces to ﬁnd suitable FAC 0 functions EXT, a0 , G0 , I0 such
that
Fval (b, A, G, I ) = EXT(Fval(a0 (∗), G0 (∗), I0 (∗)), ∗)

324

IX. Theories for Small Classes

where ∗ stands for b, A, G, I . Thus the tree circuit C described by
(a0 , G0 , I0 ) has, for each i < b, a subtree Ci which computes Fval((A)i ,
G [i] , I [i] ). We ﬁx things so that each subtree Ci is a padded version of the
circuit described by ((A)i , G [i] , I [i] ) that it is simulating, so that all circuits
Ci have the same size, and the number of leaves of each is a power of 2.
This makes it easy to deﬁne the function EXT so that EXT(Y, ∗)[i] extracts
the gate values of Ci when Y is the string of gate values for C .
2
1 we use the following quantiﬁer-free deﬁning axiom for
To deﬁne VNC
Fval, where x occurs as a free variable. It is easy to see that this deﬁning
axiom is equivalent to (276).

Fval(a, G, I ) = Y ⊃ (|Y | ≤ 2a) ∧ Y (0) ∧ x < a ⊃ (Y (x + a) ↔



I (x)) ∧ (0 < x ∧ x < a) ⊃ Y (x) ↔ (G(x) ∧ Y (2x) ∧

Y (2x + 1)) ∨ (¬G(x) ∧ (Y (2x) ∨ Y (2x + 1))) . (277)
1 is the universal theory over the vocabulary
Deﬁnition IX.5.8. VNC
0
LVNC
1 = LFAC 0 ∪ {Fval} with axioms those of V and the deﬁning axiom
(277) for Fval.
Deﬁnition IX.5.9. LFNC 1 is the smallest set that contains LVNC
1 such
2
that for every LA -term t and every quantiﬁer-free LFNC 1 -formula ϕ there
is a function Fϕ(z),t in LFNC 1 with deﬁning axiom (86) (page 125).
1

VNC is the universal theory over LFNC 1 that is axiomatized by the
1 and (86) for each function F
axioms of VNC
of L
1.
ϕ(z),t

FNC

The next theorem follows from results in Section IX.2 concerning the
 and VC.
general treatment of the theories VC, VC,
1 , or L
and T is VNC
Theorem IX.5.10. Assume that either L is L
1

1
VNC

is LFNC 1 and T is VNC .
(a) A function is in FNC 1 iﬀ it is represented by a term in LVNC
1 (and
for a string function) iﬀ it is represented by a function in LFNC 1 . A
relation is in NC 1 iﬀ it is represented by an open (or ΣB0 ) formula of
L.
(b) Every ΣB1 (L) formula is equivalent in T to a ΣB1 (L2A ) formula.
(c) T proves ΣB0 (L)-COMP, ΣB0 (L)-IND, and ΣB0 (L)-MIN.
1
1 , which is in turn
(d) VNC is a universal conservative extension of VNC
a universal conservative extension of VNC 1 .
(e) A function is in FNC 1 iﬀ it is ΣB1 -deﬁnable in VNC 1 iﬀ it is ΣB1 deﬁnable in T .
(f) A relation is in NC 1 iﬀ it is ΔB1 -deﬁnable in VNC 1 iﬀ it is ΔB1 -deﬁnable
in T .

IX.5. Theories for NC 1 and the NC Hierarchy

325

The original deﬁnition of VNC 1 [45] uses the axiom scheme ΣB0 -TreeRec
instead of the axiom MFV.
Deﬁnition IX.5.11 (ΣB0 -TreeRec). ΣB0 -TreeRec is the set of axioms of
the form
∃Y ∀x < a(Y (x + a) ↔ (x)) ∧


0 < x ⊃ (Y (x) ↔ ϕ(x)[Y (2x), Y (2x + 1)]) (278)
where (x) is a ΣB0 formula, ϕ(x)[p, q] is a ΣB0 formula which contains
two Boolean variables p and q, and Y does not occur in and ϕ.
We will show that our deﬁnition of VNC 1 here is equivalent to the
original deﬁnition. Since MFV is an instance of the ΣB0 -TreeRec axiom
scheme, we need only to show that ΣB0 -TreeRec is provable in VNC 1 .
This is proved in Theorem IX.5.12 below. In Section IX.5.4 below we
will show that VNC 1 proves several generalizations of ΣB0 -TreeRec (Theorems IX.5.13 and IX.5.14).
Theorem IX.5.12. The ΣB0 -TreeRec axiom scheme is provable in VNC 1 .
Proof. Given a, and ϕ, the idea is to construct a (large) treelike
circuit (b, G) and inputs I so that from Fval(b, G, I ) we can extract Y
(using ΣB0 -COMP) that satisﬁes (278).
Notice the “gates” ϕ(x)[p, q] in (278) can be any of the sixteen Boolean
functions in two variables p, q. We will (uniformly) construct binary
treelike ∧-∨ circuits of constant depth that compute ϕ(x)[p, q].
Let
1 , . . . , 8 , 9 ≡ ¬ 1 , . . . , 16 ≡ ¬ 8
be the sixteen Boolean functions in two variables p, q. Each i can be
computed by a binary treelike and-or circuit of depth 2 with inputs among
0, 1, p, q, ¬p, ¬q. For 1 ≤ i ≤ 16, let Xi be deﬁned by


Xi (x) ↔ x < a ∧ (ϕ(x)[p, q] ↔ i (p, q)) .
Then,
ϕ(x)[p, q] ↔

16


(Xi (x) ∧

i (p, q)).

i=1

Consequently, ϕ(x)[p, q] can be computed by a binary and-or tree Tx of
depth 7 whose inputs are 0, 1, p, ¬p, q, ¬q, Xi (x). Similarly, ¬ϕ(x)[p, q]
is computed by a binary and-or tree Tx having the same depth and set
of inputs. Our large tree G has one copy of T1 , and in general for each


copy of Tx or Tx , there are multiple copies of T2x , T2x+1 , T2x
, T2x+1
that
supply the inputs Y (2x), Y (2x + 1), ¬Y (2x), ¬Y (2x + 1), and other
trivial treelike circuits that provide inputs 0, 1, Xi (x) (1 ≤ i ≤ 16).
Finally, I is deﬁned as follows: I (x) ↔ (x < a ∧ (x)).
2

326

IX. Theories for Small Classes

IX.5.4. VTC 0 ⊆ VNC 1 . It is known that TC 0 ⊆ NC 1 (although it is
unknown whether the inclusion is proper). Here we will show, informally,
that VNC 1 proves this inclusion. In particular, we will show that VNC 1
extends VTC 0 . Note that for this it suﬃces to show that VNC 1 proves
the axiom NUMONES. Our proof is by formalizing in VNC 1 the construction of NC 1 circuits that compute numones and prove in VNC 1 the
correctness of this construction. Here we formalize the construction by
Buss [22].
The next two theorems show that VNC 1 proves some generalizations
of ΣB0 -TreeRec. They are useful in formalizing the construction of the
counting circuits. They are also useful in proving that the function Fval 
is ΣB1 -deﬁnable in VNC 1 (see Exercise IX.5.15), a result that we need for
Theorem IX.5.10 stated earlier.
First, Theorem IX.5.13 asserts, informally, that we can evaluate in
VNC 1 formulas whose underlying trees have an arbitrary constant branching factor (as opposed to binary trees).
Theorem IX.5.13. Suppose that 2 ≤ k ∈ N, (x) is a ΣB0 formula, and
ϕ(x)[p0 , . . . , pk−1 ] is a ΣB0 formula that contains also Boolean variables pi .
Then VNC 1 proves
∃Y, ∀x < ka, a ≤ x ⊃ (Y (x) ↔

(x)) ∧

∀x < a, Y (x) ↔ ϕ(x)[Y (kx), . . . , Y (kx + k − 1)]. (279)
Proof. We prove for the case k = 4; similar arguments work for other
cases.
Using Theorem IX.5.12 we will deﬁne a  ,  , ϕ  so that from Y  that
satisﬁes the ΣB0 -TreeRec axiom (278) for a  ,  and ϕ  we can obtain Y
that satisﬁes (279) above.
Intuitively, consider Y in (279) as a forest of three trees whose nodes
are labeled with Y (x), x < |Y |. Then Y has branching factor of 4 (since
k = 4), and the three trees are rooted at Y (1), Y (2) and Y (3). (See
Figure 10.) Note also that each layer in Y corresponds to two layers in
the binary tree Y  .
We will deﬁne an injective map f so that Y (x) ↔ Y  (f(x)). Since the
trees rooted at Y (1), Y (2) and Y (3) are disjoint, f is deﬁned so that these
trees are the images of disjoint subtrees in the tree Y  . For example, we
can choose the subtrees rooted at Y  (4), Y  (5) and Y  (6). Thus,
f(1) = 4, f(2) = 5, f(3) = 6.
In general, consider the function f deﬁned by:
f(4m + y) = 4m+1 + y

for 0 ≤ y < 3 · 4m .

(By the results in Chapter III, f is provably total in IΔ0 , and hence also
in V 0 .)

IX.5. Theories for NC 1 and the NC Hierarchy
Y (1)

Y (4)

...

Y (2)

Y (7)

Y (8)

...

327

Y (3)

Y (12) . . .

Y (11)

Y (15)

Y  (1)
Y  (2)
Y  (4)

Y  (3)
Y  (5)

Y  (6)

Y  (7)

Figure 10. The forest Y in Theorem IX.5.13 when k =
4. Trees rooted at Y (1), Y (2) and Y (3) are simulated by
the sub-trees Y  (4), Y  (5) and Y  (6), respectively.
Now we need



such that for a ≤ x < 4a


So deﬁne



(f(x)) ↔

(x).

as follows: for y < 3 · 4 and a ≤ 4m + y < 4a,
m



(4m+1 + y) ↔

(4m + y).

To obtain ϕ  , write ϕ(x)[p0 , p1 , p2 , p3 ] in the form
ϕ1 (x)[ϕ2 (x)[p0 , p1 ], ϕ3 (x)[p2 , p3 ]]
where ϕi is ΣB0 with at most 2 Boolean variables, for 1 ≤ i ≤ 3. Deﬁne ϕ 
as follows:
ϕ  (4m+1 + y)[p, q] ↔ ϕ1 (4m + y)[p, q]

for y < 3 · 4m ,

ϕ  (2 · 4m+1 + 2y)[p, q] ↔ ϕ2 (4m + y)[p, q]

for y < 3 · 4m /2,

ϕ  (2 · 4m+1 + 2y + 1)[p, q] ↔ ϕ3 (4m + y)[p, q]

for y < 3 · 4m /2.

Finally, let a  = f(a). Let Y  satisﬁes (278) for a  ,
Y be such that
Y (x) ↔ Y  (f(x)).
It is straightforward to verify that Y satisﬁes (279).
1



and ϕ  , and let

2

The next theorem shows that in VNC we can evaluate multiple interconnected Boolean circuits where each has logarithmic depth and constant
fan-in.
Theorem IX.5.14. Suppose that 1 ≤ m,  ∈ N, and for 1 ≤ i ≤ m,
B
i (x, y) and ϕi (x, y)[p1 , q1 , . . . , pm , qm ] are Σ0 formulas where p, q are

328

IX. Theories for Small Classes

the Boolean variables. Then VNC 1 proves the existence of Z1 , . . . , Zm such
that
m

(Zi[z] (x + a) ↔

∀z < c∀x < a

i (z, x)) ∧ 0 < x ⊃



[z]

Zi (x) ↔

i=1

!


ϕi (z, x)[Z1[z] (2x), Z1[z] (2x +1), . . . , Zm[z+−1] (2x), Zm[z+−1] (2x +1)] .
Proof. Using Theorem IX.5.13 above, the idea is to construct a constant k, a number a  and ΣB0 formulas  (c, x) and ϕ  (c, x)[p0 , . . . , pk−1 ]
so that from the set Y that satisﬁes (279) (for k, a  ,  and ϕ  ) we can
obtain Z1 , . . . , Zm .
Consider for example m = 2,  = 2. W.l.o.g., assume that c ≥ 1. The
(overlapping) subtrees
Z1[0] , Z2[0] , . . . , Z1[c−1] , Z2[c−1]

(280)

have branching factor 8 (i.e., 2m). So let k = 8 (i.e., k = 2m). We will
construct Y (with branching factor 8) so that the disjoint subtrees rooted
at
Y (c), . . . , Y (3c − 1)

(281)

are exactly the subtrees listed in (280).
We will deﬁne an 1-1, into map
s : {1, 2} × N2 → N
so that
Zi[z] (x) ↔ Y (s(i, z, x)).
The map s must be deﬁned in such a way that the nodes of the trees listed
in (280) match with those whose roots are listed in (281). For example,
for the root level we need
s(1, 0, 1) = c, s(2, 0, 1) = c + 1, s(1, 1, 1) = c + 2, s(2, 1, 1) = c + 3, . . . .
For other levels we need: If s(i, z, x) = y, then
s(1, z, 2x) = 8y, s(1, z, 2x + 1) = 8y + 1, . . . , s(2, z + 1, 2x + 1) = 8y + 7.
To deﬁne s we deﬁne partial, onto maps f, g : N → N and h : N →
{1, 2} so that
s(h(y), g(y), f(y)) = y.
In other words,
[g(y)]

Y (y) ↔ Zh(y) (f(y)).
For example, for 0 ≤ z < 2c:
f(c + z) = 1,

g(c + z) = z/2,

h(c + z) = 1 + (z

mod 2).

IX.5. Theories for NC 1 and the NC Hierarchy

329

In general, we need to deﬁne f, g, h only for values of x of the form 8r c + z
for 0 ≤ z < 2 · 8r c. The deﬁnitions of f, g, h at 8r c + z are straightforward
using the base 8 notation for z, where 0 ≤ z < 2 · 8r c.
Once f, g, h are deﬁned, the formula  and ϕ  are deﬁned by


(c, x) ↔

h(x) (g(x), f(x))

and
ϕ  (c, x)[. . . ] ↔ ϕh(x) (g(x), f(x))[. . . ]
2

(where . . . is the list of 2m Boolean variables).

Exercise IX.5.15. Use Theorem IX.5.14 to give a more detailed proof
of Lemma IX.5.7 stating that the function Fval  is ΣB1 -deﬁnable in VNC 1 .
For the next theorem we use Sum(a, X ) for the sum of a rows of X :

∅
if a = 0,
Sum(a, X ) =
[0]
[1]
[a −̇1]
if a ≥ 1.
X + X + ··· + X
(We introduced the function Sum(m, n, X ) in (250) and (251) on page
294. The two functions Sum(a, X ) and Sum(m, n, X ) have the same name
but diﬀerent arity, so the exact meaning is clear from context.)
Theorem IX.5.16. The function Sum(a, X ) with the following deﬁning
1
axiom is ΣB1 -deﬁnable in VNC :
Sum(a, X ) = Y ↔
|Y | ≤ a, |X | ∧ Y [0] = ∅ ∧ ∀x < a(Y [x+1] = Y [x] + X [x] ).

(282)

The fact that VTC 0 ⊆ VNC 1 follows easily:
Corollary IX.5.17. VTC 0 ⊆ VNC 1 .
Proof of Theorem IX.5.16. Informally we need to construct a circuit
that adds all rows
X [0] , X [1] , . . . , X [a−1] .
The idea is to use the divide-and-conquer technique. We will construct
a balanced binary tree Z that has (2a − 1) nodes (see Figure 11 for an
example):
• a leaves Z [a] , Z [a+1] , . . . , Z [2a−1] such that
Z [a+x] = X [x]

for 0 ≤ x < a.

• (a − 1) inner nodes Z [1] , Z [2] , . . . , Z [a−1] ; the two children of node
Z [x] are Z [2x] and Z [2x+1] , so that
Z [x] = Z [2x] + Z [2x+1]

for 1 ≤ x < a.

330

IX. Theories for Small Classes

Lemma IX.5.18. Let DaCAdd(a, I, Z) be the formula
∀x < a, Z [a+x] = I [x] ∧ x > 0 ⊃ Z [x] = Z [2x] + Z [2x+1] .

(283)

(DaCAdd stands for “divide-and-conquer addition”.) Then
1

VNC  ∀a∀I ∃ZDaCAdd(a, I, Z).
Z [1]

Z [2]

Z [3]

Z [4]

Z [5]

Z [8]

Z [9]

Z [10]

Z [11]

I [2]

I [3]

I [4]

I [5]

Z [6]

Z [7]

I [0]

I [1]

Figure 11. The balanced binary tree Z for DaCAdd(6, I, Z).
Proof. We show how to compute Z by an NC 1 circuit. Note that if
for each x < a we simply construct an AC 0 circuit that performs string
addition to compute Z [x] from Z [2x] and Z [2x+1] (i.e. Z [x] = Z [2x] +
Z [2x+1] ) and stack them together, the resulting circuit has depth O(log n)
(where n is the number of input bits) but unbounded fan-in.
Here we use the fact that
X + Y + Z = G(X, Y, Z) + H (X, Y, Z)

(284)

where G(X, Y, Z) is the string of bit-wise sums, and H (X, Y, Z) is the
string of carries:
G(X, Y, Z)(z) ↔ X (z) ⊕ Y (z) ⊕ Z(z),
H (X, Y, Z)(0) ↔ ⊥,

H (X, Y, Z)(z + 1) ↔ (X (z) ∧ Y (z)) ∨ (X (z) ∧ Z(z)) ∨


(Y (z) ∧ Z(z)) .

Exercise IX.5.19. Show that V 0 (G, H ) proves the equation (284).
Thus, for each Z [x] we have a pair of strings (S [x] , C [x] ) where S [x] is the
string of bit-wise sums and C [x] is the string of carries; and for 1 ≤ x < a,
Z [x] = S [x] + C [x] .

IX.5. Theories for NC 1 and the NC Hierarchy

331

(For a ≤ x < 2a, we will take S [x] = I [x −̇a] and C [x] = ∅.)
We need for 1 ≤ x < a,
S [x] + C [x] = S [2x] + C [2x] + S [2x+1] + C [2x+1] .
So
S [x] = G(C [2x+1] , U, V ),

C [x] = H (C [2x+1] , U, V )

where
U = G(S [2x] , C [2x] , S [2x+1] ),

V = H (S [2x] , C [2x] , S [2x+1] ).

In other words, let F1 , F2 be the AC 0 functions:
F1 (X, Y, Z, W ) = G(W, G(X, Y, Z), H (X, Y, Z)),
F2 (X, Y, Z, W ) = H (W, G(X, Y, Z), H (X, Y, Z)).
Then
S [x] = F1 (S [2x] , C [2x] , S [2x+1] , C [2x+1] )
and
C [x] = F2 (S [2x] , C [2x] , S [2x+1] , C [2x+1] ).
In summary we need to prove in VNC 1 the existence of S and C such
that
∀x < a, S [x+a] = I [x] ∧ C [x+a] = ∅ ∧

0 < x ⊃ (S [x] = F1 (S [2x] , C [2x] , S [2x+1] , C [2x+1] ) ∧


C [x] = F2 (S [2x] , C [2x] , S [2x+1] , C [2x+1] )) .

Notice that for each z, the bits S [x] (z), C [x] (z) are computed from the
bits
·
2 ≤ y ≤ z}
{S [2x] (y), S [2x+1] (y), C [2x] (y), C [2x+1] (y) : z −

(where we deﬁne S [2x] (y) ≡ ⊥ if y < 0, etc.). This is not in the form
of the hypothesis of Theorem IX.5.14, but we can put it in the required
form by transposing S and C . Recall the function Transpose from (252)
(page 295). We will ﬁrst compute St = Transpose(b, b, S) and Ct =
Transpose(b, b, C ) where b = |I | is a suﬃciently large bound.
Thus St[z] (x) and Ct[z] (x) are computed from
{St[y] (2x), St[y] (2x + 1), Ct[y] (2x), Ct[y] (2x + 1) : z − 2 ≤ y ≤ z}
by a ΣB0 formulas. Therefore by Theorem IX.5.14, VNC 1 proves the
existence of St and Ct .
2
Notice that V 0 proves the uniqueness of Z in (283). Deﬁne Sum(a, X )
as follows. First,
Sum(0, X ) = ∅.

332

IX. Theories for Small Classes

For a ≥ 1 we apply the above lemma for a full binary tree. Thus let a1 be
the smallest power of 2 that is ≥ a, and deﬁne X1 such that
X1[x] = X [x] for x < a and X1[x] = ∅ for a ≤ x < a1 .

(285)

Let Z be the string that satisﬁes DaCAdd(a1 , X1 , Z) as in Lemma IX.5.18
(see Figure 12). Deﬁne
Sum(a, X ) = Z [1] .
Z [1]

Z [2]

Z [3]

Z [4]

Z [5]

Z [6]

Z [7]

Z [8]

Z [9]

Z [10]

Z [11]

Z [12]

Z [13]

Z [14]

Z [15]

X [0]

X [1]

X [2]

X [3]

X [4]

X [5]

∅

∅

Figure 12. Deﬁning Sum(6, X ) using a full binary tree.
1

It remains to show that VNC (Sum) proves (282). For this, it suﬃces
to show that
Sum(a + 1, X ) = Sum(a, X ) + X [a] .

(286)

When a = 0 this is straightforward. So ﬁrst consider the case where a ≥ 1
and a is not a power of 2. Let X1 be as in (285), and let X2 be such that
X2[x] = X [x] for x ≤ a and X2[x] = ∅ for a < x < a1 .
Let Z1 and Z2 be such that DaCAdd(a1 , X1 , Z1 ) and DaCAdd(a1 , X2 , Z2 )
hold. By deﬁnition,
Sum(a, X ) = Z1[1]

and

Sum(a + 1, X ) = Z2[1] .

So we have to show that
[1]

Z2 = Z1 [1] + X [a].
The trees Z1 and Z2 have the same height h = log a1 . Note that h + 1
is the length of the binary representation of (a1 + a). Also, h is deﬁnable
in IΔ0 (see Section III.3.3). Let
d0 = 1, d1 = 3, d2 , . . . , dh = (a1 + a)

IX.5. Theories for NC 1 and the NC Hierarchy

333

be all initial segments of the binary representation of (a1 + a). Then
Z2[d0 ] , Z2[d1 ] , . . . , Z2[dh ]
are all nodes in the tree Z2 on the path from the root to the leaf Z [a1 +a] =
X [a] .
It can be proved by reverse induction on i that
(Z2[di ] = Z1[di ] + X [a] ) ∧ ∀x < a1 (|x| = |di | ∧ x < di ⊃ Z2[x] = Z1[x] ).
For i = 0 we obtain Z2[1] = Z1[1] + X [a] as required.
The case where a is a power of 2 is left as an exercise.

2

Exercise IX.5.20. Finish the proof of the theorem by showing that
(286) is true when a is a power of 2.
IX.5.5. The Theory VNC 1 V. In this section we will deﬁne VNC 1 V
using 5-BNR, a bounded number recursion scheme that characterizes
FNC 1 . This recursion theoretic characterization is based on Barrington’s
Theorem that asserts that NC 1 is the class of relations computable by
width 5 branching programs, or equivalently the word problem for the
permutation group S5 is complete for NC 1 .
Here the vocabulary LVNC 1 V consists of symbols for all FNC 1 functions, but their deﬁning axioms are based on 5-BNR rather than on AC 0 1
reductions to the function Fval (that are used to deﬁne VNC ). Recall
the bounded number recursion (BNR) scheme in Section IX.3.3.
Theorem IX.5.21 (Barrington). A function is in FNC 1 iﬀ it can be obtained from the empty set of functions by ﬁnitely many applications of AC 0
reduction and 5-BNR.
By Theorem IX.1.7 it follows also that FNC 1 is the class of functions
obtained from FAC 0 by ﬁnitely many applications of composition, string
comprehension and 5-BNR.
Deﬁnition IX.5.22. The vocabulary LVNC 1 V is the smallest set that
contains LFAC 0 such that:
• For each L2A -term t and quantiﬁer-free LVNC 1 V -formula ϕ there is a
function Fϕ(z),t in LVNC 1 V with deﬁning axiom (86):
Fϕ(z),t (x, X )(z) ↔ z < t(x, X ) ∧ ϕ(z, x, X ).

(287)

• For every string function F (x, X ) in LVNC 1 V the number function
fF (x, X ) is also in LVNC 1 V with deﬁning axiom
fF (x, X ) = |F (x, X )|.

(288)

• For any number functions g(x, X ) and h(y, z, x, X ) in LVNC 1 V , there
is a number function fg,h (y, x, X ) in LVNC 1 V with deﬁning axiom

334

IX. Theories for Small Classes
(omitting x, X )

(g < 5 ⊃ fg,h (0) = g) ∧ (g ≥ 5 ⊃ fg,h (0) = 0) ∧
(h(y, fg,h (y)) < 5 ⊃ fg,h (y + 1) = h(y, fg,h (y))) ∧
(h(y, fg,h (y) ≥ 5 ⊃ fg,h (y + 1) = 0). (289)
The next corollary follows from Theorem IX.5.21.
Corollary IX.5.23. (a) A function is in FNC 1 iﬀ it is represented by
a function in LVNC 1 V .
(b) A relation is in NC 1 iﬀ it is represented by an open (or a ΣB0 ) formula
of LVNC 1 V .
Deﬁnition IX.5.24 (VNC 1 V). The theory VNC 1 V has vocabulary
0
LVNC 1 V and axioms those of V together with (287) for each function
Fϕ(z),t and (288) for each function fF and (289) for each function fg,h .
The next exercise can be proved as in Lemma IX.3.16 and Corollary IX.3.21.
Exercise IX.5.25.
iom schemes

(a) Show that the theory VNC 1 V proves the ax-

ΣB0 (LVNC 1 V )-COMP, ΣB0 (LVNC 1 V )-IND, and ΣB0 (LVNC 1 V )-MIN.
(b) Show that for every ΣB0 (LVNC 1 V ) formula ϕ + there is a ΣB1 formula
ϕ so that VNC 1 V  ϕ + ↔ ϕ.
Corollary IX.5.26. (a) A function is in FNC 1 iﬀ it is ΣB1 -deﬁnable in
VNC 1 V.
(b) A relation is in NC 1 iﬀ it is ΔB1 -deﬁnable in VNC 1 V.
Proof sketch. (a) This part follows from Theorem IX.5.21 and Exercise IX.5.25 above. It is proved in the same way as Corollary IX.3.22.
(b) From (a) and Theorem V.4.35.
2
1
Theorem IX.5.27. VNC V is a universal conservative extension of
VNC 1 .
We outline the proof below. For details see [82].
Proof Idea. To show that VNC 1 V extends VNC 1 , the main task is to
show that VNC 1 V  MFV. The idea is to formalize in VNC 1 V the proof
that the Boolean Sentence Value Problem (see page 321) can be computed
using width 5 branching programs (the =⇒ direction of Theorem IX.5.21).
To show that VNC 1 V is conservative over VNC 1 essentially we need to
show that width 5 branching programs can be simulated by families of NC 1
circuits. The proof can be by induction on the deﬁnition of VNC 1 V. (See
also Section VIII.2.2 for the proof that VPV is a universal conservative
extension of VP.)
2

IX.5. Theories for NC 1 and the NC Hierarchy

335

IX.5.6. Theories for the NC Hierarchy. We develop the theories for
AC k and NC k+1 using the fact that the Circuit Value Problem is complete
for the respective classes under appropriate restriction on the given circuits.
Consider encoding a layered, monotone Boolean circuit C with (d + 1)
layers and n unbounded fan-in (∧ or ∨) gates on each layer. We need to
specify the type (either ∧ or ∨) of each gate, and the wires between the
gates. Suppose that layer 0 contains the inputs which are speciﬁed by a
string variable I of length |I | ≤ n. To encode the gates on other layers,
there is a string variable G such that for 1 ≤ z ≤ d , G(z, x) holds if and
only if gate x on layer z is an ∧-gate (otherwise it is an ∨-gate). Also,
the wires of C are encoded by a 3-dimensional array E: z, x, y ∈ E
iﬀ the output of gate x on layer z is connected to the input of gate y on
layer z + 1.
The following algorithm computes the outputs of C using (d + 1)
loops: in loop z it identiﬁes all gates on layer z which output 1. It starts
by identifying the input gates with the value 1. Then in each subsequent
loop (z + 1) the algorithm identiﬁes the following gates on layer (z + 1):
• ∨-gates that have at least one input which is identiﬁed in loop z;
• ∧-gates all of whose inputs are identiﬁed in loop z.
The formula LMCV (n, d, E, G, I, Y ) below formalizes this algorithm
(LMCV stands for “layered monotone circuit value”). The 2-dimensional
array Y stores the result of computation: For 1 ≤ z ≤ d , row Y [z] contains
the gates on layer z that output 1.

LMCV (n, d, E, G, I, Y ) ≡ ∀x < n∀z < d (Y (0, x) ↔ I (x)) ∧

Y (z + 1, x) ↔ (G(z + 1, x) ∧ ∀u < n, E(z, u, x) ⊃ Y (z, u)) ∨

(¬G(z + 1, x) ∧ ∃u < n, E(z, u, x) ∧ Y (z, u)) . (290)
For NC k we need the following formula which states that the circuit
with underlying graph (n, d, E) has fan-in 2:

Fanin2(n, d, E) ≡ ∀z < d ∀x < n∃u1 < n∃u2 < n∀v < n E(z, v, x) ⊃

(v = u1 ∨ v = u2 ) .
Recall (Section III.3.3) that the function |x| = log(x + 1) is an AC 0
function with a Δ0 graph. Deﬁne the functions Lmcvk and Lmcvk,2 as
follows:

Lmcvk (n, E, G, I ) = Y ↔ |Y | ≤ |n|k + 1, n ∧


LMCV (n, |n|k , E, G, I, Y ) .

336

IX. Theories for Small Classes

and


Lmcvk,2 (n, E, G, I ) = Y ↔ (¬Fanin2(n, d, E) ∧ Y = ∅) ∨


(Fanin2(n, d, E) ∧ |Y | ≤ |n|k + 1, n ∧ LMCV (n, |n|k , E, G, I, Y )) .

Theorem IX.5.28. For k ≥ 1, FAC k is the closure of Lmcvk under AC 0
reductions. For k ≥ 2, FNC k is the closure of Lmcvk,2 under AC 0 reductions.
Proof. It is easy to see that every function in uniform FAC k (resp.
FNC k ) is AC 0 many-one reducible to Lmcvk (resp. Lmcvk,2 ). Also, the
proof that FAC k and FNC k are closed under AC 0 reductions is similar
to the proof of Theorem IX.5.3 for the class NC 1 , where now we use the
ATM characterizations (271) and (272) for these classes. It remains to
show that the Lmcv functions belong to their respective classes.
We show that Lmcvk is in FAC k by using its ATM characterization
(271). Thus we describe an ATM M using space O(log n) and alternations
O((log n)k ) which computes the bit graph of Lmcvk .
Let C be the circuit of depth |n|k and width n described by (n, E, G, I ).
In order to compute bit i of Lmcvk (n, E, G, I ) the machine M must accept
the input (n, E, G, I, i) iﬀ gate i is . Thus M starts by guessing that gate
i is , and then follows a path down to an input gate. For each gate g
on the path, M veriﬁes that g is  as follows. If g is an ∨ gate then M
guesses (using existential states) which input g  of g is , and proceeds to
g  as the next gate. If g is an ∧ gate, then M enters universal states and
and proceeds to an arbitrary input g  . If g is an input to the circuit, then
M accepts iﬀ I (g) holds.
It is easy to see that this computation is correct. Further M needs to
keep only two gates written on its tape at once, so the space is O(log n).
Finally the number of alternations is bounded by the depth of the circuit,
which is O((log n)k ).
For k ≥ 2 we show that Lmcvk,2 is in NC k by using (272). Thus we need
an ATM M which uses space O(log n) and time O((log n)k ) which computes the bit graph of Lmcvk,2 . This proof is more complicated than the
one above, and we follow the argument given by Ruzzo [100, Theorem 4].
Let C be a circuit of fanin 2, depth |n|k and width n described by
(n, E, G, I ). M determines whether a given gate i in C is  by following
an arbitrary path from i down to an input gate in a manner similar to the
AC k case above, except now M uses a diﬀerent notation for the current
gate g in the path. Initially M sets a variable h to i (in binary), where in
general h is the gate at the head of the path segment it is remembering.
M also remembers the path p from h to g, where p is a string over the
alphabet {L, R}, where the j-th element of p is L if the path follows the
left input out of the j-th gate in the path, and otherwise the j-th element
is R (here we use the fanin 2 assumption). At each gate g in the path, M
guesses whether g is ∧ or ∨, and then (in parallel using universal states)

IX.5. Theories for NC 1 and the NC Hierarchy

337

veriﬁes the guess and continues the computation. It veriﬁes the guess by
following the path p from h to the current gate, where at each step j along
the path it guesses and veriﬁes the j-th gate. The veriﬁcation can be done
in space O(log n) and time O(m log n), where m is the length of p.
The original computation continues by, depending on whether g is ∨ or
∧, either using existential or universal states to determine the next node
in the path (there are two choices: L or R for the two possible inputs
to g). The path ends when an input gate (at level 0) is reached, and the
computation accepts iﬀ that input is .
The above algorithm needs to be modiﬁed, because the depth of the
circuit is not O(log n), so the path p becomes too long to write down in
space O(log n) (and the veriﬁcation time might be too big). So each time
the path p reaches length log n the machine guesses the name (i.e. the pair
z, y) of g, and (in parallel using universal states) veriﬁes the guess as
explained above. Then p is set to the empty string, and the head h of the
path is set to the new gate g.
The space required is O(log n) because during the main part of the computation M need only remember the origin h of the current path segment,
and a path p ∈ {L, R}∗ of length at most log n.
The computation time of M is O((log n)k ) because the depth of the
circuit C is O((log n)k ), and the main part of each computation path of
M takes on the average constant time per gate. Each step in which the
path head h is reset to a new value requires time log n, but these expensive
steps represent only a fraction 1/O(log n) of the total, so the total time
spent by them is still O((log n)k ).
Note that the veriﬁcation algorithms are done in parallel with the main
computation path, because they begin with a universal state which forks
between the main path and the veriﬁcation. Hence the total computation
time of the algorithm is the maximum of the times of the main algorithm
and each of its veriﬁcation computations. Each veriﬁcation takes time at
most O(m log n) = O((log n)2 ).
2
Note that we do not know whether Lmcv1,2 is in NC 1 (or even nonuniform NC 1 ).
Deﬁnition IX.5.29 (VAC k , VNC k and VNC). For k ≥ 1, the theory
VAC k has vocabulary L2A and is axiomatized by V 0 and the axiom
∃Y ≤ |n|k + 1, n LMCV (n, |n|k , E, G, I, Y ).
For k ≥ 2, VNC k has vocabulary L2A and is axiomatized by V 0 and the
axiom
(Fanin2(n, |n|k , E) ⊃ ∃Y ≤ |n|k + 1, n LMCV (n, |n|k , E, G, I, Y )).

338

IX. Theories for Small Classes

Also,
VNC =

∞


VNC k .

k=1

It is straightforward to show that the aggregate functions Lmcvk for
k ≥ 1 (resp. Lmcvk,2 , for k ≥ 2) is ΣB1 -deﬁnable in VAC k (resp. VNC k ,
for k ≥ 2). Details are left as an exercise.
Exercise IX.5.30. Show that for k ≥ 1 Lmcvk and Lmcvk+1,2 are respectively ΣB1 -deﬁnable in VAC k and VNC k+1 .
The next result follows from the general development in Section IX.2.
Corollary IX.5.31. For k ≥ 1:
(a) The ΣB1 -deﬁnable functions of VAC k (resp. VNC k+1 ) are precisely the
functions in FAC k (resp. FNC k+1 ).
(b) The ΔB1 -deﬁnable functions of VAC k (resp. VNC k+1 ) are precisely
the relations in AC k (resp. NC k+1 ).
Corollary IX.5.32. (a) A function is in FNC iﬀ it is ΣB1 -deﬁnable in
VNC iﬀ it is ΣB1 -deﬁnable in VAC k for some k ≥ 0.
(b) A relation is in NC iﬀ it is ΔB1 -deﬁnable in VNC iﬀ it is ΔB1 -deﬁnable
in VAC k for some k ≥ 0.
Now we deﬁne U 1 , another theory that characterizes NC. Let |x|
denote the length of the binary representation of the number x. Using
the fact that the predicate BIT is Δ0 -deﬁnable (Section III.3.3) we can
show that |x| is an AC 0 function (see also Section VIII.8.3). Therefore,
by Lemma V.6.7 if ϕ(z) is a Φ formula, where Φ is ΣBi or ΠBi for some
i ≥ 0, then ϕ(|z|) is translates to an equivalent to a Φ formula. Below we
will use ϕ(|z|) to denote this translation. (In particular, ϕ(|z|) will be an
L2A formula.)
Deﬁnition IX.5.33 (Length induction – two-sorted case). For a set Φ
of formulas, Φ-LIND (length induction for Φ) is the set
[ϕ(0) ∧ ∀x, ϕ(x) ⊃ ϕ(x + 1)] ⊃ ∀zϕ(|z|)

(291)

where ϕ(x) is a formula in Φ that may contain variables other than x.
(Note that the single-sorted length induction axiom schemes given in
Deﬁnition VIII.8.2 (also denoted by LIND) roughly corresponds, i.e., via
RSUV isomorphism, to our number induction schemes IND.)
Deﬁnition IX.5.34 (U 1 ). The theory U 1 has vocabulary L2A and is axiomatized by the axioms of V 0 together with ΣB1 -LIND.
The following theorem follows from results in [35, 108].
Theorem IX.5.35. A function is in FNC iﬀ it is ΣB1 -deﬁnable in U 1 . A
relation is in NC iﬀ it is ΔB1 -deﬁnable in U 1 .

IX.6. Theories for NL and L

339

IX.6. Theories for NL and L
The class NL (resp. L) is the class of problems solvable by a nondeterministic (resp. deterministic) Turing machine in space O(log n) (see
Appendices A.1 and A.2). It is straightforward that L ⊆ NL and both
are subclasses of P. In fact, it can be shown that NL ⊆ AC 1 (see Exercise IX.6.12 below). To see that NC 1 ⊆ L note that the complete problem
RMFV (Deﬁnition IX.5.1) can be solved in deterministic log space using
depth-ﬁrst search (the path from the root to a node of depth d is speciﬁed
by a binary string of length d ). (Formal arguments will be given in Theorem IX.6.38.) It is also easy to see that L is closed under AC 0 reductions,
while for NL this follows from the important theorem of Immerman and
Szelepcsényi which states that NL is closed under complementation.
The theory VNL is developed using the fact that the st-Connectivity
(st-CONN) problem is AC 0 -complete for NL. Here the problem is to
decide, for a given directed graph G and two designated vertices s and t,
whether there is a path from s to t in G.
Krom formulas are propositional formulas in conjunctive normal form
where each clause contains at most two literals. The Krom-SAT problem, which is the problem of deciding whether a given Krom formula is
satisﬁable, is known to be complete for co-NL (and hence also for NL).
It has been used to develop the theory V 1 -KROM in the same style as
V 1 -HORN (Section VIII.4). We will show that V 1 -KROM is equivalent
to VNL.
Now consider a restricted version of the st-CONN problem where every
vertex in G has out-degree at most one. This is called the PATH problem
and it is AC 0 -many-one complete for L. We will use this fact to develop the
 and VL in the family of theories discussed in Section IX.2.
triple VL, VL
Finally, the bounded number recursion scheme pBNR (Section IX.3.3)
can be used to characterize FL. Based on this we will develop a universal
theory call VLV in the style of VPV and VTC 0 V. Here the vocabulary of
VLV contains symbols for every function in FL. Their deﬁning axioms
are based on pBNR.
This section is organized as follows. We deﬁne the theory VNL and its
 and VNL in Section IX.6.1. We
universal conservative extensions VNL
1
deﬁne V -KROM and show that it is equivalent to VNL in Section IX.6.2.
 and VL. Finally, in Section IX.6.4 we
In Section IX.6.3 we deﬁne VL, VL
deﬁne VLV.
 and VNL. Our theories for NL are
IX.6.1. The Theories VNL, VNL,
based on the fact that the st-CONN problem is complete for NL. We
encode a directed graph G by a pair (a, E) as follows:
• a is the number of vertices in G, and the vertices of G are numbered
0, . . . , (a − 1), and

340

IX. Theories for Small Classes

• for x, y < a, E(x, y) holds if and only if there is a directed edge
from x to y in G.
Our designated “source” s is always the vertex 0. Consider the algorithm
that solves the st-CONN problem by inductively computing all vertices
in G that have distance from s at most 0, 1, . . . , (a − 1). The formula
CONN (a, E, Y ) below states that Y [z] is the set of all vertices with distance
at most z from 0 (recall that x ∈ Y [z] ↔ Y (z, x)):
CONN (a, E, Y ) ≡ ROW (a, Y ) ∧ Y (0, 0) ∧


∀x < |Y |(x = 0 ⊃ ¬Y (0, x)) ∧ ∀z < a −· 1 ∀x < a + |Y | Y (z + 1, x) ↔

x < a ∧ (Y (z, x) ∨ ∃y < a(Y (z, y) ∧ E(y, x))) (292)
where
ROW (a, Y ) ≡ ∀u < |Y |(Y (u) ⊃ ∃i < a∃j < |Y | u = i, j).

(293)

Here ROW (a, Y ) asserts that Y is uniquely determined by its rows Y [0] ,
. . . , Y [a−1] .
Exercise IX.6.1. Show that V 0 proves that CONN (a, E, Y ) uniquely
determines Y for every pair a, E. That is show


V 0  CONN (a, E, Y ) ∧ CONN (a, E, Y  ) ⊃ Y = Y  .
We deﬁne the relation RCONN below by assigning the “target” vertex t
number 1.
Deﬁnition IX.6.2.
RCONN (a, E) ↔ ∃Y ≤ a, a(CONN (a, E, Y ) ∧ Y (a, 1)).
Theorem IX.6.3. The relation RCONN is in NL, and for every relation
R(x, X ) in NL there are AC 0 functions a0 , E0 such that
R(x, X ) ↔ RCONN (a0 (x, X ), E0 (x, X )).
Proof Sketch. The fact that RCONN is in NL is straightforward: on
input (a, E) the nondeterministic Turing machine guesses a path from 0
to 1 by enumerating the edges on the path.
Now let R(x, X ) be a relation in NL, so R is accepted by a nondeterministic Turing machine M that works in logspace. Suppose without loss
of generality that M has a unique accepting conﬁguration. The conﬁgurations of M (without the input tape content) can be encoded by numbers
less than t(x, X ) (for some number term t bounding the running time
of M) such that 0 is the initial conﬁguration and 1 is the only accepting
conﬁguration (see also Exercise VI.2.9). Consider the directed graph G
with vertices the numbers less than t(x, X ) such that there is an edge from
z1 to z2 iﬀ z2 is a next conﬁguration of z1 . Then M accepts (x, X ) iﬀ there
is a path from 0 to 1 in G.

IX.6. Theories for NL and L

341

The fact that z1 encodes a next conﬁguration of z2 can be expressed
by a ΣB0 formula ϕ(z1 , z2 , x, X ). Thus there is an AC 0 string function
E0 (x, X ) whose value is the adjacency matrix of the graph whose nodes
are conﬁgurations and whose edges indicate one-step transitions. The
bit-graph of E0 satisﬁes, for z1 , z2 < t(x, X ),
E0 (z, X )(z1 , z2 ) ↔ ϕ(z1 , z2 , x, X ).
Consequently M accepts (x, X ) iﬀ RCONN (t(x, X ), E0 (x, X )) holds. 2
Recall the deﬁnition of the function class FNL (Deﬁnition V.2.3) associated with NL. Prior to the Immerman–Szelepcsényi Theorem stating
that NL is closed under complementation, it was not known that FNL is
closed under composition. In fact it was not known that the characteristic
function C (a, E) of RCONN (a, E) is in FNL, because in order to verify that
C (a, E) = 0 a nondeterministic log space Turing machine would have to
verify that there is no path from node 0 to node 1 in the graph speciﬁed
by E. However knowing that NL = co-NL it is easy to show that FNL is
closed under composition. For example, to verify that bit i of F (G(X )) is
0 a nondeterministic log space Turing machine M simulates the machine
for F on input G(X ), where each time that machine needs a bit j of G(X )
M guesses whether the bit is 1 or 0, and in either case can verify the guess
by simulating the machine for G or the complement machine.
Theorem IX.6.4. FNL is closed under AC 0 -reductions.
Proof sketch. By Theorem IX.1.7 it suﬃces to show that FNLis closed
under composition and string comprehension. We argued the case for
composition above. For string comprehension, to determine whether
i = f(y) for some y < b a log space machine guesses the answer and
veriﬁes it. If the guess is YES, the veriﬁcation is a nondeterministic log
space computation (because b is small and can be written in binary on
the work tape), and if the answer is NO the machine veriﬁes it using the
complementary machine.
2
Deﬁnition IX.6.5 (VNL). The theory VNL has vocabulary L2A and is
axiomatized by the axioms of V 0 together with the axiom CONN, where
CONN ≡ ∃Y ≤ a, a + 1 CONN (a, E, Y ).
The function REACH has deﬁning axiom
REACH(a, E) = Y ↔ CONN (a, E, Y ).

(294)

The next result is immediate from Theorems IX.6.3 and IX.6.4.
Corollary IX.6.6. The function REACH is complete for FNL under
AC 0 -reductions.
Lemma IX.6.7. Both REACH and its aggregate function REACH  are
B
Σ1 -deﬁnable in VNL, and VNL(Row, REACH, REACH  ) proves (166):
∀i < b, REACH  (b, X, E)[i] = REACH((X )i , E [i] ).

342

IX. Theories for Small Classes

Proof. That REACH is deﬁnable is immediate from the axiom CONN
for VNL and Exercise IX.6.1. That REACH  is deﬁnable is a simple
exercise in coding the disjoint union of a sequence of graphs as a single
graph with a common initial vertex 0.
2
Exercise IX.6.8. Give details for REACH  in the above Lemma.

Following the method of Section IX.2 we now deﬁne the theories VNL

and VNL. Let CONN (a, E, Y ) be the quantiﬁer-free LFAC 0 -formula that
0
is equivalent to CONN (a, E, Y ) over V (see Lemma V.6.3). Let REACH 
be deﬁned by

REACH  (a, E) = Y ↔ CONN
(a, E, Y ).

(295)



Then REACH and REACH are semantically equal functions but have
diﬀerent deﬁning axioms.
 Let L = LFAC 0 ∪ {REACH  }. VNL
 is
Deﬁnition IX.6.9 (VNL).
VNL
the theory with vocabulary LVNL
 and is axiomatized by the axioms of V
together with (295).

0

Deﬁnition IX.6.10 (VNL). The vocabulary LFNL is the smallest set
2
that contains LVNL
 such that for every LA -term t and every quantiﬁer-free
LFNL -formula ϕ the function Fϕ(z),t with deﬁning axiom (86):
Fϕ(z),t (x, X )(z) ↔ z < t(x, X ) ∧ ϕ(z, x, X )

(296)

is in LFNL .
The theory VNL has vocabulary LFNL and is axiomatized by the axioms
 and (296) for each function Fϕ(z),t .
of VNL
The Deﬁnability Theorems for our theories here follow from our discussion in Section IX.2.

Corollary IX.6.11. Here either L is LVNL
 and T is VNL, or L is LFNL
and T is VNL.
(a) A function is in FNL iﬀ it is represented by a term in LVNL
 (and for a
string function) iﬀ it is represented by a function symbol in LFNL . A
relation is in NL iﬀ it is represented by an open (or a ΣB0 ) formula of
L.
(b) For every ΣB1 (L) formula ϕ + there is a ΣB1 (L2A ) formula ϕ so that
T  ϕ + ↔ ϕ.
(c) T proves ΣB0 (L)-COMP, ΣB0 (L)-IND, and ΣB0 (L)-MIN.
 which is in turn a
(d) VNL is a universal conservative extension of VNL
universal conservative extension of VNL.
(e) The ΣB1 -deﬁnable functions of VNL (or T ) are precisely the functions
in FNL.

IX.6. Theories for NL and L

343

(f) The ΔB1 -deﬁnable relations of VNL (or T ) are precisely the relations
in NL.
Exercise IX.6.12. Recall the theory VAC 1 from Section IX.5.6. Show
that VNL ⊆ VAC 1 . The idea is that the transitive closure of a graph on n
vertices can be computed by squaring the adjacency matrix of the graph
log n times, and this can be computed by a circuit of depth O(log n) with
unbounded fanin ∧ and ∨ gates.
IX.6.2. The Theory V 1 -KROM. A Krom formula is a propositional
formula in conjunctive normal form where each clause contains at most
two literals. The Satisﬁability Problem for Krom formulas, Krom-SAT, is
complete for co-NL (or equivalently NL, by the Immerman–Szelepcsényi
Theorem). In descriptive complexity theory Grädel’s Theorem states that
NL is the class of ﬁnite models of the second-order Krom formulas [53].
This idea was used in [44] to develop the theory V 1 -KROM.
We start by deﬁning Σ11 -Krom formulas, which are Σ11 and resemble
propositional Krom formulas. In Theorem IX.6.18 we show that Σ11 -Krom
formulas represent precisely the co-NL relations.
Deﬁnition IX.6.13 (Σ11 -Krom Formula). A Σ11 (L2A )-formula (x, X ) is
called a Σ11 -Krom formula if it is of the form:
∃P1 . . . ∃Pk ∀z1 ≤ t1 (x, X ) . . . ∀zm ≤ tm (x, X )ϕ(z, x, X , P)

(297)

where ti are L2A -terms and ϕ(z, x, X , P) is a quantiﬁer-free formula in
conjunctive normal form. Each clause contains at most two literals of
the form Pj (s(z, x, X )) or ¬Pj (s(z, x, X )) for some number term s, but
may contain any number of literals of the form (possibly negated) Xi (t),
t1 ≤ t2 , and t1 =1 t2 . No occurrence of =2 or a term of the form |Pj | is
allowed.
Notice that ΣB0 ⊆ Σ11 -Krom. However Corollary IX.6.16 below shows
each ΣB0 -formula is equivalent in the theory V 0 to a Σ11 -Krom formula.
Example IX.6.14 (Transitive Closure in Graphs). Suppose that a graph
G is coded by (a, E) as before (page 339). The formula ContainTC(a, E, P)
below states that P contains the transitive closure of G, i.e., if there is a
path from x to y in G, then P(x, y) holds:
ContainTC(a, E, P) ≡ ∀x < a∀y < a∀z < a,
(E(x, y) ⊃ P(x, y)) ∧ (P(x, y) ∧ E(y, z) ⊃ P(x, z)).
The following Σ11 -Krom formula states that there is no path from x1 to x2
in G:
ϕ¬Reach (x1 , x2 , a, E) ≡ ∃P(ContainTC(a, E, P) ∧ ¬P(x1 , x2 )).

(298)

344

IX. Theories for Small Classes

The set Y that satisﬁes comprehension for ϕ¬Reach :
|Y | ≤ a ∧ ∀y < a(Y (y) ↔ ϕ¬Reach (x, y, a, E))
is the set of all vertices that are not reachable from vertex x.
The formula ϕ in (297) is a quantiﬁer-free formula. In some cases it is
convenient to allow the non-Pi part of ϕ to be a ΣB0 formula. The next
lemma shows that this is possible.
Lemma IX.6.15. Suppose that (x, X ) is a Σ11 formula
∃P∀z ≤ t

ϕi (z, x, X , P)

(299)

i

where each formula ϕi is a disjunction of the form
 ∨   ∨ i (z, x, X )
where ,   are literals (possibly omitted ) of the form Pj (s) or ¬Pj (s) ( for
some number terms s not containing any of P) and i is a ΣB0 formula that
does not contain any of P. Then is equivalent in V 0 to a Σ11 -Krom formula.
The special case in which P and z are missing yields:
Corollary IX.6.16. Every ΣB0 -formula is equivalent in V 0 to a Σ11 -Kromformula.
Proof of Lemma IX.6.15. We prove the lemma by structural induction
on the formulas i . Assume w.l.o.g. that they are in prenex form. The
base case (all i are quantiﬁer-free) is obvious. Consider the induction
step. First suppose that for some i the formula i has the form
∀u ≤ ti (u, z)
where we have suppressed the variables x, X . Let ϕ  (u, z, P) be obtained
from ϕi (z, P) by replacing i by i . Then


ϕj (z, P) .
↔ ∃P∀z ≤ t∀u ≤ t ϕi (u, z, P) ∧
j =i

Now consider the case where i begins with ∃u ≤ t. Suppose w.l.o.g.
that we can write φi in the form
ϕi ≡ (P1 (s) ∧ ∀u ≤ ti (u, z)) ⊃ P2 (r).
We introduce a new variable Q and force Q(v, z) to be true if P1 (s) ∧ ∀u ≤
vi (u, z) holds. Deﬁne ϕ  by
ϕ  (u, z, Q, P1 , P2 ) ≡ (P1 (s ) ∧ i (0, z) ⊃ Q(0, z)) ∧
(Q(u, z) ∧ i (u + 1, z) ⊃ Q(u + 1, z)) ∧ (Q(t, z) ⊃ P2 (r)).

IX.6. Theories for NL and L

345

Note that involving P1 (s ) in the deﬁnition of Q allows the last clause in ϕ 
to have only two occurrences of literals from Q, P. It is straightforward
to prove in V 0 that


↔ ∃P∃Q∀z ≤ t∀u ≤ t ϕi (u, z, Q, P1 , P2 ) ∧
ϕj (z, P) .
2
j =i
Corollary IX.6.17. Suppose that is a formula of the form (299) with
the same restrictions as in the Lemma except now i is a ΣB0 (LFAC 0 )-formula
instead of a ΣB0 -formula and the number terms s in Pi (s) are LFAC 0 -terms
0

instead of L2A -terms. Then is equivalent in V to a Σ11 -Krom formula.
Proof. Replace each occurrence of the form Pi (si ) in by P(ui )∨ ui =
si , for new variables ui , and add the bounded quantiﬁers ∀ui ≤ t  to the
preﬁx ∀z ≤ t in (299) for suitable bounding terms t  . Similarly for
occurrences ¬Pi (si ). Now use Lemma V.6.3 to replace each ΣB0 (LFAC 0 )formula by an equivalent ΣB0 -formula. The Corollary now follows from
Lemma IX.6.15.
2
The next result is essentially due to Grädel [53].
Theorem IX.6.18 (Σ11 -Krom Representation). A relation is represented
by a Σ11 -Krom formula if and only if it is in co-NL.
Proof. First we prove the ONLY IF direction. Let R(x, X ) be a relation represented by the Σ11 -Krom formula (297):
∃P1 . . . ∃Pk ∀z1 ≤ t1 (x, X ) . . . ∀zm ≤ tm (x, X )ϕ(z, x, X , P).
For a given input (x, X ), let vi be the value of ti (for 1 ≤ i ≤ m). Now
for each (z1 , z2 , . . . , zm ) where
0 ≤ zi ≤ vi

(for 1 ≤ i ≤ m)

we treat the atoms of the form Pj (s(z, x, X )) as propositional variables.
Since all terms and other variables in ϕ can be evaluated, ϕ(z, x, X , P)
can be made into a Krom formula Az1 ,...,zm whose variables are of the form
Pj (s(z, x, X )). Semantically,
∀z1 ≤ t1 (x, X ) . . . ∀zm ≤ tm (x, X )ϕ(z, x, X , P)
is equivalent to the Krom formula
v1

vm

···
z1 =0

Az1 ,...,zm .

(300)

zm =0

Therefore (x, X ) ∈ R iﬀ (300) is satisﬁable.
Notice that (300) can be obtained from the formula (297) and (x, X )
in deterministic logspace (in fact, AC 0 ). So the fact that R is in co-NL
follows from the following result.
Lemma IX.6.19. The Satisﬁability problem for Krom formulas is in
co-NL.

346

IX. Theories for Small Classes

Proof. We associate with each Krom formula K a graph GK whose
nodes are the set of literals  such that  or  occurs in K, and whose edges
are pairs (1 , 2 ) such that one of the clauses (1 ∨ 2 ), (2 ∨ 1 ) occurs in
K. The Lemma follows from the following exercise.
2
Exercise IX.6.20. Show that K is unsatisﬁable iﬀ the graph GK has a
directed cycle containing both  and  for some literal .
Now we prove the IF direction. Suppose that R(x, X ) is a co-NL
relation, we show that R can be represented by a Σ11 -Krom formula. By
Proposition IX.6.3 there are AC 0 functions a0 (x, X ) and E0 (x, X ) so that
R(x, X ) ↔ ¬RCONN (a0 (x, X ), E0 (x, X ))
i.e., (x, X ) ∈ R iﬀ 1 is not reachable from 0 in the graph (a0 (x, X ),
E0 (x, X )). Thus by Example IX.6.14,
R(x, X ) ↔ ϕ¬Reach (0, 1, a0 (x, X ), E0 (x, X )).
By Corollary IX.6.17 ϕ¬Reach (0, 1, a0 (x, X ), E0 (x, X )) is equivalent in V 0
to a Σ11 -Krom formula.
2
Deﬁnition IX.6.21. The theory V 1 -KROM has vocabulary L2A and is
axiomatized by 2-BASIC (Figure 2 on page 96) and the comprehension
axiom scheme for all Σ11 -Krom formulas.
Although ΣB0 ⊆ Σ11 -Krom, we will show that V 1 -KROM extends V 0 :
Lemma IX.6.22. V 0 ⊆ V 1 -KROM.
First we prove:
Lemma IX.6.23. V 1 -KROM proves the multiple comprehension axioms
(see Lemma V.4.25) for quantiﬁer-free formulas.
Proof. We have to show that V 1 -KROM proves
∃X ≤ y1 , . . . , yk ∀z1 < y1 . . . ∀zk < yk (X (z1 , . . . , zk ) ↔ ϕ(z1 , . . . , zk ))
(301)
for any quantiﬁer-free formula ϕ.
A ﬁrst attempt to prove this lemma might be to show that


V 1 -KROM  ∃X ≤ y∀x < y X (x) ↔ ∃z < y(x = z ∧ ϕ(z)) .
However, ∃z < y(x = z ∧ ϕ(z)) is not a Σ11 -Krom formula.
Here we prove (301) using Σ11 -Krom-COMP as follows. Let X satisfy:



∃X ≤ y∀x < y X (x) ↔ ∃P∀z < y (P(z) ↔ ϕ(z)) ∧ P(x) .
It is straightforward to verify that such X also satisﬁes (301).
2
Proof of Lemma IX.6.22. We prove the lemma by showing that
V 1 -KROM proves the multiple comprehension axiom for any ΣB0 formula ϕ. The proof is by structural induction on ϕ. Assume without loss
of generality that ϕ is in prenex form.

347

IX.6. Theories for NL and L

The base case, where ϕ is a quantiﬁer-free formula, follows from the
lemma above because a quantiﬁer-free formula is also in Σ11 -Krom.
For the induction step, suppose that we need to prove
V 1 -KROM  ∃X ≤ a∀x < a, X (x) ↔ ϕ(x).

(302)

First consider the case where ϕ(x) ≡ ∀z < a (x, z). By the induction
hypothesis for ,
V 1 -KROM  ∃X  ≤ a, a∀x < a∀z < a, X  (x, z) ↔

(x, z).

Now we can apply the multiple comprehension axiom for the Σ11 -Krom
formula ∀z < a X  (x, z):
V 1 -KROM  ∃X ≤ a∀x < a, X (x) ↔ ∀z < a X  (x, z).
Such X satisﬁes (302).
Finally suppose that ϕ(x) ≡ ∃z < a (x, z). Let  (x, z) be the prenex
formula equivalent to ¬ (x, z) obtained by pushing the ¬ connective
through the block of quantiﬁers using De Morgan’s laws. By the previous
case
V 1 -KROM  ∃X  ≤ a∀x < a, X  (x) ↔ ∀z < a



(x, z).

Let X be such that
|X | ≤ a ∧ ∀x < a, X (x) ↔ ¬X  (x).
Then X satisﬁes (302).

2

Now we prove the main result of this section. The proof ends with
Exercise IX.6.27 on page 350.
Theorem IX.6.24. V 1 -KROM = VNL.
Proof. First we show that VNL ⊆ V 1 -KROM. By Lemma IX.6.22
above, V 1 -KROM is an extension of V 0 . It remains to show that
V 1 -KROM proves the axiom CONN (Deﬁnition IX.6.5).
The fact that V 1 -KROM extends V 0 also gives us:
Claim. V 1 -KROM proves the multiple comprehension axiom scheme
(Lemma V.4.25) for Σ11 -Krom formulas. For each Σ11 -Krom formula ϕ,
V 1 -KROM proves the comprehension for ¬ϕ.
Recall that in the formula CONN (a, E, Y ) in (292), Y (z, x) holds iﬀ in
the graph G coded by (a, E) there is a path from 0 to x of length ≤ z. The
Σ11 -Krom formula ϕ¬Dist (x1 , x2 , z, a, E) below states that there is no path
from x1 to x2 in G of length ≤ z. The string variable P codes a superset
of the “connectivity to x1 ” relation, i.e.,
if there is a path from x1 to y of length ≤ u then P(u, y) holds.

348

IX. Theories for Small Classes

(P(u, y) might hold even if there is no x1 y path of length ≤ u.)
ϕ¬Dist (x1 , x2 , z, a, E) ≡ ∃P∀u < z∀x < a∀y < a
¬P(z, x2 ) ∧ P(0, x1 ) ∧ (P(u, x) ∧ E(x, y) ⊃ P(u + 1, y)).
By the claim above, V 1 -KROM proves the existence of Y such that
∀z < a∀x < a, Y (z, x) ↔ ¬ϕ¬Dist (0, x, z, a, E).
In other words, Y (z, x) holds iﬀ the distance from 0 to x is at most z,
i.e., Y satisﬁes CONN (a, E, Y ) (292). The formal argument is left as an
exercise.
Exercise IX.6.25. Show that
V 1 -KROM  CONN (a, E, Y ).
Now we show that V 1 -KROM ⊆ VNL. Let
(y, x, X ) ≡ ∃P∀z ≤ tϕ(y, z, x, X , P)
be a Σ11 -Krom formula. We need to show that the comprehension axiom
for

is provable in VNL:
VNL  ∃Y ≤ b∀y < b, Y (y) ↔ ∃P∀z ≤ tϕ(y, z, x, X , P).

(303)

The idea is to formalize in VNL the ONLY IF direction in the proof
of Theorem IX.6.18. For a ﬁxed set of values for x, X , for each value of
y < b we consider the propositional formula (300):
v1

vm

y ≡

···
z1 =0

Az1 ,...,zm .

(304)

zm =0

As in the proof of Theorem IX.6.18, ¬∃P∀z ≤ tϕ(y, z, x, X , P) holds
iﬀ y is unsatisﬁable. Let Gy be the graph GK deﬁned in the proof of
Lemma IX.6.19, where K is now y . Thus the vertices of Gy are the
literals of y , and there is an edge from 1 to 2 in Gy iﬀ the clause
1 ⊃ 2
is in y . Note that if the edge (1 , 2 ) is in Gy then so is the edge (¬2 , ¬1 ).
By Exercise IX.6.20 y is unsatisﬁable iﬀ the graph Gy has a directed
cycle containing both  and ¬ for some literal , i.e. iﬀ y contains a set
of clauses of the form
0 ⊃ 1 , 1 ⊃ 2 , . . . , k ⊃ ¬0 , ¬0 ⊃ 1 , 1 ⊃ 2 , . . . , n ⊃ 0 . (305)
Here we need to formalize the proof of this exercise in VNL.
The encoding of Gy by a pair (a(y), E [y] ) can be described by a ΣB0
formula and we omit the details here. It is important that we can check
simultaneously in each Gy whether there is a path from any vertex u to a
vertex v. For this we use the fact that the aggregate function REACH  is
deﬁnable in VNL (Lemma IX.6.7).

349

IX.6. Theories for NL and L
The fact (303) follows from the next lemma:

Lemma IX.6.26. VNL proves that ¬∃P∀z ≤ tϕ(y, z, x, X , P) is equivalent to the statement that Gy contains a path from p to ¬p and a path from
¬p to p for some propositional variable p of y .
It remains to prove the lemma. Argue in VNL: the (⇐=) direction is
straightforward, so consider the (=⇒) direction. We prove the contrapositive. Suppose that Gy does not contain simultaneously a path from p
to ¬p and a path from ¬p to p for any propositional variable p, we will
deﬁne a set of values for the string variables P that satisﬁes
∀z ≤ tϕ(y, z, x, X , P).
It is easy to deﬁne such a set in polytime, however, here we need to
deﬁne it in NL. We will give an NL algorithm that assigns values for the
propositional variables that satisﬁes y . It will be clear that the values
for P deﬁned accordingly satisfy the requirement. Furthermore, it is
straightforward that these arguments can be formalized in VNL.
The algorithm works as follows. First, identify all literals  such that
there is a path from ¬ to  in Gy . Assign  to all such  and all other
literals that are reachable from them. (These are the literals that are forced
to be true.) Note that by the hypothesis, no variable gets conﬂicting truth
value.
Now suppose that
p1 , p 2 , . . . , p n
are the remaining variables. The main part of the algorithm is to assign
truth values to these variables. Let Gy be the induced subgraph of Gy on
the literals
p1 , ¬p1 , p2 , ¬p2 , . . . , pn , ¬pn .
For each literal  let
C () = {  : there is a path from  to   or from   to  in Gy }.
Note that for any literal   , at most one of   , ¬  is in C (). Also,
 ∈ C (  )

iﬀ

  ∈ C ().

Let (see Figure 13 below)
C + () = {} ∪ {  : there is a path from  to   in Gy },
C − () = C () − C + ().
Notice that if 1 ∈ C (2 ) (hence 2 ∈ C (1 )), then
C + (1 ) ∩ C − (2 ) = C − (1 ) ∩ C + (2 ) = ∅.

(306)

350

IX. Theories for Small Classes

.
. . .

.
−

C (p1 )

.

C + (p1 )

p1

Figure 13. C (p1 ) and C − (p1 ), C + (p1 ).
The idea is to select indices i1 ≤ i2 ≤ · · · ≤ in ≤ n (possibly with
repetition) such that

C (pij ). (307)
for every variable p, exactly one of {p, ¬p} is in C =
j

Then we assign  to every literal in

C+ =
C + (pij )
j

and ⊥ to every literal in
C− =



C − (pij ).

j

The condition (307) ensures that every variable get a unique truth value.
Notice that
iﬀ
¬ ∈ C (¬  ).
 ∈ C (  )
The indices i1 , i2 , . . . , in are deﬁned (in parallel) as follows:


ij = min{t : t ≥ j and pt , ¬pt ∈
C (pr ) ∪ C (¬pr ) }.
r<j

Observe that the sequence i1 , i2 , . . . , in is nondecreasing, and if ij < ik ,
then both pik and ¬pik are not in C (pij ) ∪ C (¬pij ), so the observation
(306) guarantees that no literal  belongs to both C + (pij ) and C − (pik ),
or both C − (pij ) and C + (pik ). As a result, no literal  belongs to both
C + and C − . Consequently our truth assignment described above is well
deﬁned.
For any t, the truth value of pt is determined as follows:
• ﬁnd the smallest j such that pt or ¬pt is in C (pij );
• if either pt ∈ C + (pij ) or ¬pt ∈ C − (pij ) then assign pt the value ,
otherwise assign pt ⊥.
To complete the proof of Theorem IX.6.24 we need to show that the truth
assignment above is correct. This is left as an exercise.
2
Exercise IX.6.27. Complete the argument above, i.e.,
(a) show that pi1 , pi2 , . . . , pin satisfy the condition (307), and
(b) show that the truth assignment described above satisﬁes y .

IX.6. Theories for NL and L

351

 and VL. Given a directed graph G whose
IX.6.3. The Theories VL, VL,
vertices have outdegree at most one, and two vertices s, t of G, the PATH
problem is to decide whether there is a path in G from s to t. (So PATH is
the restriction of the st-CONN problem where the graphs have outdegree
 and VL based on the
at most one.) Here we develop the theories VL, VL
fact that PATH is a complete problem for L.
Below, Exercise IX.6.37 shows that our deﬁnition of VL is equivalent
to an earlier deﬁnition given in [113]. Then in Theorem IX.6.38 we show
that VNC 1 is a subtheory of VL.
First we formalize the PATH problem. As before, our “source” s
is always the vertex 0. Recall the function seq(v, P) = (P)v that encodes a sequence of numbers by P (Deﬁnition V.4.31 on page 115). Let
PATH (a, E, P) be the ΣB0 equivalent of
(P)0 = 0 ∧ ∀v < a, E((P)v , (P)v+1 ) ∧ (P)v+1 < a.

(308)

v

Here P codes a path in G starting at 0: (P) is the v-th vertex on the path.
The relation RPATH below is AC 0 -many-one complete for L. Here the
designated “target” vertex t is one.
Theorem IX.6.28. Let
RPATH (a, E) ≡ (∀x < a∃!y < aE(x, y))∧∃P(PATH (a, E, P)∧(P)a = 1).
The relation RPATH is in L, and for every relation R(x, X ) in L there are
AC 0 functions a0 (x, X ), E0 (x, X ) so that
R(x, X ) ↔ RPATH (a0 (x, X ), E0 (x, X )).
Proof Sketch. The fact that RPATH is in L is straightforward. The
second fact can be proved as in Proposition IX.6.3 except for the vertices in
the graph G now have outdegree at most one because the Turing machine
is deterministic.
2
Deﬁnition IX.6.29 (VL). Let PATH be the axiom
Unique(a, E) ⊃ ∃P ≤ a, a PATH (a, E, P)

(309)

where
Unique(a, E) ≡ a = 0 ∧ ∀x < a∃!y < aE(x, y).
VL is the theory over L2A that is axiomatized by PATH and the axioms
of V 0 .
Now consider the function Path with the following deﬁning axiom (see
page 283 for SEQ(a, P)):

Path(a, E) = P ↔ SEQ(a, P) ∧ (Unique(a, E) ∧ PATH (a, E, P)) ∨

(¬Unique(a, E) ∧ |P| = 0) . (310)
It is easy to check that V 0 proves that P is uniquely determined by (a, E)
in this deﬁnition, so by (309) we have

352

IX. Theories for Small Classes

Lemma IX.6.30. The function Path is ΣB1 -deﬁnable in VL.
The proof of the next result is an easier version of the proof of Theorem IX.6.4.
Theorem IX.6.31. FL is closed under AC 0 -reductions.
Corollary IX.6.32. The function Path is complete for FL under AC 0 reductions.
Proof. It is easy to see that Path is in FL and hence by the preceding theorem every function AC 0 -reducible to Path is in FL. The other
direction follows from Theorem IX.6.28.
2
Lemma IX.6.33. The function Path is ΣB1 -deﬁnable in VL, and (166)
(displayed below) is provable in VL(Row, Path, Path ).
∀i < b, Path (b, X, E)[i] = Path((X )i , E [i] ).
Proof. The arguments for Path code b graphs (a0 , E [0] ), . . . ,
(ab−1 , E [b−1] ). By modifying these using ΣB0 -formulas we may assume
that each au has the same value a (set to the maximum of the original
au ) and Unique(a, E [u] ) holds for each u. We need to construct simultaneously in VL the paths P [0] , P [1] , . . . , P [b−1] so that for 0 ≤ u < b, P [u]
satisﬁes PATH (a, E [u] , P [u] ).
Formally we need to prove that the following is a theorem of VL:
∀u < b∀x < a∃!y < a E [u] (x, y) ⊃ ∃P∀u < b (P [u] )0 = 0 ∧
∀v < a (E [u] ((P [u] )v , (P [u] )v+1 ) ∧ (P [u] )v+1 < a).

(311)

We will construct a graph G  encoded by (a  , E  ) that contains a path
Q = Path(a  , E  ) from which we can deﬁne the paths P [0] , . . . , P [b−1] . In
fact, we will deﬁne G  so that Q is just the concatenation of the paths P [u] ,
0 ≤ u < b. More precisely, the nodes of G  are encoded by triples u, v, x
in such a way that if P [u] encodes the path (0, x1 , . . . , xa ), then in Q there
is the sub-path of the form
u, 0, 0, u, 1, x1 , . . . , u, a, xa .
In other words, we will have
(P [u] )v = x
for all nodes u, v, x on the path Q.
Thus we have the following edges in G  (for 0 ≤ u < b):
(u, v, x, u, v + 1, y) ∈ E 

for 0 ≤ v, x, y < a and (x, y) ∈ E [u] ,

(u, a, x, u + 1, 0, 0) ∈ E 

for x < a.

Let a  = b, a, a, then the graph encoded by (a  , E  ) satisﬁes the
hypothesis of PATH. Let Q be the path for this graph. We can prove

IX.6. Theories for NL and L

353

by induction that the (u(a + 1) + v)-th node on the path is of the form
u, v, x:
(Q)u(a+1)+v = u, v, x

for some x, 0 ≤ x < a.

Deﬁne P so that
(P [u] )v = x iﬀ (Q)u(a+1)+v = u, v, x.
It is straightforward to show that each P [u] satisﬁes PATH (a, E [u] ).
2

Now we deﬁne the universal theories VL and VL. For this we need the
function Path which is semantically equal to Path but has as its deﬁning
equation the quantiﬁer-free formula over LFAC 0 which is equivalent over
0
V to the RHS of (310).
 The theory VL
 has vocabulary L c
Deﬁnition IX.6.34 (VL).
VL
 consist of the axioms of V 0 and
= LFAC 0 ∪ {Path }. The axioms of VL
the quantiﬁer-free equivalent of (310).
Deﬁnition IX.6.35 (VL). The vocabulary LFL is the smallest set that
2
contains LVL
c such that for every LA -term t and every quantiﬁer-free
LFL formula ϕ there is a function Fϕ(z),t in LFL with deﬁning axiom (86):
Fϕ(z),t (x, X )(z) ↔ z < t(x, X ) ∧ ϕ(z, x, X ).

(312)

The theory VL has vocabulary LFL and axioms those of LVL
c and (312)
for each function Fϕ(z),t .
We have as corollaries of the results from Section IX.2 the Deﬁnability
 and VL:
Theorems for VL, VL
 or L is LFL and
Corollary IX.6.36. Here either L is L c and T is VL,
T is VL.

VL

(a) A function is in FL iﬀ it is represented by a term in LVL
c . A string
function is in FL iﬀ it is represented by a string function in LFL . A
relation is in L iﬀ it is represented by an open (or a ΣB0 ) formula of L.
(b) Every ΣB1 (L) formula is equivalent in T to a ΣB1 (L2A ) formula.
(c) T proves ΣB0 (L)-COMP, ΣB0 (L)-IND, and ΣB0 (L)-MIN.
 which is in turn a conservative
(d) VL is a conservative extension of VL
extension of VL.
 VL) are precisely functions
(e) The ΣB1 -deﬁnable functions of VL (or VL,
in FL.
 VL) are precisely relations
(f) The ΔB1 -deﬁnable relations of VL (or VL,
in L.
In [113] Zambella introduced the theory ΣB0 -Rec and showed that it
characterizes L. It can be shown to be equivalent to VL. Here ΣB0 -Rec is

354

IX. Theories for Small Classes

deﬁned using the following axiom scheme:
∀w < b∀x < a∃y < a ϕ(w, x, y) ⊃ ∃Z, ∀w < b ϕ(w, (Z)w , (Z)w+1 )
(313)
for all ΣB0 formulas ϕ not involving Z.
Note that our axiom (309) is provable in V 0 from an instance of (313).
So to prove the above equivalence, the main task is to show that (313) is
provable in our theory. To do this, given a, b and the formula ϕ(w, x, y)
we construct the edge relation E of a graph whose nodes are pairs w, x
for w < b and x < a. Then E(w, x, w  , y) iﬀ w  = w + 1 and y is
the smallest number satisfying ϕ(w, x, y). If P is the path guaranteed to
exist by the axiom (309) for VL applied to E, then we can deﬁne Z so if
(P)w = w, x then (Z)w = x, so ϕ(w, (Z)w , (Z)w+1 ) holds.
Exercise IX.6.37. Fill in the details of the above outline to show that
VL proves the axiom scheme (313).
Finally we prove:
Theorem IX.6.38. VNC 1 ⊆ VL.
 is conservative over VL, it suﬃces to show that
Proof. Since VL
 Recall the formula MFV (Deﬁnition IX.5.4. We need
VNC 1 ⊆ VL.
to show that
  MFV.
VL
 a logspace algorithm that evaluates a
The idea is to formalize in VL
balanced Boolean sentence. The algorithm that we consider here makes a
depth-ﬁrst-search traversal on the tree structure of the sentence, skipping
a whole subtree whenever possible (e.g., if A is true then A ∨ B is true, so
we do not have to examine B).
Thus consider a balanced sentence speciﬁed by (a, G, I ) as in Section
IX.5.2. For each 1 ≤ x < a we construct a graph encoded by (ax , E [x] ) so
that the bit Fval(a, G, I )(x) can be obtained from Path(ax , E [x] ). Then by
Lemma IX.6.33 all bits of Fval(a, G, I ) can be obtained simultaneously,
and we are done.
We show how to obtain the bit Fval(a, G, I )(1). Other bits can be
obtained similarly. The graph (a1 , E [1] ) describes a depth-ﬁrst search
traversal in the circuit (a, G) to compute the output of the root. Each
vertex is a (potential) state of the traversal. There is a starting node (vertex
0), and every other vertex is numbered by
x, d, 0 or x, u, v,

where 1 ≤ x < 2a, 0 ≤ v ≤ 1.

Here d = 1 (down) and u = 2 (up) indicate the direction of the traversal.
A vertex x, d, 0 corresponds to the state when the depth-ﬁrst traversal
visits the gate numbered x for the ﬁrst time (so in general it will go
“down”). Similarly, a state x, u, v is when the search visits gate x the

IX.6. Theories for NL and L

355

second time (thus the direction is “up”); by this time the truth value of
the gate is known, and v carries this truth value.
The edges of this graph represent the transition between the states of
the search. The search starts at the root, thus we have the following edge:
(0, 1, d, 0).
When the search visits a gate x for the ﬁrst time, it will travel down along
the left-most branch from x:
(x, d, 0, 2x, d, 0) for 1 ≤ x < a.
And here are the transitions when it reaches the input gates:
(x + a, d, 0, x + a, u, 0)

if ¬I (x), 0 ≤ x < a,

(x + a, d, 0, x + a, u, 1)

if I (x), 0 ≤ x < a.

For an ∨-gate x (i.e., if ¬G(x), where 1 ≤ x < a) notice that the search
in the subtree rooted at x can be completed when (i) either child of x
outputs , or (ii) the right child of x outputs ⊥. Furthermore, if the left
child of x outputs ⊥, then the search continue at the right child. We have
the following transitions:
either child outputs : (2x, u, 1, x, u, 1) and (2x + 1, u, 1, x, u, 1),
the right child outputs ⊥: (2x + 1, u, 0, x, u, 0),
the left child outputs ⊥: (2x, u, 0, 2x + 1, d, 0).
Exercise IX.6.39. Give the transitions for an ∧-gate.
Notice that the graph described so far have outdegree at most 1. To
make the outdegree exactly 1 we can create an extra node and connect
all vertices with outdegree 0 to it. Let the resulting graph be encoded by
(a1 , E [1] ). Note that our traversal does not visit all gates of the circuit
(a, G, I ). But if it does visit a gate, then the gate will be evaluated. In
particular, the output of gate 1 (i.e. Fval(a, G, I )(1)) is
∃w < a1 (Path(a1 , E [1] ))w = 1, u, 1.
Similarly we construct a graph (ax , E [x] ) to evaluate each node x < a
of the circuit (a, G, I ), where now the initial edge is
(0, x, d, 0).

By ΣB0 (VL)-COMP
there is a string Y which uses these values together
with the inputs I to evaluate all the nodes in the circuit.
 that MFV (a, G, I, Y ) holds. This is left as
It remains to prove (in VL)
an exercise.
2
 proves
Exercise IX.6.40. Complete the proof above by showing that VL
MFV (a, G, I, Y ).

356

IX. Theories for Small Classes

IX.6.4. The Theory VLV. Recall the notion of polynomial-bounded
number recursion (pBNR) from Section IX.3.3. We develop the universal
theory VLV using the fact that the function class FL can be characterized
using pBNR. Thus VLV has the same style as VPV. Its vocabulary
contains symbols for all functions in FL. Here their deﬁning axioms are
given using the above fact. First we state the characterization of FL.
Theorem IX.6.41 (Lind). A function is in FL iﬀ it can be obtained by
AC 0 -reduction and pBNR iﬀ it can be obtained from FAC 0 by ﬁnitely many
applications of composition, string comprehension, and pBNR.
Proof Sketch. First, it is easy to see that FAC 0 ⊆ FL and that FL is
closed under composition, string comprehension and pBNR. By Theorem IX.1.7 it remains to show that functions in FL can be obtained from
FAC 0 by AC 0 -reduction and pBNR.
Suppose that F (x, X ) is a function in FL and let M be a logspace
polytime Turing machine that computes F . As in the proof of Propositions IX.6.3 and IX.6.28, the conﬁgurations of M (without the input and
output tape content) are encoded by numbers < t(x, X ) for some number
term bounding the running time of M such that 0 and 1 are respectively
the initial and (the only) accepting conﬁguration.
Since M is deterministic, there is an AC 0 function nextM (z, x, X ) such
that for z < t(x, X ), nextM (z, x, X ) is the next conﬁguration of z if z is a
non-ﬁnal conﬁguration of M, otherwise:

0 if z does not code a conﬁguration of M,
nextM (z, x, X ) =
z if z is a ﬁnal conﬁguration of M, e.g., 1.
Let conf M (y, x, X ) denote the conﬁguration of M at time y. Then we have
conf M (0, x, X ) = 0,
conf M (y + 1, x, X ) = nextM (conf M (y, x, X ), x, X ).
In other words, conf M can be obtained from AC 0 functions by pBNR.
Now the bits of the string F (x, X ) computed by M can be extracted
from the numbers
conf M (0, x, X ), conf M (1, x, X ), . . . , conf M (t(x, X ), x, X ).
First we need to determine the times at which M writes to its output tape.
This can be done using pBNR as well.
Exercise IX.6.42. Deﬁne using pBNR from conf M (y, x, X ) the function
next writeM (y, x, X )
which is the ﬁrst time y  > y such that M writes to its output tape at time
y  . Use this to deﬁne the function writeM (y, x, X ) which is the time at
which M performs the y-th write.

357

IX.6. Theories for NL and L

The bits F (x, X )(y) can be extracted from conf M (writeM (y, x, X ), x,
X ) by some AC 0 functions. Consequently, F can be obtained by AC 0 reduction and pBNR.
2
Deﬁnition IX.6.43 (VLV). The vocabulary LVLV is the smallest set
that contains LFAC 0 such that for every L2A -term t, quantiﬁer-free LVLV formula ϕ, number functions g, h in LVLV , and string function F in LVLV
there are:
• a string function Fϕ(z),t in LVLV with deﬁning axiom (86):
Fϕ(z),t (x, X )(z) ↔ z < t(x, X ) ∧ ϕ(z, x, X );
• a number function ft,g,h with deﬁning axiom
(g < t ⊃ fg,h (0) = g) ∧ (g ≥ t ⊃ fg,h (0) = 0) ∧
(h(y, fg,h (y)) < t ⊃ fg,h (y + 1) = h(y, fg,h (y))) ∧
(h(y, fg,h (y) ≥ t ⊃ fg,h (y + 1) = 0);

(314)

• a number function fF with deﬁning axiom
fF (x, X ) = |F (x, X )|.

(315)

VLV is the theory with vocabulary LVLV and is axiomatized by the axioms
0
of V and (86) for every function Fϕ(z),t , (314) for every function ft,g,h ,
and (315) for every function fF .
The next corollary follows from Theorem IX.6.41.
Corollary IX.6.44. A function is in FL iﬀ it is represented by a term in
LVLV . A relation is in L iﬀ it is represented by an open (or a ΣB0 ) formula
of LVLV .
The following facts can be proved as in Section IX.3.4 and we leave the
proofs as exercises.
Exercise IX.6.45.

(a) Show that VLV proves the axiom schemes

ΣB0 (LVLV )-COMP, ΣB0 (LVLV )-IND, ΣB0 (LVLV )-MIN.
(b) Show that every ΣB1 (LVLV ) formula is equivalent over VLV to a
ΣB1 (L2A ) formula.
Exercise IX.6.46. Show that
(a) A function is in FL iﬀ it is ΣB1 -deﬁnable in VLV.
(b) A relation is in L iﬀ it is ΔB1 -deﬁnable in VLV.
Finally, the relationship between VL and VLV is also left as an exercise.
Exercise IX.6.47. VLV is a universal conservative extension of VL.

358

IX. Theories for Small Classes

IX.7. Open Problems
IX.7.1. Proving Cayley–Hamilton in VNC 2 . One complexity class that
we do not consider here is #L, which can be deﬁned as the set of all
functions countM , where M is a nondeterministic log space Turing machine,
and countM (X ) is the number of accepting computations of M on input
X . This class is especially interesting because the problem of computing
the determinant of integer matrices is complete for GapL [79], where a
function in GapL has the form C1 (X ) − C2 (X ) for C1 , C2 in #L.
If V#L is a theory for #L in the style of this chapter then the ΣB1 deﬁnable functions in V#L would be those that are AC 0 -reducible to #L.
The class of relations ΔB1 -deﬁnable in V#L would be AC 0 (#L), those
relations that are AC 0 -reducible to #L. According to Allender [7] this
class is the #L hierarchy, and it is the union
#L

AC 0 (#L) = L ∪ L#L ∪ L#L ∪ · · · .
AC 0 (#L) can also be characterized as the set of relations AC 0 -reducible
to integer determinants, and since these are in the class FNC 2 it follows
that
AC 0 (#L) ⊆ NC 2 .
It turns out that many standard computational problems in linear algebra
over the ﬁeld of rationals are AC 0 -reducible to #L, such as computing
matrix inverses and solving systems of linear equations. However a major
open question is whether the correctness of these algorithms can be proved
in V#L or VNC 2 or even VNC. These questions are discussed in [104]
in the more general context of linear algebra over arbitrary ﬁelds. There
it is proved that in many cases correctness is equivalent to the Cayley–
Hamilton Theorem (that a matrix satisﬁes its characteristic polynomial).
Hence a major open question is whether VNC 2 proves the Cayley–
Hamilton Theorem (over the ﬁeld of rationals).
A simple matrix identity,
AB = I ⊃ BA = I
is not known to be provable (over the rationals) in VNC 2 , although it
does follow from the Cayley–Hamilton Theorem [104]. The propositional
translation of this identity over the ﬁeld of two elements yields a nice
tautology family that seems to be hard for most of the proof systems
discussed in Chapter X.
?

IX.7.2. VSL and VSL = VL. The class SL consists of languages that
are accepted by a symmetric nondeterministic Turing machines working
in logspace. A nondeterministic Turing machine M is said to be symmetric
iﬀ for any two conﬁgurations c1 , c2 of M:
if c2 is a next conﬁguration of c1 , then c1 is a next conﬁguration of c2 .

IX.7. Open Problems

359

It can be shown that the st-connectivity problem for undirected graph is
AC 0 -many-one complete for SL.
A deterministic Turing machine can be seen as a symmetric nondeterministic Turing machine, so
L ⊆ SL.
Recent breakthrough by Reingold [97] shows that indeed
L = SL.
Before this was shown, the fact that SL = co-SL was established in [85].
The Distance Problem for undirected graph (UDP) is to decide, given
a undirected graph G and two of its vertices s, t and a positive integer d ,
whether the distance between s and t is exactly d . It turns out that UDP
is complete for NL, so the function Conn (Section IX.6.1) restricted to
undirected graphs is complete for NL, hence we cannot use it to deﬁne a
theory for VSL.
Here we deﬁne VSL as follows. Recall the formula PATH (a, E, P) from
(308) (on page 351) which asserts that P encodes a path starting at the
vertex 0 in the graph speciﬁed by (a, E). Let UCONN (a, E, C, P) be the
formula given below that states that C (u) holds iﬀ u is in the transitive
closure of vertex 0, and in that case P [u] encodes a path from 0 to u.


UCONN (a, E, C, P) ≡ C (0)∧∀u < a∀v < a (C (u)∧E(u, v)) ⊃ C (v)


∧ ∀u < a C (u) ⊃ (PATH (a, E, P [u] ) ∧ (P [u] )a = u) .
We need the ΣB0 -formula Symm(a, E), which asserts that the graph
(a, E) is undirected and all nodes have self-loops:
Symm(a, E) ≡ ∀x < a∀y < a, E(x, x) ∧ (E(x, y) ⊃ E(y, x)).
Deﬁnition IX.7.1. VSL is the theory over L2A that is axiomatized by
the axioms of V 0 together with the axiom UCONN:
Symm(a, E) ⊃ ∃C ≤ a∃P ≤ a, a, a UCONN (a, E, C, P).
The fact that the functions ΣB1 -deﬁnable of VSL are exactly functions in
FSL can be proved using the fact that the relation RUCONN deﬁned below
is complete for SL. Let RUCONN be the following relation
RUCONN (a, E) ↔ Symm(a, E) ∧



∃C ≤ a∃P ≤ a, a, a UCONN (a, E, C, P) ∧ C (1) .

Exercise IX.7.2. Show that the relation RUCONN above is complete
for SL.
Exercise IX.7.3. Develop universal conservative extensions VSL and

 and show that their ΣB -deﬁnable
VSL of VSL (in the style of VC and VC)
1
functions are precisely the functions in FSL.

360

IX. Theories for Small Classes

Exercise IX.7.4. Show that VL ⊆ VSL.
Despite the fact [97] that SL = L, it is an open question whether the
corresponding theories are the same.
Open Problem IX.7.5. Is VSL = VL?
IX.7.3. Deﬁning X/Y  in VTC 0 . The string division function X/Y 
(or also X ÷ Y ) is deﬁned so that
X/Y  × Y ≤ X < S(X/Y ) × Y

(316)

where S is the string successor function (Example V.4.17). Exercise VI.2.8
shows that X/Y  is ΣB1 -deﬁnable in V 1 by formalizing in V 1 a polytime
algorithm that computes X/Y .
A breakthrough result by Hesse et. al. [55] shows that this function is
computable in TC 0 . However, it has been an open problem whether this
algorithm can be formalized and proved correct in the theory VTC 0 .
Open Problem IX.7.6. Is the function X/Y  with deﬁning axiom
0
(316) ΣB1 -deﬁnable in VTC ?
IX.7.4. Proving PHP and Countm in V 0 (m). Recall the Modulo m
Counting Principle Countm from Sections IX.4.3 and IX.4.7. Exercise IX.4.38 (b) shows that V 0 (m) proves Countm whenever m and m 
share a common nontrivial divisor. However, we do not know whether
the same is true if the gcd(m, m  ) = 1.
Open Problem IX.7.7. Let m, m  ∈ N, m, m  ≥ 2, gcd(m, m  ) = 1.
Does V 0 (m)  Countm (a, X )?
We also know that V 0 (m) proves OPHP, but not whether V 0 (m)
proves PHP:
Open Problem IX.7.8. Let m ∈ N, m ≥ 2. Does V 0 (m)  PHP?

IX.8. Notes
The string comprehension operation (Deﬁnition IX.1.6) can be seen
as a two-sorted version of the concatenation recursion on notation (CRN)
operation for single-sorted classes [36].
The families VC and VC (Sections IX.2.1 and IX.2.3) are from [83].
 are new.
The theories VC
The number recursion operations (in Theorems IX.3.12, IX.4.15,
IX.4.42, IX.5.21 and IX.6.41) are from [82] and are based on previous
work of Lind [77] (for FL) and Clote and Takeuti’s [38] (for FAC 0 (2),
FAC 0 (6) and FNC 1 ). The characterizations in [38] go back to [89] (for

IX.8. Notes

361

FAC 0 (2) and FAC 0 (6)) and [9] (for FNC 1 ). The proof of the Theorems
IX.4.42 and IX.5.21 can be found in [82].
Various problems computable in TC 0 are discussed in [32, 55].
The descriptive complexity characterizations of TC 0 , AC 0 (m) (Sections IX.3.1, IX.4.1) are from [10], and Grädel’s characterization of NL
by second-order logic (Section IX.6.2) is in [53].
Section IX.3.5 (proving the Pigeonhole Principle in VTC 0 ) formalizes
a “folklore” fact that the PHP can be proved using counting, and was
inspired by Buss’s proof of the PHP in the Frege proof system [21]. Section IX.3.6 (deﬁning X × Y in VTC 0 ) is based on [18, 32].
Regarding the relationships between PHP, OPHP and the modulo
counting principles Countm (Sections IX.4.3 IX.4.7) it follows from [99]
that V 0 does not prove the implications OPHP ⊃ PHP and Countm ⊃
PHP (for 2 ≤ m ∈ N). These unprovability results come from superpolynomial lower bounds for constant-depth Frege systems augmented
with appropriate axioms, as shown in Corollary IX.4.9 (see also [98] for
other lower bounds). These superpolynomial lower bounds (as well as
that of Theorems IX.4.39, IX.4.11 and IX.4.6) have been improved to
exponential lower bounds in [12, 14].
The proof of the Discrete Jordan Curve Theorem (Section IX.4.5) is
from [84] which contains also the more complicated proof of the sequence
version of JCT in V 0 .
The theory VNC 1 (Section IX.5.3) was ﬁrst deﬁned in [45] and is based
on Arai’s theory AID [8]. The current axiomatization is from [82]. Both
VNC 1 and AID are based on Buss’s Theorem that the Boolean Formula
Value Problem is complete for NC 1 [22]. The fact that VTC 0 ⊆ VNC 1
(Section IX.5.4) is based on [21]. The theory VNC 1 V is called VALV in
[82]. It is developed based on Barrington’s Theorem which is from [9]. A
proof of Theorem IX.5.27 can be found in [82].
The theory VNL is from [83] and V 1 -KROM is from [44]. The results
in Section IX.6.2 are from [67]. Immerman–Szelepcsényi Theorem (that
NL is closed under complement) is from [58] and [106]. The theory VL is
from [82]. The equivalent theory ΣB0 -Rec is from [113].

Chapter X

PROOF SYSTEMS AND THE REFLECTION
PRINCIPLE

An association between V i and the proof system Gi (for i ≥ 1) is shown
in Chapter VII by the fact that each bounded theorem of the theory
V i translates into a family of tautologies that have polynomial-size Gi
proofs. Our theories and their associated proof systems are more deeply
connected than as shown by just the propositional translation theorems.
In this chapter we will present some more connections between the proof
systems, their associated theories and the underlying complexity classes.
In general, for each proof system F we study the principle that asserts
that the system is sound, i.e, that formulas that have F -proofs are valid.
This is known as the Reﬂection Principle (RFN) for F . We will show
in this chapter that the theories V i and TV i prove the RNF for their
associated proof systems when the principles are stated for Σqi formulas.
Together with the Propositional Translation Theorems, these show that
the systems Gi and Gi are the strongest systems (for proving Σqi formulas)
whose RFN are provable in the theories V i and TV i , respectively.
A connection between a propositional proof system F and the complexity class C deﬁnable in the theory T associated with F will be seen
by the fact that the Witnessing Problem for F is complete for C. Recall Theorem VII.4.13 which shows that the Witnessing Problem for G1
(and equivalently for eFrege) are solvable by a polytime algorithm. (In
fact here we will formalize this algorithm in V 1 in order to show that
the Σq1 -RFN of G1 is provable in V 1 as mentioned above.) The fact that
the Witnessing Problem for G1 is hard for P can be proved by using the
Proposition Translation Theorem for V 1 and the fact that theorems of V 1
can be proved using the RFN for G1 .
We will also present some connections between subtheories of TV 0 and
their associated proof systems. Here VNC 1 is associated with the sequent
calculus PK introduced in Chapter II in the same way that V 0 is associated
with bounded depth PK or V 1 is associated with eFrege. We prove that
PK is the strongest propositional proof system whose reﬂection principle is provable in VNC 1 . The theory VTC 0 is associated with bounded
363

364

X. Proof Systems and the Reﬂection Principle

depth PTK, the systems that extend bounded depth PK by a new kind of
connective corresponding to the counting gates in TC 0 circuits.
This chapter is organized as follows. We start by formalizing propositional proofs in Section X.1. The formalizations are needed for stating
the Reﬂection Principle. They also enable us to state the Propositional
Translation Theorems as theorem in our theory VTC 0 . In fact we will
prove (in Section X.1.3) the Propositional Translation Theorems for TV i
as a theorem of VTC 0 , and restate various theorems from Chapter VII
this way. The RFN and Witnessing Problems for Gi and Gi will be discussed in Section X.2. Finally, in Sections X.3 and X.4 we discuss the
Propositional Translation Theorems for the theories VNC 1 and VTC 0 .

X.1. Formalizing Propositional Translations
Recall (Deﬁnition VII.1.2) that a proof system is deﬁned to be a polytime, surjective function:
F : {0, 1}∗ −→ TAUT.
It turns out that all proof systems that we have discussed are TC0 functions.
This is because for these systems, to compute F (X ) the main task is often
to verify whether X is a legitimate proof. The veriﬁcation in turn consists
of recognizing (quantiﬁed) propositional formulas, sequents and proofs.
The recognition can be done using counting gates, for example, to check
that parentheses are properly nested in formulas, or that inference rules are
properly applied in a proof. Therefore the property of being a legitimate
proof (or formula, or sequent) is a TC 0 relation.
Verifying proofs in polytime is often straightforward and therefore omitted. However, to show that it can be done in TC 0 is less straightforward.
So in Section X.1.1 below we will carry this out in some detail. Recall
(Section IX.3.2) that a relation is in TC 0 iﬀ it is ΔB1 -deﬁnable in VTC 0 , iﬀ
it is represented by an open LFTC 0 formula, and iﬀ it is represented by a
ΣB0 (LFTC 0 ) formula (Theorem IX.3.7).
The propositional translations of LK 2 proofs from Chapter VII produce
uniform propositional proofs. In fact, in Section X.1.2 we will show that
these translations are computable by TC 0 functions, and the propositional
translation theorems are theorems of VTC 0 .
Then in Section X.1.3 we will prove the Propositional Translation Theorem for TV i . Following the discussion from the previous section, we will
show that this is also a theorem of VTC 0 .
X.1.1. Verifying Proofs in TC 0 . We will consider proofs of G. Other
systems can be handled in similar way or with minor modiﬁcations. Recall
the deﬁnition of G from Section VII.3. First we present a simple encoding

X.1. Formalizing Propositional Translations

365

of proofs in our two-sorted vocabulary L2A . The pairing function (Example V.4.20) can be used to avoid using deliminators for sequents in a proof
or formulas in a cedent.
Let
 = S , S−1 , . . . , S1 , S0
be a proof in G where S0 is the end sequent. A simple way of present
 in our two-sorted vocabulary is to view it as an array whose rows  [i]
encode the sequents Si . To simplify our veriﬁcation [i] will also contain
the indices of all parents of Si . Thus, we let
[i] = j, k, Si 

(317)

where either j = k = 0 or j > i ∧ k = 0 or j > i ∧ k > i. Here j, k are
indices of the parents of Si (if a parent is not present, the corresponding
index is 0). Also, j, k is the pairing function from Example V.4.20, and
x, Y  is the pairing function from Deﬁnition VIII.7.2.
The number of sequents in  can be easily extracted from . We will
require that every sequent except for the end sequent is used at least once.
This can be checked by stating that for all j, where 0 < j ≤ , there exists
i < j such that [i] has the form
j, k, Si 

or

k, j, Si 

(for some k).
Verifying that the rules are properly applied in  will be discussed in the
proof of Lemma X.1.5 below. Now we brieﬂy discuss the other ingredients
of a proof, i.e., sequents and formulas. A sequent S is encoded as two
arrays S [0] and S [1] that encode its antecedent and succedent, respectively.
For example, S [0] is ∅ if the antecedent is empty; otherwise S [0,0] encodes
the ﬁrst formula of the antecedent, etc.
Next, assume that all propositional variables are either xk (bound variables) or pk (free variables), for k ≥ 0. Using the letters x and p, these can
be written respectively as x11 . . . 1 and p11 . . . 1 with k 1’s in each string
(when k = 0 the strings are just x and p, respectively). Thus quantiﬁed
propositional formulas are written as strings over the alphabet
{, ⊥, p, x, 1, (, ), ∧, ∨, ¬, ∃, ∀}.

(318)

(Note that we use unary notation for writing the indices of variables. For
a propositional formula of size n there are at most n variables and their
indices are at most n.)
We will encode a string S over (318) by a binary string X in such a way
that the i-th symbol X [i] of S can be easily (in AC 0 ) extracted from X .
The exact encoding is not important; for example each symbol in (318)
can be encoded by a ﬁve-bit string with high-order bit 1, and X could be
the concatenation of the codes for the symbols in S. Formal proofs for
most of the results below are straightforward but at the same time tedious.

366

X. Proof Systems and the Reﬂection Principle

So our arguments will often be informal or sketched. Interested readers
are encouraged to carry out the proofs in detail themselves.
Our TC 0 algorithm for recognizing formulas requires the following
notion.
Notation. The outside pair of parentheses in a string “(Z)” over the
vocabulary (318) is said to match if Z contains the same number of left
and right parentheses, and every initial segment of Z contains at least as
many left parentheses as right parentheses.
Notation. A string over the vocabulary (318) is called a pseudo formula
if it has the form
¬
. . ¬ Q1 x 11
. . . 1 ¬
. . ¬ Q2 x 11
. . . 1 . . . Qk x 11
. . . 1 ¬
. . ¬ Y
 .
 
 .
 
 
 .
n1

i1

n2

i2

ik

(319)

nk+1

where Qj ∈ {∃, ∀} for 1 ≤ j ≤ k; k, n1 , n2 , . . . , nk+1 , i1 , i2 , . . . , ik ≥ 0 (i.e.,
the string preceding Y might be empty); and the substring Y satisﬁes the
condition:
1) either Y is one of the following strings:
,

⊥,

p 11
. . . 1,
 

x 11
. . . 1
 





(for some  ≥ 0),
2) or Y has the form “(Z)” where the indicated pair of parentheses
match.
Note that any formula is also a pseudo formula.
Notation. For a string s0 s1 . . . sn over the vocabulary in (318) that is
encoded by an L2A string (i.e., set) X , we use X [i] for the symbols si , for
0 ≤ i ≤ n. Also for i ≤ j, let X [i, j] denotes the substring of X that
consists of the symbols X [i], X [i + 1], . . . , X [j].
The next lemma implies that there is a TC 0 algorithm that accepts
precisely proper encodings of formulas.
Lemma X.1.1. A string X over the alphabet (318) is a formula iﬀ it is a
pseudo formula, and
• for every substring of X the form “(S)” where the indicated parentheses
are matched, S has the form Y ∧ Z or Y ∨ Z, where Y and Z are
pseudo formulas; and
• every maximal substring of X of the form x11 . . . 1 (with s 1’s) is
contained in a pseudo formula of the form (319) where ij = s for
some j.
Proof. See the deﬁnition of formula given in Section VII.3. The second
condition in the lemma ensures that every variable beginning with x is
quantiﬁed. That every formula satisﬁes the two conditions is proved

X.1. Formalizing Propositional Translations

367

by induction on the length of the formula. The converse is proved by
induction on the length of X .
2
Deﬁnition X.1.2. For a proof system F let FLAF (X ) denote the property that X encodes a formula in F. Let PRF F (, X ) hold iﬀ the string
 encodes an F -proof of the formula X . (We will omit the subscript F
when it is clear from context.)
It follows from Lemma X.1.5 that for G and its subsystems the above
predicates FLA and PRF F are in TC 0 . The more general treatment below
will be useful for later results.
In general, a proof system is a polytime function, and hence it is ΣB1 deﬁnable in TV 0 and its graph PRF F (, X ) is ΔB1 -deﬁnable in TV 0 (see
Chapter VIII). Here we are interested in formulas of special forms that
represent PRF F (, X ) and FLAF (X ). These forms will be useful for
our proof of Lemma X.1.7 and several results in Section X.2.2. Recall
(Section VIII.3.2) that for each ΣB0 formula ϕ(y, x, X , Y ) the BIT-REC
axiom for ϕ is deﬁned using the ΣB0 formula
ϕ rec (y, x, X , Y ) ≡ ∀i < y(Y (i) ↔ ϕ(i, x, X , Y <i )).
(The notation Y <i stands for Cut(i, Y ) and is deﬁned in (97) on page
139.) For the exercise below, the idea is that the formula
ϕ rec (t + 1, x, X , Y )
states that Y encodes a polytime computation for the relation R(x, X ),
and the bit Y (t) is the “check bit”: Y (t) is true iﬀ R(x, X ) holds. (Note
also that for strings Y of length |Y | ≤ t + 1, Y (t) ↔ |Y | = t + 1.)
Exercise X.1.3. Show that a relation R(x, X ) is in P iﬀ there are a
ΣB0 formula ϕ(y, x, X , Z) and an L2A term t(x, X ) so that both formulas
below represent R:



ϕ1 (x, X ) ≡ ∃Y ≤ t + 1 ϕ rec (t + 1, x, X , Y ) ∧ Y (t) ,


ϕ2 (x, X ) ≡ ∀Y ≤ t + 1 ϕ rec (t + 1, x, X , Y ) ⊃ Y (t)

(320)
(321)

and that
TV 0  ϕ1 (x, X ) ↔ ϕ2 (x, X ).
Thus for each proof system F there are a ΣB0 formula ϕF (y, , X, Y )
and a term tF (, X ) such that
 rec

(tF + 1, , X, Y ) ∧ Y (tF ) ,
(322)
Prf ΣF (, X ) ≡ ∃Y ≤ tF + 1 ϕF
 rec

Π
Prf F (, X ) ≡ ∀Y ≤ tF + 1 ϕF (tF + 1, , X, Y ) ⊃ Y (tF )
(323)
both represent PRF F (, X ) and
TV 0  Prf ΣF (, X ) ↔ Prf Π
F (, X ).

(324)

368

X. Proof Systems and the Reﬂection Principle

(Lemma X.1.5 below shows that for the case of G and its subsystems,
the theory TV 0 can be replaced by VTC 0 . This fact will be useful, for
example, for Theorem X.2.23.)
We are also interested in similar formulas that represent the FLA relation.
Corollary X.1.4. There is an open LFTC 0 formula (X ) that represents
FLAG (X ). The relation FLAG (X ) is ΔB1 -deﬁnable in VTC 0 . Moreover,
there are a ΣB0 formula ϕFLA (y, X, Y ) and an L2A term tFLA such that both
formulas FlaΣ (X ) and FlaΠ (X ) below represent FLAG (X ) and VTC 0 
FlaΣ (X ) ↔ FlaΠ (X ):
 rec

(tFLA + 1, X, Y ) ∧ Y (tFLA ) , (325)
FlaΣ (X ) ≡ ∃Y ≤ tFLA + 1 ϕFLA
 rec

FlaΠ (X ) ≡ ∀Y ≤ tFLA + 1 ϕFLA
(tFLA + 1, X, Y ) ⊃ Y (tFLA ) . (326)
Proof sketch. The open LFTC 0 formula (X ) expresses the conditions
listed in Lemma X.1.1.
To prove the existences of the formulas FlaΣ and FlaΠ as required, it

B
is easier to start with a ΣB0 (LVTC
0 ) (i.e., Σ0 (Numones )) formula (X )
that is equivalent to the above open LFTC 0 formula (X ) (see Theorem IX.3.7). The idea is to successively remove the occurrences of
Numones in  using the axiom NUMONES (which can be used as a
deﬁning axiom for Numones ). Note that NUMONES is already an instance of ΣB0 -BIT-REC.
2
Now we show that for the subsystems of G in (324) we can use VTC 0
instead of TV 0 .
Lemma X.1.5. For each proof system F that we have discussed (e.g., G,
Gi , Gi , eFrege, etc.) there are a ΣB0 formula ϕF and an L2A term tF so
that the formulas Prf ΣF (, X ) and Prf Π
F (, X ) as in (322) and (323) both
represent the relation PRF F (, X ), and such that
VTC 0  Prf ΣF (, X ) ↔ Prf Π
F (, X ).
Proof sketch of Lemma X.1.5. We will argue for G. The arguments
for other proof systems F are similar.
First we sketch a TC 0 algorithm that veriﬁes that (i)  properly encodes
a proof, and (ii) the last sequent in  is
−→ X.
In fact, it can be shown that there is a ΣB0 (LFTC 0 ) formula  (, X ) that is
true iﬀ the algorithm accepts (, X ). Therefore, as in Corollary X.1.4, it
is straightforward to obtain Prf ΣF and Prf Π
F as desired.
Verifying (ii) is straightforward. For (i) note that by our encoding of
proofs, the i-th sequent in  can be easily extracted from , see (317). So
ﬁrst we check that each row [i] of  is of the form (317) where Si consists
of two lists of formulas Si[0] and Si[1] . Next, it remains to verify locally

X.1. Formalizing Propositional Translations

369

that for each i, either Si is an axiom and j = k = 0, or Si follows from
sequent(s) Sj (and Sk ) by an inference rule.
Verifying that Si is an axiom is straightforward. Now consider the case
where Si follows from Sj by the ∃-left rule; other rules are similar or easier.
This case can be checked by
1) verifying that Sj and Si are identical except for Sj contains a formula
of the form A(pk ) and Si contains a formula of the form ∃xt A(xt )
at the same location in the antecedent,
2) verifying that pk does not occur in Si .
It is easy to see that task 2) can be done by an AC 0 algorithm. For (1) we
ﬁrst need to identify the scope of the existential quantiﬁer ∃xt : this is the
smallest pseudo formula that contain ∃xt (see Lemma X.1.1). Then we
need to check that all occurrences of pk have been properly replaced by xt .
For this the counting gates are used, for example, to count the number of
occurrences of pk and xt in subformulas of A(pk ) and A(xt ), respectively.
For treelike proofs (e.g., Gi ) we have to verify in addition that every
sequent is used at most once. For this we simply check that all nonzero
indices j, k as in (317) appear at most once.
2
Now we show that the polytime algorithms for recognizing formulas
and proofs translate into polytime algorithms for generating G0 proofs
verifying that formulas are formulas and proofs are proofs. We need the
following notation.
Deﬁnition X.1.6. For an L2A formula ϕ(X ) that might contain other
free variables and a constant string X0 we use
ϕ(X0 )[ ]
to denote the propositional formula that is obtained from the translation
ϕ(X )[n], where n = |X0 |, by plugging the values (, ⊥) of the bits X0 (j)
for pjX .
(Thus if X is the only free variable in ϕ(X ), then ϕ(X0 )[ ] is a sentence.)
Recall the propositional translation given in Sections VII.2 and VII.5.
Lemma X.1.7. Let F be a proof system with deﬁning formulas as in (322)
and (323). Then there is a polytime algorithm that, given a string X0 that
encodes a formula A and a string 0 that encodes an F -proof of A, outputs
G0 proofs of the following sequents:
−→ FlaΣ (X0 )[ ],

(327)

Π

−→ Fla (X0 )[ ],

(328)

−→ Prf ΣF (0 , X0 )[ ],
−→ Prf Π
F (0 , X0 )[ ].

(329)

For the proof we need the following:

(330)

370

X. Proof Systems and the Reﬂection Principle

Exercise X.1.8. Show that there is a polytime algorithm that, given a
Boolean sentence A, outputs a cut-free PK  proof of −→ A if A is true
and A −→ if A is false. Use induction on A to show the existence of the
proofs.
Proof of Lemma X.1.7. First we give a G0 proof of (327). The idea is
to use a polytime algorithm that, given X0 , computes the (unique) string
Y0 of length n = val(tFLA + 1) that witnesses Y in FlaΣ (X0 ) (see (325)).
Then by Exercise X.1.8 we can generate a cut-free PK  of


rec
(tFLA + 1, X0 , Y0 ) ∧ Y0 (tFLA )) [ ].
−→ |Y0 | ≤ tFLA + 1 ∧ (ϕFLA
Finally (327) can be derived by a series of applications of the ∃-right rule.
Formally, let m = |X0 |. By deﬁnition FlaΣ (X )[m] is the translation of
rec
∃Y ≤ tFLA + 1(ϕFLA
(tFLA + 1, X, Y ) ∧ Y (tFLA )).

Let r = tFLA (m). First we translate
rec
ϕFLA
(tFLA + 1, X, Y ) ∧ Y (tFLA )

(331)

for X of length m and each Y of length k ≤ r + 1. Note that when
k = r + 1, Y (tFLA ) translates into  and hence (331) translates into
rec
ϕFLA
(tFLA + 1, X, Y )[m, r + 1].

On the other hand, for k ≤ r, Y (tFLA ) translates into ⊥ and therefore
(331) also translates into ⊥. As a result, FlaΣ (X )[m] is

 rec
Y
∃p0Y ∃p1Y . . . ∃pr−1
ϕFLA (tFLA + 1, X, Y )[m, r + 1] .
So, as outlined above, ﬁrst we compute in polytime the unique Y0 that
rec
satisﬁes |Y0 | ≤ r + 1 and ϕFLA
(tFLA + 1, X0 , Y0 ) ∧ Y0 (tFLA ). Then we
derive the following sequent as in Exercise X.1.8:
rec
(tFLA + 1, X0 , Y0 )[ ].
ϕFLA

The sequent −→ FlaΣ (X0 )[ ] can now be obtained by applying the ∃ right
rule r times.
Now we construct a G0 proof of (328). It will be clear that our construction can be done in polynomial time. As above let m = |X0 | and
r = tFLA (m). By deﬁnition FlaΠ (X0 )[ ] is
r+1
Y
∀p0Y ∀p1Y . . . ∀pr−1

 rec

ϕFLA (tFLA + 1, X0 , Y ) ⊃ Y (tFLA ) [k].

k=0


So we will give a PK proof of the following sequent
r+1

−→


rec
(tFLA + 1, X0 , Y ) ⊃ Y (tFLA ) [k].
ϕFLA



(332)

k=0

The G0 proof of (328) is then obtained by applying the ∀-right rule r
times.

X.1. Formalizing Propositional Translations

371

When k = r + 1 the atom Y (tFLA ) translates into , so
 rec

ϕFLA (tFLA + 1, X0 , Y ) ⊃ Y (tFLA ) [r + 1]
is  and hence is deleted from the conjunction. For k ≤ r the atom
Y (tFLA ) translates into ⊥ and hence
 rec

ϕFLA (tFLA + 1, X0 , Y ) ⊃ Y (tFLA ) [k]
is

 rec

¬ ϕFLA
(tFLA + 1, X0 , Y )[k] .

Consequently (332) is
 rec

¬ ϕFLA
(tFLA + 1, X0 , Y )[k] .

r

−→
k=0

Intuitively the above sequent is valid because any string Y that satisﬁes
rec
ϕFLA
(tFLA +1, X0 , Y ) must have length exactly r +1. To derive the sequent
we need to derive the following sequents (for k ≤ r):
rec
(tFLA + 1, X0 , Y )[k] −→ .
ϕFLA

Recall that
rec
ϕFLA
(tFLA + 1, X0 , Y ) ≡ ∀i ≤ tFLA (Y (i) ↔ ϕFLA (i, X0 , Y <i )).

Therefore
r
rec
ϕFLA
(tFLA + 1, X0 , Y )[k] ≡




(Y (i) ↔ ϕFLA (i, X0 , Y <i ))[k] .

i=0

It suﬃces to construct, for each k ≤ r, a PK  proof of the following
sequent:
(Y (0) ↔ ϕFLA (i, X0 , Y <0 ))[k], (Y (1) ↔ ϕFLA (i, X0 , Y <1 ))[k], . . . ,
(Y (r) ↔ ϕFLA (i, X0 , Y <r ))[k] −→ . (333)
Suppose that k = 0, then Y (i)[0] is ⊥, and ϕFLA (i, X0 , Y <i ))[0] is a
sentence Bi , for 0 ≤ i ≤ r. Therefore the sequent (333) becomes
¬B0 , ¬B1 , . . . , ¬Br −→ .
Since X0 encodes a formula, at least one of the sentences Bi must be true
rec
(otherwise Y = ∅ will satisfy ϕFLA
(tFLA + 1, X0 , Y )). Moreover, such a
Bi can be found in polytime. It follows from Exercise X.1.8 that the above
sequent has a polynomial size PK  proof that is computable in polynomial
time.

372

X. Proof Systems and the Reﬂection Principle

The case k = 1 is similar. Now consider the case 1 < k ≤ r. We will
write pi for the variables piY , for i ≥ 0. Recall that
⎧
⎪
⎨pi if i < k − 1,
Y (i)[k] =def  if i = k − 1,
⎪
⎩
⊥ if i > k − 1
and ϕFLA (i, X0 , Y <i ))[k] has the form
⎧
⎪
⎨B0
ϕFLA (i, X0 , Y <i ))[k] = Bi (p0 , . . . , pi−1 )
⎪
⎩
Bi (p0 , . . . , pk−2 )

if i = 0,
if 1 ≤ i < k,
if k ≤ i ≤ r

for some formulas Bi with all free variables displayed (in particular, B0 is
a sentence). The sequent (333) becomes
p0 ↔ B0 , p1 ↔ B1 (p0 ), . . . , pk−2 ↔ Bk−2 (p0 , . . . , pk−3 ),
Bk−1 (p), ¬Bk (p), . . . , ¬Br (p) −→

(334)

(here p = p0 , p1 , . . . , pk−2 ). Compute inductively in polytime the Boolean
values b0 of B0 , b1 of B1 (b0 ), . . . , bk−2 of Bk−2 (b0 , . . . , bk−3 ). Then we
can construct PK  proofs of the following sequents:
p0 ↔ B0 −→ p0 ↔ b0 ,
p1 ↔ B1 (p0 ), p0 ↔ b0 −→ p1 ↔ b1 ,
...
pk−2 ↔ Bk−2 (p0 , . . . , pk−3 ), p0 ↔ b0 , . . . , pk−3 ↔ bk−3 −→ pk−2 ↔ bk−2 ,
Bk−1 (p), p0 ↔ b0 , . . . , pk−2 ↔ bk−2 −→ Bk−1 (b),
¬Bk (p), p0 ↔ b0 , . . . , pk−2 ↔ bk−2 −→ ¬Bk (b),
...
¬Br (p), p0 ↔ b0 , . . . , pk−2 ↔ bk−2 −→ ¬Br (b).
Argue as in previous cases, at least one of the sentences
Bk−1 (b), ¬Bk (b), . . . , ¬Br (b)
must have value ⊥, and such a sentence can be found in polynomial time.
Using Exercise X.1.8 we can now compute a PK  proof of the sequent
(334). This completes our argument for the sequent (328).
Deriving (329) and (330) is similar.
2
The formulas FlaΣ , FlaΠ , Prf ΣF and Prf Π
F are important for this chapter.
They will be used to deﬁne the Reﬂection Principle (Deﬁnition X.2.11).
Note that
V 0  ∀X (FlaΣ (X ) ⊃ FlaΠ (X ))

X.1. Formalizing Propositional Translations

373

and (by Y -IND on the string Y in (323)):
V 0  ∀∀X (Prf ΣF (, X ) ⊃ Prf Π
F (, X )).
We also use FlaΣ and Prf ΣF for the following notions.
Deﬁnition X.1.9. Let F (n) be a function in the vocabulary L of a
theory T . Suppose that F (n) is the encoding of a formula An , for all n.
We say that F provably in T computes An if
T  ∀nFlaΣ (F (n)).

(335)

Similarly we say that a function G(n) provably in T computes an F -proof
n ) if G(n) = n for all n, and
n of a formula An (encoded by A
n ).
T  ∀nPrf ΣF (G(n), A

(336)

In these cases we also say that the formulas An (resp. proofs n ) are
provably in T computable by F (resp. G), or just provably computable in T .
We will often view a formula A as a tree whose leaves are labeled with
the constants , ⊥ or atomic subformulas pk , xk , and whose inner nodes
are labeled with the Boolean connectives or quantiﬁers. Then all paths
from the root to the leaves can be identiﬁed as follows. For each leaf B
of the tree we can identify all pseudo formulas that contain B. Then it
can be shown that these pseudo formulas are indeed all subformulas of A
that contain B, and hence they form the path from the root of A to B.
For this path, using the counting gates we can compute, for example, the
alternation depths of quantiﬁers or connectives. It follows in particular
that there is a TC 0 number function, called qdepth, that computes the
maximum alternation depth of quantiﬁers in X .
Some basic properties of proofs can be proved as theorems of our
theories. We leave these as exercises.
Exercise X.1.10. Show that VTC 0 proves the subformula property of
Gi proofs: If  is a Gi proof of a formula A, then all formulas in  are
either in (Σqi ∪ Πqi ) or a subformula of A.
Exercise X.1.11. Recall the notion of free variable normal form proofs
from Section II.2.4. Show that there is a polytime function G so that for
every treelike proof , G() is provably in VPV (Deﬁnition VIII.2.2) a
treelike proof in free variable normal form of the same endsequent. (Hint:
we need to ﬁnd all paths in .)
X.1.2. Computing Propositional Translations in TC 0. Recall from Chapter VII (Sections VII.2 and VII.5) that each bounded L2A formula ϕ(x, X )
is translated into a family #ϕ# of propositional formulas ϕ(x, X )[m; n],
for m, n ∈ N. Each formula ϕ(x, X )[m; n] is obtained from ϕ(x, X ) by
substituting the numerals m for x and introducing for each string variable

374

X. Proof Systems and the Reﬂection Principle

X of intended length n the propositional variables piX that represent the
bits X (i) of X (for 0 ≤ i < n − 1).
In general the family #ϕ# involves bound variables
p0X , p1X , . . .

p0Y , p1Y , . . .

etc.

p0α , p1α , . . .

p0 , p1 , . . .

etc.

and free variables
Encoding and verifying the formulas in #ϕ# will be as described in Section X.1.1. We assume that the original string variables X, Y, . . . and
α, , . . . have been assigned distinct numbers, and we represent a bound
variable piX by x1 (x followed by a string of 1’s of length ) where
 = i, j and X has number j. Similarly we represent a free variable piα
by p1 .
Following the inductive deﬁnition of the propositional translations
ϕ(x, X )[m; n]
from Sections VII.2.1 and VII.5 we can show that the encoding Y of
ϕ(x, X )[m; n] can be described by a ΣB0 (LFTC 0 ) formula and its length |Y |
can be expressed by some LFTC 0 function tϕ (m, n). For example, suppose
that ϕ is ∃y ≤ t (x, y, X ). Then
ϕ(x, X )[m; n] ≡

v


(x, y, X )[m, i; n]

i=0

(where v = val(t)). Thus,
v

tϕ (m, n) = 3v +

t (m, i, n).
i=0

(3v is the number of parentheses plus the number of occurrences of ∨.)
Lemma X.1.12. For every bounded L2A formula ϕ(x, X ) there is a
(m, n, Y ) and an LFTC 0 function tϕ (m, n) such that
for all m, n and Y , (m, n, Y ) is true iﬀ Y encodes ϕ(x, X )[m; n], and
|Y | = tϕ (m, n) when (m, n, Y ) holds.

ΣB0 (LFTC 0 ) formula

Proof idea. We can prove by structural induction on ϕ the existence
of both (m, n, Y ) and tϕ (m, n), as illustrated above.
2
Notation. For a (quantiﬁed) propositional formula A, we use A" to
denote the string that encodes A.
The next corollary follows easily. (Recall Deﬁnition X.1.9.)
Corollary X.1.13. For every bounded L2A formula ϕ(x, X ) there is an
0
FTC 0 function T (m, n) that provably in VTC computes ϕ(x,
X )[m; n].
ϕ

X.1. Formalizing Propositional Translations

375

0

Moreover, VTC proves the deﬁnitions of the translation given in Sections VII.2.1 and VII.5, such as
T∃y<tϕ(y,X ) (n) = A"
where
A=

v−1


Bi ,

for Bi such that Tϕ(i,X ) (n) = 
Bi

i=0

where v = val(t(n)).
Proof idea. Using the formula
and the function tϕ from Lemma
X.1.12, Tϕ can be deﬁned as follows:


Tϕ(x,X ) (m, n) = Y ↔ |Y | ≤ tϕ (m, n) ∧ (m, n, Y ) .
It is easy to see that Tϕ is in LFTC 0 .
The fact that
0
VTC  FlaΣ (Tϕ (m, n))
0

and that VTC proves the deﬁnitions of the translation as required are
straightforward.
2
In Chapter VII we proved a number of Propositional Translation Theorems of the following form for a theory T and an associated proof system
P: for certain theorems ϕ(x, X ) of T , the families #ϕ# of propositional
tautologies ϕ(x, X )[m; n] have polynomial-size proofs in P. Here we will
strengthen these theorems by showing that the P-proofs of ϕ(x, X )[m; n]
0
are in fact provably in VTC computable by some FTC 0 function Fϕ (m, n)
that depends on ϕ. In Section X.1.3 will prove one more such theorem
for the theories TV i and the proof systems Gi (where i ≥ 1).
Theorem X.1.14 below strengthens Theorem VII.5.6 in the way mentioned above. Here our propositional proofs of ϕ(x, X )[m; n] are computable in TC 0 because they consist of disjoint components each of which
can be computed by a TC 0 function. For example, suppose that S is
a ﬁrst-order sequent that is obtained from the sequent(s) S1 (and S2 ).
Then the propositional proof of S[m; n] is obtained from the propositional proof(s) of S1 [m; n] (and S2 [m; n]) by adding some derivations that
can also be computed in TC 0 .
Theorem X.1.14. Suppose that ϕ(x, X ) is a bounded theorem of V 0 .
Then there is a constant d and an FTC 0 function Fϕ so that provably in
0

VTC , Fϕ (m, n) is a d -G0 proof of ϕ(a, α)[m; n], for all m, n.
Proof Sketch. The constant d will be the same as in Theorem VII.5.6,
and we will follow the proof of Theorem VII.5.6 to construct Fϕ . Let 
be the LK 2 -V 0 proof of ϕ as in the proof of Theorem VII.5.6. For
each sequent S in  we will construct an FTC 0 function FS, (m, n) that

376

X. Proof Systems and the Reﬂection Principle

computes the d -G0 proofs of the translations S[m; n]. Then Fϕ = FS0 ,
for the last sequent S0 of .
For each sequent S, the function FS, (m, n) is obtained by composition
from earlier functions FS1 , , FS2 , (for parents S1 , S2 of S) and some
FTC 0 functions. Therefore it will be straightforward that FS, are in
FTC 0 . Moreover, the fact (336):
0

VTC  ∀m∀nPrf Σ (Fϕ (m, n))
can be proved by verifying at each step that
0

VTC  ∀m∀nPrf Σ (FS, (m, n)).
Exercise VII.5.7 can be strengthened to show that the translations of
formulas in  are provably in VTC 0 computable by FTC 0 functions that
depend only on . Details are left as an exercise (see also Corollary X.1.13
above).
Exercise X.1.15. Show that for each ΣB0 formula (x, X ) in  there is
an FTC 0 function G , (m, n) that depends only on  and that, provably
0

in VTC , computes the translation (x, X )[m; n] of

.

Following the proof of Theorem VII.5.6, it can be shown that there are
TC 0 computable proofs of the tautology (156). This is left as an exercise
(see also Exercise VII.5.3 and Theorem VII.1.8).
*Exercise X.1.16. Suppose that Tϕ (i) is an FTC 0 function that provably in VTC 0 computes the translation ϕ(x)[i] for an ΣB0 formula ϕ(x)
as in Corollary X.1.13. Show that there is an FTC 0 function H () that
0
provably in VTC computes a PK  proof of the sequent




−→

¬Ai , A0 ∧
i=0



¬Ai , A1 ∧
i=1

¬Ai , . . . , A−1 ∧ ¬A , A
i=2

where Ai denotes Tϕ (i). Hint: ﬁrst describe using a ΣB0 (LFTC 0 ) formula a
PK  proof of


−→



¬pi , p0 ∧
i=0



¬pi , p1 ∧
i=1

¬pi , . . . , p−1 ∧ ¬p , p
i=2

then substitute Tϕ (i) for pi .
Now we proceed inductively as in the proof of Theorem VII.5.6. Here
we can show that if S is derived from S1 (and S2 ), then the proof FS, of
S[m; n] can be obtained by compositions from FS1 , (and FS2 , ) and some
2
other FTC 0 functions.
Formalizing the V i Translation Theorem (Theorem VII.5.2) is similar
and is left as an exercise.

377

X.1. Formalizing Propositional Translations

*Exercise X.1.17. Show that for each bounded theorem ϕ(x, X ) of V i
0
there is an FTC 0 function Fϕ (m, n) that, provably in VTC , computes a
Gi -proof of ϕ(x, X )[m; n].
X.1.3. The Propositional Translation Theorem for TV i . Recall the theories TV i from Section VIII.3. Analogous to the V i Translation Theorem
(Theorem VII.5.2) we will show here that theorems of TV i translate into
families of tautologies that have polynomial size Gi proofs. In fact, we
0
will show that provably in VTC these Gi proofs can be computed by
FTC 0 functions that depend only on the theorems of TV i . First we need
the following facts whose proofs are left as exercises. (Recall that A" is the
encoding of a propositional formula A.)
Exercise X.1.18. Let the functions Tϕ(Z) (n) and T (x) (m) be as in
0

Corollary X.1.13, i.e., provably in VTC , Tϕ(Z) (n) computes
Z
) =def ϕ(Z)[n]
A(p0Z , p1Z , . . . , pn−2

and T (x) (m) computes
Bm =def

(x)[m].

Then the formula A(B0 , B1 , . . . , Bn−2 ) is also provably computable in
0
VTC by some FTC 0 function of the form Tϕ  (y) (n).
Below, Exercise X.1.19 formalizes a generalization of Lemma VII.4.11
and Exercise X.1.20 formalizes Lemma VII.4.10 (for our translation formulas ϕ[m; n]).
Exercise X.1.19. Suppose that the FTC 0 functions Tϕ(Z) (n), T 1 (x) (i)
0

and T 2 (x) (i) provably in VTC compute a (quantiﬁed) formula A(p) and
−
→
−
→
quantiﬁer-free formulas Bi1 and Bi2 . Then there is an FTC 0 function that
0
provably in VTC computes G0 proofs of
−
→
−
→
1
2
A(B 1 ), B01 ↔ B02 , . . . , Bn−2
↔ Bn−2
−→ A(B 2 ).
Hint: ﬁrst describe a proof of the sequent by structural induction on A,
then argue that such a proof can actually be computed in parallel.
Exercise X.1.20. Consider a sequent of formulas in (Σqi ∪ Πqi ):
Γ(p), Γ −→ Δ(p), Δ .
0

Suppose that all formulas in this sequent are provably in VTC computable by FTC 0 functions of the form Tϕ(Z) (n). Suppose also that Bj
0

are quantiﬁer-free formulas that are provably in VTC computable by an

378

X. Proof Systems and the Reﬂection Principle
0

FTC 0 function T (x) (j). Then provably in VTC there is a Gi derivation
of the form
Γ(p), Γ −→ Δ(p), Δ
=======
==========
Γ(B), Γ −→ Δ(B ), Δ
Now we prove the main theorem of this section.
Theorem X.1.21 (TV i Propositional Translation). Let i ≥ 1. For each
bounded theorem ϕ(x, X ) of TV i there is an FTC 0 function F (m, n) that,
0
provably in VTC , computes a Gi proof of ϕ(x, X )[m; n], for all m, n ∈ N.
Proof. First we will translate ﬁrst-order proofs of theorems of TV i into
propositional proofs as in Theorems VII.2.3 and VII.5.2. Then we will
0
argue that the propositional proofs can be provably in VTC computed
0
i
by FTC functions that depend on the theorems of TV . We will consider
the case where i = 1; other cases are similar.
Recall that LK 2 -TV 1 (Deﬁnition VIII.5.14) is a complete system for
TV 1 . To simplify our translation we modify the string induction rule
SIND as follows. Let S(X, Y ) be a formula representing the graph of the
string successor function, i.e., the “successor relation” (we redeﬁne the
symbol S used in Example V.4.17 where it denotes the successor function;
the exact meaning is easily understood from context):

S(X, Y ) ≡ ∀i ≤ |X | + |Y |Y (i) ↔ i ≤ |X | ∧


(X (i) ∧ ∃j < i¬X (j)) ∨ (¬X (i) ∧ ∀j < iX (j)) .
Now let ΣB1 -SIND be the rule:
S1
S2

=

Γ, A(α), S(α, ) −→ A( ), Δ
Γ, A(∅) −→ A(), Δ

(337)

In this rule, A is a ΣB1 formula, and α and do not appear in Γ, Δ.
It is straightforward to verify that the modiﬁed LK 2 -TV 1 system is
also complete for TV 1 . (See the discussion for LK 2 -TV 1 following Def 1 in Section VI.4.1.)
inition VIII.5.14 and also the arguments for LK 2 -V
1
In other words, a formula is a theorem of TV if and only if it has an
anchored LK 2 proof where all nonlogical axioms are instances of axioms
of V 0 and instances of the ΣB1 -SIND rule are allowed. (Here a proof is
anchored if the cut formulas are instances of axioms of V 0 or instances of
A(∅) or A() in the bottom sequent of (337).)
Let  be an anchored LK 2 proof of ϕ(x, X ) where the rule (337) is
allowed. For each sequent S(x, X ) in  we will deﬁne the propositional
proofs FS (m, n) for the tautologies S[m; n]. This is done inductively for
all sequents in , starting with the axioms. The base case (where S is an
axiom) and most of the induction step have been dealt with in the proof

X.1. Formalizing Propositional Translations

379

of Theorem VII.5.2 (see also Exercise X.1.17). The only remaining case
for the induction step is the case of the ΣB1 -SIND rule above.
Thus consider an instance of the rule ΣB1 -SIND . Suppressing other
free variables in S1 and S2 , for the lengths , m, n of α, ,  we have
S1 [, m, n] ≡ Γ[n], A(α)[], S(α, )[, m] −→ A( )[m], Δ[n],
S2 [n] ≡ Γ[n], A(∅)[] −→ A()[n], Δ[n].
We need to show that for each n, S2 [n] can be derived from S1 [, m, n]
(for polynomially many values of  and m) by some polynomial size
G1 derivation. (Furthermore, the derivation is computable by an FTC 0
function.)
At ﬁrst sight such a derivation might seem impossible. Informally,
assuming that both Γ and Δ are empty, then S1 allows us to obtain
A(α + 1) from A(α) (here 1 is really the set {0} and + is the string
addition function). So it appears that in order to get A() from A(0) (i.e.,
A(∅)) we need to use S1  times, i.e., we need exponentially many cuts.
Lemma X.1.22 below shows that the number of cuts can be eﬀectively
reduced to just a polynomial in ||, by showing roughly that using S1 we
can obtain A( ) from A(α) for any of length | | = |α| + 1.
Formally we use the following notation:
Notation. Let Sk (X, Y ) be the ΣB0 formula
X ≤ Y ∧ Y ≤ X + {k}.
(Recall that {k}, or also POW2(k), is an AC 0 function deﬁned by {k}(x)
↔ x = k. See Example VIII.3.12.)
Lemma X.1.22. For each ΣB1 formula A(X ) and distinct string variables
0
α, , ,  there is a FTC 0 function H (k, d ) which is provably in VTC a G1
derivation whose nonlogical axioms are from the set
{A(α)[], S(α, )[, m] −→ A( )[m] : , m ≤ d }
and that contains all sequents in the set
{A( )[s], Sk ( , )[s, n] −→ A()[n] : s, n ≤ d }.
Lemma X.1.22 completes the induction step for describing the proofs
FS (m, n) of the translations S[m; n] of sequents S in . It can be veriﬁed
that FS is in FTC 0 when S is an axiom in . When S is derived from
S1 (and S2 ) then as in Theorem X.1.14 and Exercise X.1.17 it can be
shown that FS is obtained by composition from FS1 (and FS2 ) and some
other FTC 0 functions (here we need also the FTC 0 functions from Lemma
0
X.1.22). Thus FS are in FTC 0 for all S in . The fact that VTC proves
that FS (m, n) are proofs of S[m; n] can be proved by induction on the
sequent S.
2

380

X. Proof Systems and the Reﬂection Principle

Proof of lemma X.1.22. First we will describe H (k, d ) simply as a
polynomial-size derivation. The deﬁnition is by induction on k. Then
0
we will argue that H is in fact a FTC 0 function that provably in VTC
computes the desired derivation. From now on we will denote the desired
derivation by
{A(α)[], S(α, )[, m] −→ A( )[m] : , m ≤ d }
=====================================
{A( )[s], Sk ( , )[s, n] −→ A()[n] : s, n ≤ d }

(338)

Consider the base case, k = 0. Note that S0 ( , )[s, n] is false if n < s
or n > s + 1, and in these cases
A( )[s], S0 ( , )[s, n] −→ A()[n]

(339)

can easily be shown to have polynomial size G0 proofs.

So we focus on
the cases n = s or n = s + 1.
0
By Exercise X.1.19 there is provably in VTC an FTC 0 -computable G0
derivation of
A( )[s], ( = )[s, s] −→ A()[s].

(340)

Also, note that for n = s, the formula ( = )[s, n] is false, and the sequent
A( )[s], ( = )[s, n] −→ A()[n]

(341)

can be shown to have polynomial size proof in G0 .
0

By Exercise X.1.20 there are (provably in VTC ) FTC 0 -computable G1
derivations
A(α)[s], S(α, )[s, n] −→ A( )[n]
==========================
A( )[s], S( , )[s, n] −→ A()[n]
for n = s and n = s + 1. Combine these derivations we obtain G1
derivations
{A(α)[s], S(α, )[s, m] −→ A( )[m] : m ∈ {s, s + 1}}
===================================================
{A( )[s], ( = )[s, n] ∨ S( , )[s, n] −→ A()[n] : n ∈ {s, s + 1}}
(342)
Now note that V 0 proves
S0 (X, Y ) ↔ (X = Y ∨ S(X, Y )).
0

So by Theorem X.1.14 there is provably in VTC an FTC 0 -computable
G0 derivation of
S0 ( , )[s, n] −→ ( = )[s, n] ∨ S( , )[s, n].

(343)

From this and (342) above we obtain a G1 derivation
{A(α)[s], S(α, )[s, m] −→ A( )[m] : s ≤ d, and m = s or m = s + 1}
=======================================================
{A( )[s], S0 ( , )[s, n] −→ A()[n] : s ≤ d, and n = s or n = s + 1}

X.1. Formalizing Propositional Translations

381

Combine this and the derivations in (339) we obtain the derivation for the
base case.
For the induction step, suppose that there is a polynomial size G1
derivations of the form (338):
{A(α)[], S(α, )[, m] −→ A( )[m] : , m ≤ d }
=====================================
{A( )[s], Sk ( , )[s, n] −→ A()[n] : s, n ≤ d }

(344)

We will augment this derivation with additional derivations in order to
obtain one that contains also all sequents in the set
{A( )[s], Sk+1 ( , )[s, n] −→ A()[n] : s, n ≤ d }.

(345)
0

By Exercise X.1.20 there are FTC 0 functions that provably in VTC
compute some derivations of the following sequents from the bottom
sequents in (344):
{A()[n], Sk (, )[n, p] −→ A()[p] : n, p ≤ d }.

(346)

From the sequents in (346) and the sequents at the bottom of (344) we
obtain
{A( )[s], Sk ( , )[s, n] ∧ Sk (, )[n, p] −→ A()[p] : s, n, p ≤ d }.
For each pair (s, p) (s, p ≤ d ), from the above sequents with n =
0, 1, . . . , p using the ∨-left and ∃-left rules we obtain


(347)
A( )[s], ∃Z ≤ ||(Sk ( , Z) ∧ Sk (Z, )) [s, p] −→ A()[p].
Notice that {k} + {k} = {k + 1}, and
V 0  Sk+1 ( , ) −→ ∃Z ≤ ||(Sk ( , Z) ∧ Sk (Z, )).
0

Therefore by Theorem X.1.14 there is provably in VTC an FTC 0 -computable G0 proof of


(348)
Sk+1 ( , )[s, p] −→ ∃Z ≤ ||(Sk ( , Z) ∧ Sk (Z, )) [s, p].
From this and (347) we obtain the following member of (345):
A( )[s], Sk+1 ( , )[s, p] −→ A()[p].
This completes the description of the polynomial size derivation (338).
Observe that the top sequents in (344) are used more than once, so the
resulting derivation is daglike.
0
Now we show that H ∈ FTC 0 ; the fact that provably in VTC the
function H (k, d ) computes the desired derivations is straightforward.
That H ∈ FTC 0 can be seen by observing that (i) H (0, d ) is a FTC 0
function, and (ii) H (k + 1, d ) is obtained from H (k, d ) by augmenting
additional derivations that are computed by functions in FTC 0 . In other
words, the string H (k, d ) consists of disjoint fragments that can be deﬁned
2
independently by FTC 0 functions. Therefore H (k, d ) is in FTC 0 .

382

X. Proof Systems and the Reﬂection Principle

Recall that V 1 is ΣB1 -conservative over TV 0 (Theorem VIII.3.10 and
Corollary VIII.2.18) and G1 is equivalent to ePK for proving prenex Σq1
formulas (Theorem VII.4.16). Thus the V i Translation Theorem (Theorem VII.5.2) shows that ΣB1 theorems of TV 0 translate into families of
propositional tautologies that have polynomial-size ePK proofs. The next
0
exercise is to formalize in VTC a more direct proof of this fact.
*Exercise X.1.23 (Propositional Translation Theorem for TV 0 ).
Show, by translating the axiom MCV (Deﬁnition VIII.1.1) and using
Theorem X.1.14, that for each ΣB1 theorem ϕ(x, X ) of TV 0 there is a
0
function Fϕ in FTC 0 that provably in VTC computes an ePK proof of
ϕ(x, X )[m; n]. (Hint: consider a free variable normal form LK 2 -TV 0
proof  and treat the bits of the existentially quantiﬁed string variable in
MCV that appear in antecedents in  as extension variables.)

X.2. The Reﬂection Principle
The Reﬂection Principle (RFN) for a proof system F states that F is
sound, i.e., the endsequent of any F-proof is a valid sequent. In order
to state the principle we need to formalize the notion of truth deﬁnitions,
i.e. the relation (Z |= X ) that holds iﬀ the truth assignment Z satisﬁes a
propositional formula X . It is straightforward that for i ≥ 1 the relation
(Z |= X ) is in ΣPi (resp. ΠPi ) whenever X is a Σqi (resp. Πqi ) formula. When
X is a quantiﬁer-free propositional formula, it is also straightforward that
(Z |= X ) is a polytime relation and is ΔB1 -deﬁnable in TV 0 . (A diﬃcult
result, due to Buss, states that (Z |= X ) is an NC 1 relation when X is a
quantiﬁer-free. See Section X.3.2.) Formulas that represent the relations
(Z |= X ) (for diﬀerent classes of X ) are presented in Section X.2.1.
Using the formulas expressing (Z |= X ) we can state and prove the
following “back and forth” properties. On the one hand, let A" denote the
string (of L2A ) that encodes a propositional formula A(p). Then for all
"
truth assignments Z, intuitively the propositional translations of (Z |= A)
−
→
−
→
Z
Z
are equivalent to A(p ), where p are the values of p under Z. These
equivalences will be stated as propositional tautologies, and we will give
polytime algorithms that compute G0 proofs for them.
On the other hand, let ϕ(Z) be a formula of L2A and A" be the string
encoding the propositional translation ϕ(Z)[n] of ϕ. Then for Z of length
|Z| = n we must have
" ↔ ϕ(Z).
(Z |= A)
0

We will show that this equivalence is a theorem of VTC . Detailed discussions are given in Section X.2.2.

X.2. The Reﬂection Principle

383

The Φ-RFN for F will be deﬁned in Section X.2.3, where Φ is a class
of formulas and F is a proof system. There we will show that the Φ-RFN
for each system Gi and Gi is provable in the associated theory, where Φ
includes (at least) Σqi ∪ Πqi . In Section X.2.4 we will show that for i ≥ 1
the Σqi+1 -RFN for Gi (resp. Gi ) can be used to axiomatize the associated
theories V i (resp. TV i ). Then in Section X.2.5 we will show that Gi and
Gi are the strongest (w.r.t. p-simulation) proof systems whose RFN can
be proved in V i and TV i , respectively.
Recall the Witnessing Theorem for V 1 (Theorem VII.4.13). In Section X.2.6 we consider generally the problem of ﬁnding witness for a Σqj
formula
A(p) ≡ ∃xB(p, x)
given a truth assignment to p and a Gi (or Gi ) proof  of A. The
Witnessing Problem is closely related to the RFN. Indeed, our proof of
the fact that V 1 proves the Σq1 -RFN for G1 is by formalizing the proof
of the Witnessing Theorem for V 1 (Theorem VII.4.13). We will show in
Section X.2.6 that the Witnessing Problems for the systems Gi and Gi are
complete for the classes that are deﬁnable in the associated theories.
X.2.1. Truth Deﬁnitions. Suppose that X encodes a (quantiﬁed) propositional formula. Then each string Z speciﬁes a truth assignment to the
variables pi in X as follows:
pi is assigned the value of Z(i).
Thus all possible truth assignment to variables in X can be speciﬁed by
strings Z of length |Z| ≤ |X |.
Here we present L2A -formulas that represent the relation
(Z |= X )
which holds for a truth assignment Z and a formula X iﬀ Z satisﬁes X .
We will consider separate cases depending on whether X is quantiﬁer-free
or X belongs to Σqi or Πqi where i ≥ 1.
First let
(Z |=0 X )
hold iﬀ X encodes a quantiﬁer-free formula, and Z is a satisfying truth
assignment to X . Lemma X.2.1 below follows from Exercise X.1.3 and
the fact that (Z |=0 X ) is in P. (Recall the axiom ΣB0 -BIT-REC from
Section VIII.3.2.) Nevertheless, we will give some details describing the
formula ϕ0 (y, X, Z, E) for the Lemma, since we will need them later. In
Section X.3.2 we will show that (Z |=0 X ) is indeed in NC 1 and ΔB1 deﬁnable in VNC 1 .

384

X. Proof Systems and the Reﬂection Principle

Lemma X.2.1. There are a ΣB0 formula ϕ0 (y, X, E) and an L2A term
t0 (y, X ) so that both


(Z |=Σ0 X ) ≡ ∃E ≤ t0 + 1 ϕ0rec (t0 + 1, X, Z, E) ∧ E(t0 ) ,
 rec

(Z |=Π
0 X ) ≡ ∀E ≤ t0 + 1 ϕ0 (t0 + 1, X, Z, E) ⊃ E(t0 )
represent (Z |=0 X ) and such that
TV 0  (Z |=Σ0 X ) ↔ (Z |=Π
0 X ).
Proof idea. The formula ϕ0rec (t0 + 1, X, Z, E) asserts that E encodes a
polytime algorithm that consists of two stages: ﬁrst it veriﬁes that X is
a formula, then it evaluates X in a bottom up fashion. If the ﬁrst stage
rejects then the algorithm rejects, otherwise its output is the value of the
evaluation and is stored in E(t0 ).
For the ﬁrst stage in the algorithm we use the formula ϕFLA (y, X, Y )
from Corollary X.1.4 that essentially states that Y encodes a computation
of the relation FLA(X ). The “check bit” Y (tFLA ) indicates whether the
computation accepts. Thus, for i ≤ tFLA we have
ϕ0 (i, X, Z, E <i ) ↔ ϕFLA (i, X, E <i ).
If the ﬁrst stage rejects (i.e., E(tFLA ) is false) then the algorithm rejects,
i.e., for all tFLA < i ≤ t0 we have
ϕ0 (i, X, Z, E <i ) ↔ ⊥.
Suppose now that E(tFLA ) is true. Let n = |X |. To encode the second
stage we will store the value of each subformula X [i, j] of X (for some
0 ≤ i ≤ j < n) in the bit E(ai,j ), for distinct terms ai,j > tFLA deﬁned
below.
In order to conform with the axiom scheme BIT-REC, where the bits
E(z) is computed from E <z , and since the subformulas of X are evaluated
bottom up, we can order the subformulas of X in nondecreasing order of
their lengths, i.e., we want
ai,j < ai  ,j 
whenever j  − i  > j − i. Thus, let
ai,j = tFLA + 1 + (j − i + 1)n, n + i, j.
Now, for example if X [i, j] is an atom ps , then we have
ϕ0 (ai,j , X, Z, E <ai,j ) ↔ Z(s).
For another example, suppose that X [i, j] is the formula
(C ∧ D)
where C = X [i + 1, ] and D = X [ + 2, j − 1] for some , then
ϕ0 (ai,j , X, Z, E <ai,j ) ↔ (E(ai+1, ) ∧ E(a+2,j−1 )).

X.2. The Reﬂection Principle

385

The “check bit” for E is E(t0 ), where t0 = a0,n−1 . The value of this check
bit is the value of the formula X . Also, for all other bits E(r), where
tFLA < r < t0 and r = ai,j for all subformulas X [i, j] of X , we set E(r) to
 by having
ϕ0 (r, X, Z, E <r ) ↔ .
This completes the description of the formula ϕ0 (i, X, Z, E). It is easy to
see that
TV 0  (Z |=Σ0 X ) ↔ (Z |=Π
0 X ).

2

Recall that A" denotes the L2A string encoding a propositional formula A.
Exercise X.2.2. Show that the theory V 0 proves


" ∧ (Z |=Σ B)
" ,

∧ B) ↔ (Z |=Σ0 A)
1) (Z |=Σ0 A
0


" ∨ (Z |=Σ B)
" ,

∨ B) ↔ (Z |=Σ0 A)
2) (Z |=Σ0 A
0
 ↔ ¬(Z |=Π A).
"
3) (Z |=Σ ¬A)
0

0

Σ
Show also that V 0 proves similar theorems with |=Π
0 instead of |=0 .

Now we consider the classes of formulas Σqi and Πqi (for i ≥ 1). Here
it can be seen that evaluating Σqi (resp. Πqi ) sentences can be done in ΣPi
(resp. in ΠPi ). So in this case the formulas that represent (Z |= X ) belong
to ΣBi (resp. ΠBi ).
Lemma X.2.3. Let 1 ≤ i ∈ N. There is a ΣBi formula (Z |=Σqi X ) that
is true iﬀ X encodes a Σqi formula and the truth assignment Z satisﬁes X .
Similarly, there is a ΠBi formula (Z |=Πqi X ) that is true iﬀ X encodes a Πqi
formula and the truth assignment Z satisﬁes X .
Proof Idea. We show how to construct (Z |=Σqi X ); the formula
(Z |=Πqi X ) is constructed in the same way. The idea is to encode quantiﬁed propositional variables by the bits of quantiﬁed string variables. Let
A be the Σqi formula encoded by X .
First suppose that A is a prenex formula of the form
∃xi ∀xi−1 . . . Q x1 B
where B is a quantiﬁer-free formula, and Q ∈ {∃, ∀}: if i is odd then Q is
∃, otherwise Q is ∀. Then (Z |=Σqi X ) has the form
" X1 , . . . , Xi , Z)
∃Xi ≤ n ∀Xi−1 ≤ n . . . QX1 ≤ n (B,

(349)

where n = |X |, is in ΣB1 if i is odd, and is in ΠB1 if i is even (so the
whole formula is ΣBi in either case). Here is obtained as in Lemma X.2.1
to express the fact that the truth assignment deﬁned by Z and X1 , X2 , . . . ,
Xi satisﬁes the formula B.
Now suppose that A is not in prenex form. Note that by deﬁnition no
string quantiﬁer in a ΣBi formula is in the scope of a number quantiﬁer
or a Boolean connective. So ﬁrst we have to put A into prenex form.

386

X. Proof Systems and the Reﬂection Principle

The procedure described in Theorem II.5.12 is sequential. A parallel
procedure is as follows.
TC 0 prenexiﬁcation. First we compute the quantiﬁer depth of each
quantiﬁed variable using the function qdepth mentioned on page 373.
(Here we can assume that A has an outer most existential quantiﬁer.)
After renaming the quantiﬁed variables (so that they are distinct) we can
safely move the quantiﬁers into their proper block in the preﬁx. Consider a
quantiﬁer ∃xi or ∀xi that occurs in X at position t. We will simply rename
simultaneously all occurrences of xi that are caught by this quantiﬁer to
xn+t , where n is the length of the original formula A. Note that in A all
variables have index at most n. Also, all variables (including both bound
and free variables) in the new formula will have distinct indices.
Consider for example the following scenario:
. . . ∃x2 (. . . ∀x2 (. . . x2 . . . ) . . . x2 . . . ) . . .
where the ∃ is at position 7 and the ∀ is at position 20, and n is 100. Then
the ﬁrst and the fourth occurrences of x2 are renamed to x107 , while the
other two occurrences of x2 are renamed to x120 .
Finally we must determine (in TC 0 ) whether each (original) quantiﬁer
is in the scope of an odd number of ¬’s, and if so change it from ∀ to ∃ or
from ∃ to ∀.
It can be seen that the length of the resulting formula is at most n 2 .
It can be seen that the transformation can be done by a TC 0 algorithm.
In fact, it can be shown that there are a ΣB1 formula ϕ1 (X, X  ) and a ΠB1
formula ϕ2 (X, X  ) that are true iﬀ X  is the result of the transformation
of X described above, and such that
VTC 0  ϕ1 (X, X  ) ↔ ϕ2 (X, X  )
and

VTC 0  ∃X  ≤ n 2 ϕ1 (X, X  ).
Now the ΣBi formula Z |=Σqi X has the form
∃Xi ≤ n 2 ∀Xi−1 ≤ n 2 . . . QX1 ≤ n 2 QX  ≤ n 2

(X  , X , Z)

(350)

where Q is ∃ if i is odd and Q is ∀ otherwise. Suppose that i is odd. Then
is a ΣB1 formula; it is is obtained from ϕ1 and the ΣB1 formula (obtained as
in Lemma X.2.1) that expresses the fact that the truth assignment deﬁned
by Z and X1 , X2 , . . . , Xi satisﬁes the formula coded by X  . The case
where i is even is similar.
2
Exercise X.2.4. Let A, B be Σqi formulas. Show that the following are
theorems of V 0 :


" ∧ (Z |=Σq B)
" .

1) (Z |=Σqi A
∧ B) ↔ (Z |=Σqi A)
i


" ∨ (Z |=Σq B)
" .

2) (Z |=Σq A
∨ B) ↔ (Z |=Σq A)
i

i

" ↔ ¬(Z |=Πq ¬A).

3) (Z |=Σqi A)
i

i

X.2. The Reﬂection Principle
387
 ↔ (Z |= q A(⊥))
 ∨ (Z |= q A())
 .
4) (Z |=Σqi ∃xA(x))
Σi
Σi
 ↔ (Z |= q A(⊥))
 ∧ (Z |= q A())
  (if ∀xA(x)
5) (Z |= q ∀xA(x))
Σi

Σi

Σi

is a Σqi formula).
Give similar theorems of V 0 that involve (Z |=Πqi X ).
X.2.2. Truth Deﬁnitions vs Propositional Translations. In this section
we consider a kind of back and forth relationship between propositional
translation (from ﬁrst-order theories to proof systems) and the formalization of propositional proofs in our theories.
Consider for example a quantiﬁer-free propositional formula
A(p0 , p1 , . . . , pn−1 ).
As before let A" be the encoding of A. Recall that for Z of length |Z| =
" deﬁned in Section X.2.1 is
n + 1, the intended meaning of (Z |=0 A)
Z
).
A(p0Z , p1Z , . . . , pn−1

Therefore, intuitively, the propositional formulas
" + 1]
" + 1]
(Z |=Π A)[n
and
(Z |=Σ A)[n
0

0

Z
).
should both be equivalent to A(p0Z , p1Z , . . . , pn−1
We will show that there are polytime algorithms that compute G0 proofs
of these equivalences. In addition, if A is a Φ formula (where Φ ∈
{Σqi , Πqi } for i ≥ 1) then there is a polytime algorithm that computes a
−
→
" + 1]. In
Gi proof of the equivalence between A(pZ ) and (Z |=Φ A)[n

other words, the systems Gi prove the correctness of the composition of
our truth deﬁnitions and translation (and the Gi proofs can be computed
in polytime).
In Theorem X.2.10 we will turn the above observation around and
show that the theory VTC 0 proves the correctness of the composition of
propositional translation and truth deﬁnition.
For the next theorem recall (Deﬁnition X.1.6) that for a constant string
0 of length m, the notation
A

0 )[n + 1]
(Z |=Σ0 A

−
→
denotes the propositional formula with variables pZ that is obtained from
0 |) by plugging the
the translation (Z |=Σ0 X )[m, n + 1] (where m = |A
X

values of the bits A0 (j) for pj . Since the truth values of the variables
−
→
pZ are intended to assign truth values to the free variables p of A0 (p)
we generally assume that n is greater than or equal to the number of free
variables in A0 .
Theorem X.2.5. There are polytime algorithms that, given a quantiﬁerfree formula A0 (p) that has no more than n free variables p, compute G0
proofs of the sequents:

388

X. Proof Systems and the Reﬂection Principle
−
→
Z

(a) (Z |=Π
0 A0 )[n + 1] −→ A0 (p ).
−
→
Σ 
Z
(b) (Z |=0 A0 )[n + 1] −→ A0 (p ).
−
→
0 )[n + 1].
(c) A0 (pZ ) −→ (Z |=Σ0 A
−
→
0 )[n + 1].
(d) A0 (pZ ) −→ (Z |=Π A
0

Proof. We will prove (a) and (b) and leave the proofs of (c) and (d) as
an exercise. Refer to the proof of Lemma X.2.1 for detailed description
0 , Z, E). Let m = |A
0 | and r = t0 (m).
of the formula ϕ0rec (t0 + 1, A

(a) We will construct a G0 proof of the sequent, and it can be veriﬁed that

the construction is in polytime. Recall (Lemma X.2.1) that (Z |=Π
0 A0 ) is
B
the Π1 formula
 rec



(Z |=Π
0 A0 ) ≡ ∀E ≤ t0 + 1 ϕ0 (t0 + 1, A0 , Z, E) ⊃ E(t0 )

so (Z |=Π
0 A0 )[n + 1] is
r+1
E
∀p0E ∀p1E . . . ∀pr−1

 rec

0 , Z, E) ⊃ E(t0 ) [n + 1, k].
ϕ0 (t0 + 1, A

k=0

The idea is to prove an instance of the following sequent
r+1

 rec

−
→
0 , Z, E) ⊃ E(t0 ) [n + 1, k] −→ A0 (pZ )
ϕ0 (t0 + 1, A

(351)

k=0

−
→
where the variables p E have the right values, and then apply the ∀-left rule
0
repeatedly. In particular, note that the ﬁrst (tFLA + 1) bits of E parse A
0 [u, v] of
and the remaining bits evaluate A0 bottom up: if the substring A
0 encodes a subformula Au,v of A0 , then
A
E(au,v ) ↔ Au,v
for the term au,v described in the proof of Lemma X.2.1. Thus, as in
Lemma X.1.7 we can compute the “parsing” bits of E (and compute a
cut-free PK  proof for their correctness) in polytime. For the “evaluating”
bits in E, the only relevant bits are bits of the form E(au,v ) as above, and
here we substitute the subformulas Au,v for them.
More precisely, consider the antecedent of (351). For k = r + 1, E(t0 )
translates into , so

 rec
0 , Z, E) ⊃ E(t0 ) [n + 1, r + 1]
ϕ0 (t0 + 1, A
is  and is deleted from the conjunction. For k ≤ r, E(t0 ) translates into
⊥, so

 rec
0 , Z, E) ⊃ E(t0 ) [n + 1, k] ≡
ϕ0 (t0 + 1, A
0 , Z, E)[n + 1, k].
¬ϕ0rec (t0 + 1, A

X.2. The Reﬂection Principle

389

Therefore to derive (351) it suﬃces to derive an instance of the following
−
→
sequent (where the free variables pE are replaced by appropriate formulas):
0 , Z, E)[n + 1, 0], ϕ0rec (t0 + 1, A
0 , Z, E)[n + 1, 1], . . . ,
−→ ϕ0rec (t0 + 1, A
−
→
0 , Z, E)[n + 1, r], A0 (pZ ).
ϕ0rec (t0 + 1, A
In fact, we will give a PK  proof of an instance of the following sequent
and then apply the weakening rule:
−
→
0 , Z, E)[n + 1, r], A0 (pZ ).
−→ ϕ0rec (t0 + 1, A
(352)
−
→
It remains to describe a substitution for the free variables pE so that
(352) has a polynomial size PK  proof.
Recall that
0 , Z, E) ≡ ∀i ≤ t0 (E(i) ↔ ϕ0 (i, A
0 , Z, E <i )).
ϕ0rec (t0 + 1, A
0 , Z, E)[n + 1, r] is
So ϕ0rec (t0 + 1, A
r−2


0 , Z, E <i ))[n + 1, r] ∧
(E(i) ↔ ϕ0 (i, A



i=0



0 , Z, E <r−1 )[n + 1, r] ∧ ¬ ϕ0 (r, A
0 , Z, E <r )[n + 1, r] .
ϕ0 (r − 1, A

0 , Z, E) is deﬁned so that:
Also recall that the formula ϕ0 (i, A
0 ;
• bits E(0), E(1), . . . , E(tFLA ) “parse” A
0 [u, v] is a subformula of A0 of the form an atom ps , then
• if A
0 , Z, E <au,v ) ↔ Z(s);
ϕ0 (au,v , A
0 [u, v] is a subformula of A0 of the form
• if A
(A0 [u + 1, w] ∧ A0 [w + 2, v − 1])
then
0 , Z, E <au,v ) ↔ E(au+1,w ) ∧ E(aw+2,v−1 )
ϕ0 (au,v , A
and similarly for other kinds of connectives;
• if tFLA < i < t0 (t0 = a0,m−1 ) and u = au,v for all 0 ≤ u ≤ v < m,
then
0 , Z, E <i ) ↔ .
ϕ0 (i, A
In polytime we can compute the right Boolean values b0 , b1 , . . . , btFLA
for the bits E(0), E(1), . . . , E(tFLA ) and PK  proofs of their correctness,
i.e., PK  proofs of
−→ bi ↔ Bi

(353)

390

X. Proof Systems and the Reﬂection Principle

for 0 ≤ i ≤ tFLA , where Bi is the sentence obtained from
0 , Z, E <i )[n + 1, r]
ϕ0 (i, A
by substituting bj for pjE , for j < i.
From now on we will assume that b0 , b1 , . . . , btFLA have been substituted
0 [u, v] is an atomic
for the bits E(0), E(1), . . . , E(tFLA ). Suppose that A
subformula ps of A0 , then the following sequent is valid and has a short
PK  proof:
0 , Z, E <au,v )[n + 1, r] ↔ pZ .
−→ ϕ0 (au,v , A
s
0 [u, v] is a subformula of A0 of the form
In addition, if A
(A0 [u + 1, w] ∧ A0 [w + 2, v − 1])
then we have a short PK  proof of the sequent
E
0 , Z, E <au,v )[n + 1, r] ↔ (p E
−→ ϕ0 (au,v , A
au+1,w ∧ paw+2,v−1 ).

Similarly for other subformulas of A0 . Also, for tFLA < i < r and i = au,v
0 [u, v] of A0 (for 0 ≤ u ≤ v < m), then there are
for all subformulas A
short PK  proof of
0 , Z, E <i )[n + 1, r].
−→ ϕ0 (i, A

(354)

(In particular, it can be veriﬁed that r − 1 = au,v for 0 ≤ u ≤ v < m, so
0 , Z, E <r−1 )[n + 1, r]
−→ ϕ0 (r − 1, A

(355)

has a short PK  proof.)
0 [u, v] is a proper subformula C of A0 , we will substitute C
Thus, if A
for paEu,v . Also, for i such that tFLA < i < r and i = au,v for all subformulas
0 [u, v] of A0 , we will substitute  for p E . The above argument shows
A
i
0 [u, v] of A0 we can derive
that for any subformula C = A
0 , Z, E <au,v )[n + 1, r].
−→ C ↔ ϕ0 (au,v , A

(356)

In particular we can derive
0 , Z, E <r )[n + 1, r].
−→ A0 ↔ ϕ0 (r, A

(357)

Now it can be seen that under the described substitution, the sequent
(352) can be derived from the sequents (353), (354), (355), (356) and
(357).
(b) As in (a) we will construct a G0 proof of the given sequent and leave
it to the reader to verify that the construction is in polytime.
Recall that


0 , Z, E) ∧ E(t0 ) .
0 ) ≡ ∃E ≤ t0 + 1 ϕ0rec (t0 + 1, A
(Z |=Σ0 A

391

X.2. The Reﬂection Principle
0 )[n + 1] is (the simpliﬁcation of)
So by deﬁnition, (Z |=Σ0 A
E
∃p0E ∃p1E . . . ∃pr−1

r+1





0 , Z, E) ∧ E(t0 ))[n + 1, k] .
(ϕ0rec (t0 + 1, A

k=0

We have E(t0 )[r + 1] =def , and E(t0 )[k] =def ⊥ for k ≤ r. Therefore
0 )[n + 1] =def
(Z |=Σ0 A


 rec
E
0 , Z, E)[n + 1, r + 1] .
∃p0E ∃p1E . . . ∃pr−1
ϕ0 (t0 + 1, A

Thus, to prove the given sequent we will give a PK  proof of the sequent
(358) in Lemma X.2.6 below and then apply repeatedly the rule ∃-left. We
conclude the proof by proving Lemma X.2.6.
2
Lemma X.2.6. Let A0 and n, r be as in Theorem X.2.5 and its proof. Then
there is a polytime algorithm that computes a PK  proof of the following
sequent:
−
→
0 , Z, E)[n + 1, r + 1] −→ A0 (pZ ).
ϕ0rec (t0 + 1, A

(358)

Proof. We have
0 , Z, E) ≡ ∀i ≤ t0 (E(i) ↔ ϕ0 (i, A
0 , Z, E <i )).
ϕ0rec (t0 + 1, A
So by deﬁnition (recall E(t0 )[r + 1] ≡ ):
0 , Z, E)[n + 1, r + 1] ≡
ϕ0rec (t0 + 1, A
r−1

0 , Z, E <i )[n + 1, r + 1]) ∧
(piE ↔ ϕ0 (i, A

i=0

0 , Z, E <t0 )[n + 1, r + 1].
ϕ0 (t0 , A
−
→
Let B0 , B1 , . . . , Br−1 be the correct values of p E , i.e.,
• B0 , B1 , . . . , BtFLA are the (only) Boolean values of the bits
E(0), E(1), . . . , E(tFLA )
that correctly parse the formula A0 ;
0 [u, v] (for 0 ≤ u ≤
• for a subformula Cu,v of A0 that is encoded by A
v < m), Bau,v is Cu,v ;
• for tFLA < i < r such that i = au,v for all 0 ≤ u ≤ v < m, Bi ≡ .
For 1 ≤ i ≤ r let
E
Λi = p0E ↔ B0 , . . . , pi−1
↔ Bi−1 .

392

X. Proof Systems and the Reﬂection Principle

Now we can prove by induction that there are polynomial size PK  proofs
of the following sequents:
0 , Z, E <0 )[n + 1, r + 1] −→ pE ↔ B0 ,
pE ↔ ϕ0 (0, A
0

0

0 , Z, E <1 )[n + 1, r + 1], Λ1 −→ pE ↔ B1 ,
p1E ↔ ϕ0 (1, A
1
...
E
0 , Z, E <r−1 )[n + 1, r + 1], Λr−1 −→ pE ↔ Br−1 ,
↔ ϕ0 (r − 1, A
pr−1
r−1

−
→
0 , Z, E <r )[n + 1, r + 1], Λr −→ A0 (pZ ).
ϕ0 (r, A

From these we can obtain a polynomial size PK  proof of (358).

2

Exercise X.2.7. Prove parts (c) and (d) of Theorem X.2.5.
Theorem X.2.8. Let i ≥ 1 and Φ ∈ {Σqi , Πqi }. There are polytime
algorithms that on input a prenex Φ formula A0 (p), with no more than n
free variables p, compute G0 proofs of the following sequents:
−
→
0 )[n + 1] −→ A0 (pZ )
(Z |=Φ A
(359)
and

−
→
0 )[n + 1].
A0 (pZ ) −→ (Z |=Φ A
If A0 is is not a prenex formula, then the proofs are in Gi .
Proof sketch. We consider the ﬁrst sequent; the argument for the
second is similar. Suppose that A0 is Σqi , so A0 has the form
∃xi ∀xi−1 . . . Q x1 B0 (x1 , . . . , xi , p).
0 |)
0 ) has the form (for m = |A
Then by (349) (Z |=Σqi A
0 , X1 , . . . , Xi , Z).
∃Xi ≤ m ∀Xi−1 ≤ m . . . QX1 ≤ m (B
Suppose that i is even, so is ΠB1 and Q is ∀. By a slight generalization
of part (a) of Theorem X.2.5 we can compute in polytime a G0 proof of
0 , X1 , X2 , . . . , Xi , Z)[m + 1, m + 1, . . . , m + 1, n + 1]
(B
−→
−→ −
→
−→ B0 (pX1 , . . . , p Xi , p Z ).

(360)

To turn this proof into a G0 proof of (359) involves applying the quantiﬁer
introduction rules together with ∨ and ∧ introduction. To see how this is
done, refer to Section VII.5 on propositional translations, formulas (149)
and (150). Since the innermost quantiﬁer of A0 is ∀X1 we refer to (150).
Starting with (360) we apply successive weakenings and ∧-left to obtain
the required conjunction on the left side, and then apply ∀-left repeatedly
−→
to quantify the variables of p X1 , and ﬁnally ∀-right repeatedly to quantify
the same variables on the right.
The next quantiﬁer of A0 is ∃X2 . According to (149) the translation on
the left has a disjunction over all lengths k of X2 from k = 0 to m + 1.

X.2. The Reﬂection Principle

393

Here we need the fact that assigning a length k < m + 1 to X2 implicitly
assigns some high-order bits of X2 to ⊥. Thus (360) continues to hold
with the second m + 1 on the left replaced by k, provided the high-order
−→
variables for p X2 on the right are replaced by ⊥. Hence for all values of
−→
k the sequent holds when on the right all variables in p X2 are existentially
quantiﬁed (after universal quantiﬁers have been applied to the variables
−→
pX1 ). Now we can put these derivations together and successively apply
∨-left, followed by repeated applications of ∃-left to quantify the variables
−→
of p X2 . We continue in this way until all variables associated with the Xj s
have been quantiﬁed, to obtain a G0 proof of (359).
For the second statement, ﬁrst let A0 be the prenex formula equivalent
to A0 as output by the TC 0 prenexiﬁcation procedure described in the
proof of Lemma X.2.3. We leave the proofs of the following facts as an
exercise:
Exercise X.2.9. Show that there are polytime algorithms that compute
Gi proofs of the following sequents:
A0 −→ A0

and

A0 −→ A0 .

(Hint: construct the proofs by structural induction on A0 .)
Consider the ﬁrst sequent:
−
→
0 )[n + 1] −→ A0 (pZ ).
(Z |=Φ A
By the ﬁrst statement there is a polynomial size G0 proof of
→
Z
 )[n + 1] −→ A (−
(Z |=Φ A
0 p ).
0
The desired sequent can now be derived from this and A0 −→ A0 using
q
cut on the Σi prenex formula A0 .
The second sequent is derived similarly.
2
Now we prove the category-theoretic reverse direction of Theorems
X.2.5 and X.2.8. Let ϕ(Z) be a ΣBi formula whose only free variable
is Z (for some i ≥ 0). By Corollary X.1.13 there is an FTC 0 function
0
Tϕ (n) that provably in VTC computes the encoding of ϕ(Z)[n], for all
n. Formally,

Tϕ (n) = ϕ(Z)[n]
and
0

VTC  ∀nFlaΣ (Tϕ (n))
where n = |Z|. Now intuitively it should be clear that
 ⇐⇒ ϕ(Z).
(Z |=Σqi ϕ(Z)[n])
0

We will show that this equivalence is indeed provable in our theory VTC .

394

X. Proof Systems and the Reﬂection Principle

Notation. (Z |=Σq0 X ) and (Z |=Πq0 X ) are deﬁned to be Z |=Σ0 X and
Z |=Π
0 X , respectively.
Theorem X.2.10. Let i ≥ 0 and ϕ(Z) be a ΣBi formula with a single free
variable Z as shown. Then

0
 ↔ ϕ(Z).
VTC  n = |Z| ⊃ (Z |= q ϕ(Z)[n])
Σi

Similarly, if ϕ(Z) is ΠBi , then


0
 ↔ ϕ(Z).
VTC  n = |Z| ⊃ (Z |=Πqi ϕ(Z)[n])

Proof idea. First consider the case i = 0. Suppose that ϕ is a ΣB0
0

formula. Reasoning in VTC . Let n = |Z|. We will show that
 ↔ ϕ(Z).
(Z |=Σ0 ϕ(Z)[n])
The fact that


(Z |=Π
0 ϕ(Z)[n]) ↔ ϕ(Z)

is similar.
Let A denote ϕ(Z)[n]. Recall from the proof of Lemma X.2.1 that
" has the form:
(Z |=Σ0 A)
" Z, E) ∧ E(t0 ))
∃E ≤ t0 + 1(ϕ0rec (t0 + 1, A,
where the ﬁrst (tFLA + 1) bits of E encode a computation that parses the
" and the remaining bits in E evaluate A in a bottom up fashion,
formula A,
" j]) is stored as the
where the value of a subformula Ai,j (encoded by A[i,
bit E(ai,j ) for the term ai,j as in the proof of Lemma X.2.1 (note that
"
a0,m−1 = t0 , where m = |A|).
First we show that
" ⊃ ϕ(Z).
(Z |=Σ0 A)
" Z, E) ∧ E(t0 ). Then we can show by structural
Let E satisfy ϕ0rec (t0 + 1, A,
induction on the (constant number of) subformulas ϕk of ϕ that
ϕk ↔ E(ak ,rk )

(361)

" k , rk ] encodes the translation of ϕk .
where k , rk are the indices so that A[
As a result, from E(t0 ) (i.e., E(a0,m−1 )) we conclude ϕ(Z).
Now we show that
"
ϕ(Z) ⊃ (Z |=Σ0 A).
Here we need to prove the existence of the string E that parses and
 is provably
" Recall Corollary X.1.13 that A" = ϕ(Z)[n]
then evaluates A.
0
0
computable in VTC by an FTC function. So, informally, the “parsing”
part in E (i.e., up to bit E(tFLA )) exists because
"
VTC  FlaΣ (A).
0

X.2. The Reﬂection Principle

395

rec
(tFLA +
(This part of E can be extracted from the string Y that satisﬁes ϕFLA
"
1, A, Y ) ∧ Y (tFLA ).)
The “evaluating” part in E can be proved to exist by ΣB0 (LFTC 0 )-COMP
using the observation (361). The fact that these bits satisfy ϕ0rec is straightforward. Note that by assuming that ϕ(Z) is true we also have that
E(a0,m−1 ) (i.e., E(t0 )) is true.
Now consider the case i = 2; the cases for other values i ≥ 1 are similar.
First, suppose that ϕ(Z) is a ΣB2 formula. Let n = |Z| as before. Without
loss of generality, suppose that ϕ(Z) has the form

∃X ≤ t(|Z|)∀Y ≤ t(|Z|) (X, Y, Z)
is a ΣB0 formula.

Then ϕ(Z)[n] has the form (recall (149) and

where
(150), page 191):

X
∃p0X . . . ∃pr−2

r


r
Y
∀p0Y . . . ∀pr−2

=0

(X, Y, Z)[, m, n]
m=0

where r = t(n).
In deﬁning (Z |=Σq2 ϕ(Z)[n]) (see Lemma X.2.3) we ﬁrst get the following prenex form of ϕ(Z)[n] (with bound variables renamed):
r
−→ −→ 
∃pX ∀pY

r

−→ −→ −
→
A,m (pX , pY , p Z )

=0 m=0

−→
where pX is a sequence of (r − 1) distinct variables obtained by renaming
−→
−→
pX and pY contains (r + 1)(r − 1) distinct variables resulting from re−→ −→ −
−→
→
naming pY . Also, A,m (pX , p Y , p Z ) is (X, Y, Z)[, m, n] with the bound
variables renamed. Note that the renaming of variables is performed by
a TC 0 function. Note also that for 0 ≤  =   ≤ r and 0 ≤ m, m  ≤ r,
−→ −→ −
−→ −→ −
→
→
A,m (pX , p Y , p Z ) and A  ,m (pX , p Y , pZ ) contain disjoint subsets of
−→

pY corresponding to disjoint substrings of Y  .
Now the formula (Z |=Σq2 ϕ(Z)[n]) has the form


"
∃X  ≤ s∀Y  ≤ s X  , Y  , Z |=Π
0 A
for some term s, where
A≡

r


r

−→ −→ −
→
A,m (pX , p Y , p Z )

=0 m=0
B
"
and (X , Y , Z |=Π
0 A) is the Π1 formula obtained as in Lemma X.2.1






expressing the fact that the truth assignment speciﬁed by X , Y , Z satisﬁes A.
We mentioned above that the renaming functions are in TC 0 . It can
also be seen that their inverses are also in TC 0 . Thus, there are TC 0

396

X. Proof Systems and the Reﬂection Principle

functions F (, X  ), G(, m, Y  ) and F  (X ), G  (, Y ) where
|F (, X  )| = , |G(, m, Y  )| = m, |F  (X )| ≤ s, |G  (, Y )| ≤ s
−→ −→
such that (using the case i = 0 above, and write A,m for A,m (pX , p Y ,
−
→
p Z )):
• for |X | = :


0

VTC  (X, G(, m, Y  ), Z) ↔ F  (X ), Y  , Z |=Π
0 A,m
and
• for |Y | = m and any string Y  that shares with G  (, Y ) the sub−→
strings corresponding to the pY -variables in A,m :


0

VTC  (F (, X  ), Y, Z) ↔ X  , Y  , Z |=Π
0 A,m .
From this it can be shown that
 

" ↔ ∃X ≤ t∀Y ≤ t (X, Y, Z)
∃X ≤ s∀Y  ≤ s(X  , Y  , Z |=Π
0 A
so we obtain

0
 ↔ ϕ(Z)
VTC  (Z |=Σq2 ϕ(Z)[n])

as required.
The second statement (i.e., for a ΠB2 formula ϕ) is proved similarly. 2
X.2.3. RFN and Consistency for Subsystems of G. For a class Φ of formulas and a (quantiﬁed) propositional proof system F , the Φ-Reﬂection
Principle for F , denoted by Φ-RFN F , asserts that every formula of Φ that
q
has an F -proof is valid. Here we will show that for i ≥ 1, the Πi+1 -RFN
for Gi (resp. Gi ) is provable in the associated theory V i (resp. TV i ). In
Section X.2.4 we will show that indeed the theories can be axiomatized
using the RFN of the associated proof systems.
To state the principle we need the formulas (Z |=Σqi X ) and (Z |=Πqi X )
from Section X.2.2. Recall that (Z |=Σq0 X ) and (Z |=Πq0 X ) stands for
Σ
(Z |=Σ0 X ) and (Z |=Π
0 X ), respectively. Recall also the formulas Fla ,
Σ
Π
Π
Fla , Prf F , and Prf F (see Corollary X.1.4 and Lemma X.1.5).
Σ
Notation. For i ≥ 0 and Φ ∈ {Σqi , Πqi }, let FlaΠ
Φ (X ) (resp. FlaΦ (X ))
B
B
be the Π1 (resp. Σ1 ) formula that represents the relation FLA(X ) for
formulas X in Φ.

Deﬁnition X.2.11 (The Reﬂection Principle). For a proof system F
and Φ ∈ {Σqi , Πqi } (i ≥ 0) the Φ-Reﬂection Principle for F, denoted
Φ-RFN F , is the L2A sentence deﬁned as follows:


Π
q
q
Σqi -RFN F ≡ ∀∀X ∀Z (FlaΠ
Σi (X ) ∧ Prf F (, X )) ⊃ (Z |=Σi X ) ,


Πqi -RFN F ≡ ∀∀X ∀Z (FlaΣΠq (X ) ∧ Prf ΣF (, X )) ⊃ (Z |=Πqi X ) .
i

X.2. The Reﬂection Principle

397

Also,
i-RFN F ≡ Σqi -RFN F ∧ Πqi -RFN F .
Note that for i ≥ 1, Σqi -RFN F is equivalent to a ∀ΣBi sentence, and
q
Πi -RFN F is equivalent to a ∀ΠBi sentence. Also, Σq0 -RFN F is equivalent
to a ∀ΣB1 sentence, while Πq0 -RFN F is equivalent to a ∀ΣB0 sentence.
The principle Πq0 -RFN F is equivalent to the consistency statement which
asserts that the proof system F does not prove a contradiction:

Deﬁnition X.2.12 (Consistency). For a proof system F, the sentence
CON F is deﬁned to be
∀¬Prf ΣF (, ⊥).
Note that CON F is equivalent to a ∀ΣB0 sentence.
Lemma X.2.13. Let F be the system Gi or Gi (where i ≥ 0). Then
TV 0  CON F ↔ Πq0 -RFN F .
Proof. The direction
Πq0 -RFN F ⊃ CON F
is obvious. So consider proving
CON F ⊃ Πq0 -RFN F .
Reason in TV 0 . Assume for a contradiction that ¬Πq0 -RFN F . That
is, there are a quantiﬁer-free formula A with an F -proof  and a truth
" (Recall that A" denotes the encoding
assignment Z such that ¬(Z |=Πq0 A).
of formula A.)
 Let A0 be the formula A with
By Exercise X.2.4 we have (Z |=Πq0 ¬A).
the bits of Z substituted for the free variables in A. Then we have ¬A0 , and
by Exercise X.1.8 there is a PK  -proof  of ¬A0 . Also, by substituting
the bits of Z for the parameter variables in  we obtain a F -proof  of
A0 . Combine  and  by a cut we obtain an F -proof of ⊥, and this
violates CON F .
2
Observe that asserting that a formula A(p) of the form
∀xB(p, x)
is valid is essentially equivalent to asserting that B(p, q) is valid. So, if an
F -proof of any Πqi+1 formula A(p) can be transformed (in a theory T )
into a proof of B (or some other Σqi formula), then T proves
Σqi -RFN F ⊃ Πqi+1 -RFN F .
We illustrate this in the next lemma where we prove the implication for
treelike proof systems. The transformation in this case can be computed
by a polytime function, and this explains why the implication is provable
in TV 0 .

398

X. Proof Systems and the Reﬂection Principle

Lemma X.2.14. For i, j ≥ 0,
TV 0  Σqi -RFN Gj ⊃ Πqi+1 -RFN Gj .
It follows immediately that:
Corollary X.2.15. For i ≥ 1, j ≥ 0,
TV 0  Σqi -RFN Gj ↔ i-RFN Gj .
q

Proof sketch of Lemma X.2.14. Assuming Σi -RFN Gj we need to prove Πqi+1 -RFN Gj . Thus let  be a Gj proof of a Πqi+1 formula A(p).
Informally we need to show that A is valid.
If A is in Σqi then we can use Σqi -RFN Gj and the conclusion is trivial. So
suppose that A is in (Πqi+1 − Σqi ). Using the fact that  is a treelike proof,
we will transform  into a proof of a Σqi formula A (p, q) so that
∀A ⊃ ∀A

(362)

and such that the transformation is in polytime. Then by Σqi -RFN Gj we
have that A is valid, and hence A is valid.
Below we will describe the transformation and the formula A . They
can be computed from  and A in polytime, and (362) can be formalized
and proved in TV 0 , so we are done.
There are two cases depending on whether A is a prenex formula or not.
We consider the simpler case ﬁrst.
Case I. A is a prenex formula. Here A has the form
∀xm . . . ∀x1 B(p, x1 , . . . , xm )

(363)

where B is a prenex Σqi formula.
If j > i then there is an easy argument as follows. There is an obvious
G0 proof of
A −→ B(p, q).
This together with the proof  of A and cut gives a Gj proof of B(p, q),
so we can take A to be B. Thus we may assume j ≤ i, although the
argument below can be made to work for any j ≥ 0.
Since  is treelike, we can assume that  is in free variable normal form
(recall Section II.2.4 and see Exercise X.1.11).
We use the idea of Gentzen’s Midsequent theorem, and transform 
into a proof of a sequent of the form
−
→
−
→
−
→
(364)
−→ B(p, q 1 ), B(p, q 2 ), . . . , B(p, q k )
−
→
for some k. Here q t are all eigenvariables that introduce the universal
variables x shown in (363). Intuitively, we retain these eigenvariables by
ignoring the ∀-right rule.

X.2. The Reﬂection Principle

399

Formally, suppose that C is a (Πqi+1 −Σqi ) ancestor of A in the succedent
of a sequent S in . Then C has the form
∀xt . . . ∀x1 B(p, x1 , . . . , xt , qt+1 , . . . , qm )
(for some t, 1 ≤ t ≤ m). Note that C can only be in the succedent of
S. We transform S by replacing C by a list of formulas as in (364) that
contains all ancestors of C of the type B(p, q). (In case C occurs in an
axiom C −→ C we may assume C has the form B(p, q) by using the
axiom B −→ B and adding universal quantiﬁers to both sides.)
The replacement above is performed for all such C . Let S  denote the
transformed sequent, and   denote the transformed proof. We can easily
turn  into a legitimate proof by (i) deleting the ∀-right that introduces the
variables ∀x of A as shown in (363) as well as contraction right involving
C , and (ii) inserting necessary weakenings.
Finally, from a proof of the sequent of the form (364) using the ∨-right
we obtain a proof of A (p, q) where A has the form

−
→
(365)
B(p, q  ).
Case II. A is not a prenex formula. The description of A in this case is
more complicated, so we only outline the arguments here. For illustration,
consider a (Πqi+1 − Σqi ) subformula A1 of A of the form (363) where here
B is in Σqi but is not necessarily in prenex form. Then following the above
procedure, A1 is replaced by a formula A1 of the form (365).
We need to extend the above transformation to other (Πqi+1 − Σqi ) subformulas of A. The transformation will be done in a top-down fashion.
Thus, for example, a superformula of A1 may be replaced by several different copies all containing A1 . These copies of A1 can then be replaced
by diﬀerent disjunctions of the form (365).
This motivates the following deﬁnition. For simplicity, assume that in
A all ¬ connective occur only in front of atoms.
Deﬁnition X.2.16. For a formula A in (Πqi+1 − Σqi ), a Σqi -expansion of
A is any Σqi formula that can be obtained from A by ﬁnitely many repeated
applications of the operations that consist of the following steps:
1) let A1 be a non-Σqi subformula of A;
2) replace A1 by a formula as follows:
• if A1 has the form ∀xB(x) then let q1 , q2 , . . . , qr be a list of new
free variables (qt need not be distinct), and replace A1 by the
disjunction

B(qt ),
1≤t≤r

• otherwise A1 is replaced by (A1 ∨ A1 ).

400

X. Proof Systems and the Reﬂection Principle

For example, the formula in (365) is a Σqi -expansion of (363). For
another example, suppose


A ≡ ∀x1 ∃y1 B(x1 , y1 ) ∧ ∀x2 ∃y2 C (x1 , x2 , y2 )
where B, C are quantiﬁer-free formulas. Then the following formula is a
Σq1 -expansion of A:


∃y1 B(x1 , q1 ) ∧ ∃y2 C (q1 , q2 , y2 ) ∨ ∃y2 C (q1 , q3 , y2 ) .
Now, the Gj proof  of A(p) can be transformed into a Gj proof 
of an Σqi -expansion A (p, q) of A. The transformation can be seen to be
computable by a polytime function, and the formalization of (362) can
be shown to be provable in TV 0 .
2
Now we prove the RFN of the systems Gi and Gi in our theories. We
take the following approaches to show that the endsequent of given proof
 (in Gi or Gi ) is valid. The ﬁrst (see part (a) of the theorem below) is to
proceed by induction on the length of  to show that all sequents in  are
valid. Notice that if A(p) is a Σqi or Πqi+1 formula and A" encodes A, then
the statement asserting A is valid:
"
"
∀Z ≤ |A|(Z
|=Σqi A)
is in ΠBi+1 . Thus, informally, to prove Πqi+1 -RFN Gi we need ΠBi+1 -IND (so
V i+1 suﬃces).
Another approach for proving the RFN for G1 is to formalize the
proof of the Witnessing Theorem for G1 (Theorem VII.4.13). In general,
suppose that A(p) is a Σqi formula of the form
∃xB(p, x)
where B is a Πqi−1 formula (here i ≥ 1). We wish to deﬁne a witnessing function for A that, given the values for p, computes x that satisfy
q
B(p, x). The graph of the function is Πi−1 , so this suggests that the
witnessing function is in LFPi (see Deﬁnition VIII.7.6). For part (b) of
Theorem X.2.17 below we will outline the formalization of the proof of
the Witnessing Theorem for G1 . The proof of the general case is similar
and will be left as an exercise.
For part (c) of Theorem X.2.17 (due to Perron) we will need to formalize
a more complicated witnessing argument. We refer to [91] for a proof of
this part.
Theorem X.2.17. For i ≥ 1:
(a) V i  Πqi -RFN Gi−1 ;
(b) V i  Πqi+1 -RFN Gi ;
(c) [Perron] V i  Πqi+2 -RFN Gi .

401

X.2. The Reﬂection Principle

Proof. (a) Reasoning in V i . Let  be a Gi−1 proof of a Πqi formula.
By Exercise X.1.10 all formulas in  are Πqi . Moreover, it can be shown
that all formulas in the antecedents of sequents in  are in (Σqi−1 ∪ Πqi−1 ).
The idea is to prove by induction on t that the t-th sequent in  is valid.
Suppose ﬁrst that i ≥ 2. Let
St = A0 , . . . , An −→ B0 , . . . , Bm

(366)

be the t-th sequent in . Here all Aj are in (Σqi−1 ∪ Πqi−1 ) and all Bk are
in Πqi .
Deﬁnition X.2.18. For i ≥ 1 deﬁne (Z |=i X ) to be the formula
((Z |=Σqi X ) ∨ (Z |=Πqi X )).
Thus (Z |=i X ) iﬀ X is in Σqi ∪ Πqi and Z satisﬁes X . Note that
(Z |=i X ) is in (ΣBi+1 ∩ ΠBi+1 ).
Formally we will prove the following formula:



Bk ) .
(367)
∀Z ≤ || ∀j ≤ n(Z |=i−1 Aj ) ⊃ (Z |=Πqi
k

Since (Z |=i−1 X ) is ΣBi and Z |=Πqi X ) is ΠBi , by Corollary VI.3.8 we
can prove (367) by induction on t. Both the base case and the induction
step are straightforward.
Now we prove
V 1  Πq1 -RFN G0 .
Let  be a G0 -proof of a Πq1 formula. Let St as in (366) be the t-th sequent
in , here all Aj are quantiﬁer-free and all Bk are Πq1 formulas. We prove
in V 1 the following formula:



Aj ) ⊃ (Z |=Πq1
Bk ) .
(368)
∀Z ≤ || (Z |=Σ0
j

k

Because (Z |=Σ0 X ) is a ΣB1 formula and (Z |=Πq1 X ) is a ΠB1 formula,
(368) is equivalent in V 1 to a ΠB1 formula. Therefore (368) can be proved
in V 1 by induction on t (using ΠB1 -IND, see by Corollary VI.1.4).
(b) By Lemma X.2.14 it suﬃces to show that
V i  Σqi -RFN Gi .
Let  be a Gi proof of a Σqi formula A. First consider the case i = 1, and
consider the interesting case where A is in (Σq1 − Σq0 ). Note that by the
subformula property (see Exercise X.1.10) all formulas in  are Σq1 .
To show that this formula is valid, the idea is to prove the Witnessing Theorem for G1 (Theorem VII.4.13) that there is a polytime function that produces the witnesses for the existentially quantiﬁed variables.
Recall that this requires Theorem VII.4.7 and the second half of Theorem VII.4.16. It is straightforward to formalize in TV 0 the proof of both
theorems, and hence also the proof of Theorem VII.4.13.

402

X. Proof Systems and the Reﬂection Principle

The proof for the case where i > 1 is similar. Here the outermost
P
existentially quantiﬁed variables in A can be witnessed by some FPΣi−1
functions. These witnessing functions can in fact be deﬁned by examining
 directly (without introducing an analogue of ePK ). Details are left as
an exercise.
(c) By Lemma X.2.14 it suﬃces to show that
V i  Σqi+1 -RFN Gi .
This is Theorem 5.1.2 in [91].

2

*Exercise X.2.19. Prove part (b) above for the case where i > 1.
Corollary X.2.20. For i ≥ 0:
 ;
(a) TV i  Πqi+2 -RFN Gi+1
q
i
(b) TV  Πi+1 -RFN Gi .

is equivalent to a ∀ΣBi+1 sentence and by TheProof. (a) Πqi+2 -RFN Gi+1
orem X.2.17 (b) it is provable in V i+1 . By Theorem VIII.7.13 V i+1 is
 .
ΣBi+1 -conservative over TV i , hence TV i also proves Πqi+2 -RFN Gi+1
q
(b) Similar to part (a) here for i ≥ 1 the sentence Πi+1 -RFN Gi is ∀ΠBi+1 ,
which is the same as ∀ΣBi . So the fact that TV i proves Πqi+1 -RFN Gi follows
from the fact that V i+1 proves Πqi+1 -RFN Gi (Theorem X.2.17 (a)) and the
fact that V i+1 is ΣBi+1 -conservative over TV i .
For the case where i = 0, Πq1 -RFN G0 is a ∀ΠB1 sentence that is provable
in V 1 . Since V 1 is ΣB1 -conservative over TV 0 , Σq0 -RFN G0 is also provable
2
in TV 0 .

Exercise X.2.21.

(a) For i ≥ j ≥ 0, show that

⊃ Σqj -RFN Gi .
TV 0  Σqj -RFN Gi+1

(b) For i ≥ 0 and j ≥ 0, show that
 .
TV 0  Σqj -RFN Gi ⊃ Σqj -RFN Gi+1

(Hint: formalize the p-simulations given in the proofs of Theorems
VII.4.3 and VII.4.8.)
Π
B
*Exercise X.2.22. Let FlaΠ
PK and Prf ePK be Π1 formulas that represent
the relations FLAPK and PRF ePK , respectively. The Reﬂection Principle
for ePK is deﬁned as follows:


Π
Σ
RFN ePK ≡ ∀∀X ∀Z (FlaΠ
PK (X ) ∧ Prf ePK (, X )) ⊃ (Z |=0 X ) .

Note that RFN ePK is equivalent to a ∀ΣB1 sentence. Show that
TV 0  RFN ePK .
(Hint: show that V 1  RFN ePK and then use the fact that V 1 is ΣB1 conservative over TV 0 .)

X.2. The Reﬂection Principle

403

X.2.4. Axiomatizations Using RFN. In this section we present results
of the following type. We will show that the RFN of a proof system F (Gi
or Gi ) can be used together with a base theory (e.g., VTC 0 ) to axiomatize
the associated theory T (V i or TV i ). In Section X.2.3 above we have
shown one direction, i.e., the RFN of F is provable in T . For the other
direction we need to show that all theorems of T are provable from the
base theory and the RFN of F. Informally, this can be seen as follows.
First, the propositional version of each theorem of T have been shown to
have proofs in F that are deﬁnable in VTC 0 (Section X.1.2). So by the
0
RFN for F these propositional translations are valid. Next, VTC proves
that the validity of the propositional translations implies the validity of
the ﬁrst-order formulas (Theorem X.2.10 in Section X.2.2). As the result,
the theorem of T can be proved using VTC 0 and the RFN of F (because
0
VTC is a conservative extension of VTC 0 ).
First, we prove:
Theorem X.2.23. (a) Let i ≥ j ≥ 1. Then ΣBj (V i ), the ΣBj consequences of V i , can be axiomatized by the axioms of VTC 0 together
with Σqj -RFN Gi .
(b) For j ≥ 1 and i ≥ j + 1, ΣBj (V i ) can also be axiomatized by the
axioms of VTC 0 together with Σqj -RFN Gi−1 .
(c) For i ≥ 1, the theory V i can be axiomatized by the axioms of VTC 0
and Σqi+1 -RFN Gi . V i can also be axiomatized by the axioms of VTC 0
and Σqi+1 -RFN cut-free G  .
Proof. (a) Note that by Theorem X.2.17 (b) V i proves Σqj -RFN Gi .
Therefore Σqj -RFN Gi is a ΣBj consequence of V i . Since j ≥ 1, all axioms
of VTC 0 are also in ΣBj (V i ). Thus it remains to show that every ΣBj
consequence of V i can be proved in VTC 0 + Σqj -RFN Gi . We prove this
for i = j = 1, since other cases are similar. Here we have to show that all
ΣB1 theorems of V 1 are provable using VTC 0 + Σq1 -RFN G1 .
Suppose that ϕ is a ΣB1 theorem of V 1 . Assume without loss of generality
that it has a single free variable Z. Let Tϕ(Z) (n) be the FTC 0 function
0

as in Corollary X.1.13 that provably in VTC computes the encoding of
ϕ(Z)[n]. Thus we have

Tϕ(Z) (n) = ϕ(Z)[n]
and
0

VTC  FlaΠ
Σq (Tϕ(Z) (n)).
1

(369)

404

X. Proof Systems and the Reﬂection Principle

Now by Exercise X.1.17 there is an FTC 0 function Fϕ(Z) (n) that prov0

ably in VTC computes a G1 proof of ϕ(Z)[n]. In other words, we have
0

VTC  Prf Π
G1 (Fϕ(Z) (n), Tϕ(Z) (n)).

(370)

From (369) and (370), using Σq1 -RFN G1 we obtain
∀Z(Z |=Σq1 Tϕ(Z) (n)).
From this and Theorem X.2.10 we obtain ∀Zϕ(Z).
(b) This is suggested by (a) since by Corollary VII.4.9, Gi and Gi−1
are p-equivalent for proving Σqj formulas for j ≤ i − 1. However the
p-equivalence seems to require TV 0 rather than VTC 0 to prove, so we
prove (b) as follows.
Note that V i is ΣBi -conservative over TV i−1 (Theorem VIII.7.13). So
the proof here similar to (a). Here Theorem X.2.17 (a) gives us that
ΣBj (V i )  Σqj -RFN Gi−1 .
Therefore all consequences of VTC 0 + Σqj -RFN Gi−1 are also in ΣBj (V i ).
For the other direction, let ϕ be a ΣBj theorem ϕ of V i . Since V i is
B
Σi -conservative over TV i−1 , ϕ is also a theorem of TV i−1 and hence has
0
a Gi−1 proof which is provably computable in VTC (by Theorem X.1.21).
The argument is similar to (a).
(c) For the ﬁrst sentence, the fact that all theorems of V i are provable
from
VTC 0 + Σqi+1 -RFN Gi
can be proved as in part (a).
The proof of the other direction, i.e., that V i proves Σqi+1 -RFN Gi , is
part (c) of Theorem X.2.17.
The second sentence follows from the ﬁrst and Theorem X.2.27 below.
2
i
As a corollary, we obtain a ﬁnite axiomatization of TV as follows.
Corollary X.2.24. (a) For i ≥ 0, the theory TV i can be axiomatized
 .
by the axioms of VTC 0 together with Σqi+1 -RFN Gi+1
i
(b) For i ≥ 1, the theory TV can be axiomatized by the axioms of TV 0
and Σqi+1 -RFN Gi .
Proof. Part (a) follows from Theorem X.2.23 (a) applied to ΣBi+1(V i+1 ),
and the fact that TV i can be axiomatized by the ΣBi+1 consequences of
V i+1 , because TV i have ΣBi+1 axioms and V i+1 is ΣBi+1 -conservative over
TV i (Theorem VIII.7.13).
Part (b) follows from (a) and Exercise X.2.21.
2
We obtain an alternative proof for the ﬁnite axiomatizability of the
theories TV i (see Theorem VIII.7.3):

X.2. The Reﬂection Principle

405

Corollary X.2.25. For i ≥ 0 the theories V i+1 and TV i are ﬁnitely
axiomatizable. For i ≥ j ≥ 1, the ΣBj consequences of V i are ﬁnitely
axiomatizable.
Proof. The conclusion follows from Corollary X.2.24 and Theorem
X.2.23, and the fact that VTC 0 is ﬁnitely axiomatizable.
2
Exercise X.2.26. Show that TV 0 can be axiomatized by the axioms
of VTC 0 together with RFN ePK deﬁned in Exercise X.2.22. (Hint: one
direction follows from Exercise X.2.22. For the other direction, use Exercise X.1.23.)
In Theorem X.2.23 above we have considered Σqj -RFN Gi only for the
values of j such that 1 ≤ j ≤ i. Now we consider Σqj -RFN Gi for j > i.
It turns out that in this case Σqj -RFN Gi is equivalent to Σqj -RFN cut-free G  ,
because any Gi proof of a Σqj formula can be transformed into a cut free
G  proof of an equivalent Σqj formula A . This observation is due to Perron
[91]. Here we need VTC 0 to prove the equivalence, essentially because the
transformation given in the proof below is computable in TC 0 (while the
equivalence between A and A is provable in V 0 ).
Theorem X.2.27. Let i ≥ 0. The theory VTC 0 proves that the following
are all equivalent:
Σqi+1 -RFN cut-free G  , Σqi+1 -RFN G0 , . . . , and Σqi+1 -RFN Gi .
Proof. Since cut-free G  is a subsystem of G0 , which in turn is a sub0

system of G1 , etc., and since VTC is a conservative extension of VTC 0 ,
it suﬃces to show that
0

VTC + Σqi+1 -RFN cut-free G   Σqi+1 -RFN Gi .
The idea is as follows. Let  be a Gi proof of a Σqi+1 formula A. We
will transform  into a cut free G  proof of a Σqi+1 formula A of the form
(372) below. Our transformation can be seen to be in TC 0 . So, formally,
0
the transformed prove is provably in VTC computable by some FTC 0
q
function F . Then using Σj -RFN cut-free G  we have that A is valid. Finally,
since V 0 proves that A and A are equivalent we conclude that A is valid.
We will ﬁrst transform  into a cut-free G  proof of the following sequent:
−→ A, ∃(C1 ∧ ¬C1 ), ∃(C2 ∧ ¬C2 ), . . . , ∃(Ck ∧ ¬Ck )

(371)

where Ct (for 1 ≤ t ≤ k) are all cuts formulas in , and ∃(Ct ∧ ¬Ct ) is
the sentence obtained from (Ct ∧ ¬Ct ) by existentially quantifying all free
variables. Then, by using the ∨-right we get a proof of

(∃(Ct ∧ ¬Ct )).
(372)
A =def A ∨
1≤t≤k

406

X. Proof Systems and the Reﬂection Principle

Notice that each Ci is a Σqi formula, so A is in Σqi+1 .
The derivation from (371) to
−→ A
is obvious, so we will focus on the derivation of (371).
Let Δ denote the sequence
∃(C1 ∧ ¬C1 ), ∃(C2 ∧ ¬C2 ), . . . , ∃(Ck ∧ ¬Ck )
as in (371). We transform  as follows. First, add Δ to the succedent of
every sequent in . For each sequent S in  let S  be the result of this
addition.
To obtain a legitimate derivation, note that if S is derived from S1 (and
S2 ) by an inference of G, then S  can be derived from S1 (and S2 ) by the
same inference with possibly some applications of the exchange rule. In
addition, each axiom B −→ B now becomes B −→ B, Δ so we also add
the following derivation (using weakening)
B −→ B
========
B −→ B, Δ
Thus, the result, called 1 , is a Gi proof.
Next, consider an instance of the cut rule in 1 :
Λ −→ Γ, Δ, C

C, Λ −→ Γ, Δ

Λ −→ Γ, Δ
We insert the following derivation
C, Λ −→ Γ, Δ
Λ −→ Γ, Δ, C

Λ −→ Γ, Δ, ¬C

Λ −→ Γ, Δ, (C ∧ ¬C )
==================
Λ −→ Γ, Δ, ∃(C ∧ ¬C )
==================
Λ −→ Γ, Δ
Here the bottom double line represents applications of exchange and
contraction right. The double line above it represents a series of ∃-right.
It can be seen that the result is a cut-free G  proof of (371) as desired.
We will brieﬂy verify that the above transformation is computable in TC 0 .
The fact that it can be formalized in VTC 0 is straightforward.
For the transformation, ﬁrst we need to identify all cuts and cut formulas
in  (here we need TC 0 circuits to recognize formulas). Once this has been
done, it is easy to see that the cut free G  proof of (371) described above
can be computed by some TC 0 circuit (here we need the counting gates,
e.g., to put ∃(Ct ∧ ¬Ct ) into the list Δ). The last step is to obtain a
derivation of A from (371), and this can also be computed by a TC 0
circuit.
2

X.2. The Reﬂection Principle

407

X.2.5. Proving p-Simulations Using RFN. In this section we will show
how to use the Propositional Translation Theorems (e.g., Theorems
VII.5.2, X.1.21) to prove p-simulations between proof systems. Informally, the result is as follows. Suppose that G (such as G1 ) is a proof
system associated with a theory T (such as V 1 ) (where the association is
by propositional translation). Then any proof system F (such as eFrege)
which is deﬁnable in T and whose RFN is provable in T is p-simulated
by G. (See the precise statement in Theorem X.2.29 below.)
Intuitively the reason why G p-simulates such F is as follows. Because T
proves the soundness (i.e., the RFN) of F , and G is a nonuniform version
of T , there are short G derivations of the fact that F is sound. Therefore,
given a proof of F of A we can derive a short G derivation of A (we will
need the derivations from Theorems X.2.5 and X.2.8).
First we need to prove in Gi the “honesty” of our encoding of the RFN.
Here we translate the RFN for a system F by treating the variables , X
and Z (Deﬁnition X.2.11) as free variables and introducing the bits
p0 , p1 , . . . ;

p0X , p1X , . . . ;

p0Z , p1Z . . .

as usual.
Recall Deﬁnition X.1.6 that for some constant values of 0 and X0 of
length n and m respectively, we use
Σqi -RFN F (0 , X0 , Z)[k]

(373)

to denote the result of substituting the values ( or ⊥) of bits X0 (t), 0 (t)
for the variables ptX and pt in the propositional translation
Σqi -RFN F (, X, Z)[n, m, k]
where m = |X0 | and n = |0 |. (Thus the only free variables in (373) are
p0Z , p1Z , . . . .) For a Σqi formula X0 , note that the translation (373) is
Π
q
q
(FlaΠ
Σ (X0 ) ∧ Prf F (0 , X0 ))[ ] ⊃ (Z |=Σi X0 )[k].
i

For the proof of the theorem below, it is helpful to review Theorems X.2.5 and X.2.8 and their proofs.
Theorem X.2.28. Let i ≥ 1 and F be a proof system with deﬁning
formulas Prf ΣF and Prf Π
F as in (322) and (323) (on page 367). Then there is
a polytime algorithm that computes a Gi proof of the sequent below for each
Σqi formula A0 of length m with at most k − 1 free variables, and F-proof
0 of A0 of length n:
−
→
0 , Z)[k] −→ A0 (pZ ).
Σqi -RFN F (0 , A
Proof. The desired sequent is obtain from the sequent in Theorem
X.2.8 and the following sequent by a Σqi cut:
0 , Z)[k] −→ (Z |=Σq A
0 )[k].
Σqi -RFN F (0 , A
i

408

X. Proof Systems and the Reﬂection Principle

In turns, the sequent above can be derived from


0 ) ∧ Prf Π (0 , A
0 ) [ ].
−→ FlaΠ (A
F
A G0 proof of this sequent can be computed in polytime as follows from
Lemma X.1.7.
2
Theorem X.2.29. Let i ≥ j ≥ 1.
(a) Suppose that F is a proof system such that
V i  Σqj -RFN F .
Then Gi p-simulates F w.r.t. Σqj formulas.
(b) The same is true for TV i and Gi in place of V i and Gi .
Proof. (a) Let A0 (p) be a Σqj formula and 0 be an F -proof of A0 (p).
0 denote the string encoding of A0 (p). Let n = |0 |, m =
As before, let A
0 |. From the hypothesis and the Propositional Translation Theorem
|A
for V i (Theorem VII.5.2, see also Exercise X.1.17), there are polytime
computable Gi proofs of the translations
0 , Z)[k].
Σqj -RFN F (0 , A
Now using the Gj proof from Theorem X.2.28 we obtain a Gi proof
−
→
of A0 (pZ ).
Part (b) is proved similarly.
2
*Exercise X.2.30. Let F be a proof system for (unquantiﬁed) propositional formulas. Suppose that RFN F (i.e., Σq0 -RFN F , see Deﬁnition
X.2.11) is provable in TV 0 . Show that ePK p-simulates F . (Hint: use
Theorem X.2.29 (a) for i = 1 and Theorem VII.4.16.)
We obtain as corollaries some results proved earlier in Chapter VII
(Corollary VII.4.9 and Theorem VII.4.16).

Corollary X.2.31. For i ≥ 1, Gi+1
and Gi are p-equivalent when provq
q

ing Σi formulas. ePK and G1 are p-equivalent for proving prenex Σ1 formulas.
X.2.6. The Witnessing Problems for G. Recall the notion of search
problems deﬁned in Section VIII.5 (see Deﬁnitions VIII.5.1 and
VIII.5.11). Recall also the witnessing problem given in Theorem VII.4.13.
In general, the witnessing problems for (subsystems of) G are search problems that are motivated by the following observation. Let i ∈ N, i ≥ 1,
and consider a Σqi tautology A(p) of the form
A(p) ≡ ∃xB(x, p)
where B is a Πqi−1 formula. Given A and the values for p we wish to ﬁnd
a truth assignment for the existentially quantiﬁed variables x that satisﬁes
P
B(x, p). Note that this problem is polytime complete for FPΣi . However,

409

X.2. The Reﬂection Principle

a given G-proof  of A(p) may help us ﬁnd x, and it becomes interesting
to study the problems when diﬀerent proofs  are given.
Formally, the problems are deﬁned as follows.
Deﬁnition X.2.32 (Witnessing Problem). For a quantiﬁed propositional proof system F and 1 ≤ i ∈ N, the Σqi Witnessing Problem for F ,
denoted by Σqi -WIT F , is, given an F-proof  of a Σqi formula A(p) of the
form
A(p) ≡ ∃xB(x, p)
where B is a Πqi−1 formula, and a truth assignment to p, ﬁnd a truth
assignment for x that satisﬁes B(x, p).
Not surprisingly, the Witnessing Problems for Gi and Gi are closely
related to the classes of deﬁnable search problems in the associated theories. For the next theorem it is useful to refer to the the summary table on
page 250.
Recall the notion of many-one reduction between search problems (Definition VIII.5.2). For the next theorem we use the notion of TC 0 manyone reduction between search problems. This is deﬁned just as in Deﬁnition VIII.5.2 with the exception that the functions f, F , G are now in
FTC 0 (as opposed to FAC 0 ). The reason that we need TC 0 reductions here
is basically because our translation functions (such as in Exercise X.1.17)
are TC 0 functions. Theorem X.2.33 is about the witnessing problems for
Gi and Gi for i ≥ 1. In Theorem X.3.12 we will state the results for G0
and G0 .
Theorem X.2.33. For i ≥ 1:
P

(a) Σqi -WIT Gi is TC 0 -complete for FPΣi−1 .

P

(b) Σqi -WIT Gi is TC 0 -complete for CC(PLS)Σi−1 .
P
(c) Σqi+1 -WIT Gi is TC 0 -complete for FPΣi [wit, O(log n)].
P

Proof. (a) First we show that Σqi -WIT Gi is in FPΣi−1 . Consider the
case i = 1. Here the Witnessing Theorem for G1 (Theorem VII.4.13)
q
already shows that Σ1 -WIT G1 is in P. The case where i > 1 is similar.
In fact, we have pointed out in the proof of Theorem X.2.17 (b) that by
analyzing , a witnessing function can be deﬁned in V i by a ΣBi formula.
P
Now we show that Σqi -WIT Gi is hard for FPΣi−1 . Thus let Q(x, X ) be
P

a search problem in FP Σi−1 with graph R(x, X , Z). We show that Q is
q
reducible to Σi -WIT Gi . By Theorem VIII.7.12 Q is ΣBi -deﬁnable in V i by
a ΣBi formula ϕ(x, X , Z), i.e.,
ϕ(x, X , Z) ⊃ R(x, X , Z)
and
V i  ∃Z ϕ(x, X , Z).

410

X. Proof Systems and the Reﬂection Principle

By the V i Translation Theorem (Theorem VII.5.2) the ΣBi theorem
∃Z ϕ(x, X , Z) of V i translates into a family of tautologies that have
polynomial-size Gi proofs. In fact, by Exercise X.1.17 there is a TC 0
0
function Fϕ (x, X ) that provably in VTC computes a Gi proof of the
translation of ϕ. Thus, given (x, X ), a value for Z that satisﬁes ϕ(x, X , Z)
can be easily obtained from the solution of the witnessing problem given
by Fϕ (x, X ) and (x, X ).
P
(b) The fact that Σqi -WIT Gi is complete for CC(PLS)Σi−1 is proved
i
similarly using Corollary X.2.20 (b), the TV Translation Theorem X.1.21
and Theorem VIII.7.14.
P
(c) Similar to part (a). Here Σqi+1 -WIT Gi is in FPΣi [wit, O(log n)]
q
because Σi+1 -RFN Gi is provable in V i (Theorem X.2.23 (c)) and ΣBi+1 P

deﬁnable search problems in V i are in FPΣi [wit, O(log n)] (Theorem
P
VIII.7.17). The fact that Σqi+1 -WIT Gi is hard for FPΣi [wit, O(log n)] also
follows from Theorem VIII.7.17 and the V i Translation Theorem VII.5.2
as in (a).
2
The Witnessing Problems for G0 and G0 are discussed in the next section.

X.3. VNC 1 and G0
Recall the theory VNC 1 from Section IX.5.3. Here we will show that
bounded theorems of VNC 1 translate into tautologies with polynomial
size G0 -proofs. (Section X.3.1.) It will follow that ΣB0 theorems of VNC 1
translate into families of propositional tautologies that have PK proofs
0
which are provably in VTC computable by FTC 0 functions.
In order to prove the RFN for PK in VNC 1 we need to show that the
relation (Z |=0 X ) (that the truth assignment Z satisﬁes a formula X ,
see Section X.2.1) is ΔB1 -deﬁnable in VNC 1 . For this we will formalize
in VNC 1 an NC 1 algorithm, due to Buss, that computes the Boolean
Sentence Value Problem (BSVP). We will present the algorithm in Section X.3.2 and its formalization in VNC 1 in Section X.3.3.
X.3.1. Propositional Translation for VNC 1 . Recall (Section VII.4) that
G0 is the subsystem of G  in which all cut formulas are quantiﬁer-free.
Note also that G0 is p-equivalent to G0 with respect to prenex Σq1 formulas
(Theorem VII.4.5).
Recall (Section IX.5.3) that the theory VNC 1 is axiomatized by the
axioms of V 0 together with the axiom MFV (for monotone formula value)
that asserts the existence of a string Y which evaluates all subformulas of
a balanced formula (encoded by (a, G, I )):
∃Y ≤ 2aMFV (a, G, I, Y )

X.3. VNC 1 and G0

411

where

MFV (a, G, I, Y ) ≡ ∀x < a (Y (x + a) ↔ I (x)) ∧ Y (0) ∧


0 < x ⊃ Y (x) ↔ (G(x) ∧ (Y (2x) ∧ Y (2x + 1))) ∨

(¬G(x) ∧ (Y (2x) ∨ Y (2x + 1))) . (374)
Our goal in this section is to prove the following theorem. Recall Deﬁnition X.1.9.
Theorem X.3.1 (Translation Theorem for VNC 1 ). Let ϕ(x, X ) be a
bounded theorem of VNC 1 . Then there is an FTC 0 function Fϕ (m, n)
0

that provably in VTC computes a G0 proof of the propositional formulas
ϕ(x, X )[m; n] for all m, n in N.
Our translation of an anchored LK 2 -VNC 1 proof (in free variable normal form) of a bounded theorem of VNC 1 extends the translation of
LK 2 -V 0 proofs discussed in Section VII.5.1. Here the new type of cut formulas are instances of the formula ∃YMFV (a, G, I, Y ) (see (374)). Note
that the length |Y | in MFV is bounded by 2a. To make the translation

(a, G, I, Y )
easier we will ﬁx |Y |. Thus we will use another axiom MFV
deﬁned below, where now the length |Y | of Y is required to be exactly
2a + 1. Informally, this is easily obtained by adding a ﬁxed leading bit
(bit 2a) to the string Y .
The fact that the new axiom is equivalent to MFV over V 0 is easy and
is left as an exercise.

Exercise X.3.2. Let MFV
(a, G, I, Y ) denote

|Y | = 2a + 1 ∧ Y (0) ∧ ∀x < a (Y (x + a) ↔ I (x)) ∧ 0 < x ⊃


Y (x) ↔ (G(x) ∧ Y (2x) ∧ Y (2x + 1)) ∨

(¬G(x) ∧ (Y (2x) ∨ Y (2x + 1))) . (375)

Then VNC 1 can be axiomatized by V 0 together with

MFV  ≡ ∃Y MFV
(a, G, I, Y ).

As a result, every theorem of VNC 1 has an anchored LK 2 proof in which
cut formulas are instances of the axioms of V 0 or the axiom MFV  above.
To prove the Theorem X.3.1 we will ﬁrst translate LK 2 proofs of this
type, and then argue that the translation is indeed provably computable
0
in VTC .
Translating the proof of a bounded theorem of VNC 1 is done by extending the translation of LK 2 -V 0 proofs as described in Section VII.5.1. Here
we have to consider in addition instances of the axiom MFV  above. Like
the translations of the ΣB0 -COMP cut formulas, here the translations of
the cut MFV  formulas will be tautologies that have PK proofs which are

412

X. Proof Systems and the Reﬂection Principle
0

provably in VTC computable. Recall the notions such as comprehension
variables from Section VII.5.1.
Proof of Theorem X.3.1. By Exercise X.3.2 above, there is an anchored LK 2 -proof  of ϕ where all cut formulas are instances of the
axioms of V 0 or instances of the axiom MFV  . In addition, we can
assume that  is in free variable normal form.
The translations of cut ΣB0 -COMP formulas as described in the proof
of Theorem VII.5.6 can be extended here easily. So we will focus on the
instances of the cut MFV  axiom. Similar to the notion of comprehension
variables, we deﬁne:
Notation. A free string variable  in  is called an MFV variable if it is
used as the eigenvariable for the string-∃-left rule whose principal formula

is an ancestor of a cut formula of the form ∃Y MFV
(t, α, , Y ). In this
case, we also say that (t, α, ) is the deﬁning triple of .
For example, consider an instance of the string-∃-left rule:
S1
S2

=


(t, α, , ), Γ −→ Δ
MFV

∃YMFV
(t, α, , Y ), Γ −→ Δ

(376)


Suppose that the formula ∃YMFV
(t, α, , Y ) in S2 is an ancestor of a cut
formula. Then  is an MFV variable.
In our translation below, if two MFV variables have the same deﬁning
triple, they will have identical translations.
Next, we extend the deﬁnition of the dependence relation deﬁned in the
proof of Theorem VII.5.6 to include MFV variables.

Notation. We say that an MFV variable  depends on a variable
b) if (or b) occurs in the deﬁning triple of .

(or

The dependence degree of a variable is deﬁned as before by taking into
account the fact that now there are also MFV variables. Formally, all
variables that are not comprehension variables nor MFV variables have
dependence degree 0. The dependence degree of a comprehension variable
(resp. an MFV variable)  is one plus the maximum dependence degree
of all variables occurring in its deﬁning pair (resp. deﬁning triple).
Before translating formulas in  we will remove from  the right branch
of a cut rule if the cut formula is an MFV  instance or a ΣB0 -COMP
instance, and remove all remaining MFV  instances that are ancestors of
a cut formula (i.e., the MFV  instance in (376) and all its descendants) as
well as instances of ΣB0 -COMP that are ancestors of a cut formula. The

reason for doing this is that MFV
(t, α, , ) will translate into tautologies

that have short PK proofs, and hence the translations can be cut. The
same is true for the ΣB0 matrix of ΣB0 -COMP (as shown in the proof of
Theorem VII.5.6).

X.3. VNC 1 and G0

413

Now the formulas in  are translated in stages just as described in the
proof of Theorem VII.5.6. Here the only new case to be handled is the
case of a atomic formula of the form (s) for an MFV variable . Thus,
let  be an MFV variable, and suppose that (t, α, ) is the deﬁning triple
of  as in (376). Note that the length of  is (2t + 1). Let n be the list of
values/lengths of all non-MFV variables in . The translation (s)[n] is
deﬁned by (reverse) induction on val(s) as follows.
Let m = val(t). First, suppose that m ≤ val(s) < 2m, then
(s)[n] =def

(r)[n]

where r is the numeral val(s) − m. Next, suppose that 1 ≤ val(s) < m,
then
(s)[n] =def (A ∧ (B0 ∧ B1 )) ∨ (A ∧ (B0 ∨ B1 ))

(377)

where A ≡ α(s)[n], B0 ≡ (2s)[n], and B1 ≡ (2s + 1)[n]. Finally,

⊥ if val(s) > 2m,
(s)[n] =def
 if val(s) = 2m ∨ val(s) = 0.
0

We show that the translations above are provably in VTC computable.
Lemma X.3.3. For each L2A formula ϕ(x, X ) in  there is an FTC 0 func0
tion Fϕ, (k, n) that provably in VTC computes the translation ϕ(x, X )[k; n]
as described above.
Proof sketch. Following our translation of formulas in , Fϕ, will
be deﬁned in stages: for i ≥ 0, in stage i we deﬁne the functions for all
formulas ϕ that contain some variable of dependence degree i but none
of higher degree.
In each stage the construction is by structural induction on the formula
ϕ. Stage 0 is exactly the same as in Exercise X.1.15; and in general, for
each stage i (where i ≥ 1) except for the base case of the formulas (s)
for MFV variables , the arguments are the same as in Exercise X.1.15.
So now consider the base case of stage i where i ≥ 1. Let  be an MFV
variable of dependence degree i, and let (t, α, ) be the deﬁning triple for
. We need to deﬁne the function F(s), . As before, let m = val(t). Then
note that the length of  is understood to be 2m + 1.
Let b = val(s). If b = 0 or b ≥ m then by deﬁnition (s)[n] is a
constant  or ⊥ or is a function that has been deﬁned in the previous
stage. So consider the case where 1 ≤ b < m.
By the deﬁnition (377), (s)[n] can be seen as a binary tree whose leaves
are labeled with α(s)[n], (s)[n] and (2s)[n], (2s + 1)[n]. Intuitively we
will expand this tree repeatedly at the leaves (2s)[n], (2s + 1)[n] until
all leaves are labeled with either α(r)[n] or (r)[n] for some r.
The depth of the ﬁnal tree can be shown to be computable by some AC 0
functions (recall Section III.3.3, for example, that the function log(x) is

414

X. Proof Systems and the Reﬂection Principle

in AC 0 , where log(x) is the length of the binary representation of x).
Additionally, the labels of the nodes on all paths from the root to the
leaves of the tree can be identiﬁed by AC 0 functions. From these facts,
using the counting gates we can compute the string that concatenates all
labels on the nodes with parentheses properly inserted.
2
Now we verify that for every sequent S in  that is not on the right
branches of the cut ΣB0 -COMP or cut MFV  instances, there are provably
in VTC 0 computable G0 proofs of the translation of S. The proof is by
induction on the sequent S. Except for the case of the string ∃-left that
introduces a cut MFV  instance, all cases are the same as in the proof of
Theorem X.1.14.
So consider an instance of the string ∃-left that introduces a cut MFV 
as in (376). Consider the interesting case where the translation of S1 is
not simpliﬁed to an axiom, and thus has the form

S1 [n] = MFV
(t, α, , )[n], Γ −→ Δ .

Then S translates into
S[n] = Γ −→ Δ .
In order to obtain S[n] from S1 [n], we need to derive the tautology


MFV
(t, α, , )[n] and then apply the cut rule. Here note that MFV
(t, α, ,
)[n] is just a conjunction of the form
(Bi ↔ Bi )
where Bi is the translation of (s) when val(s) = i, for 1 ≤ i < 2val(t).

Hence MFV
(t, α, , )[n] can be easily derived from the axioms
Bi −→ Bi .
0

Given the FTC functions that compute the translations of formulas in
S1 , it is straightforward to obtain an FTC 0 function that computes the
above derivation of S[n] from S1 [n]. By the same arguments as in the
proof of Theorem X.1.14, it follows that the G0 proofs can be provably in
0

VTC computed by some FTC 0 functions.
2
The next corollary follows easily.
Corollary X.3.4. For any ΣB0 theorem ϕ of VNC 1 , there is an FTC 0
0

function that provably in VTC computes PK  proofs of the family of tautologies #ϕ#.
X.3.2. The Boolean Sentence Value Problem. Recall (page 321) that the
Boolean Sentence Value Problem (BSVP) is to determine the truth value
of a Boolean sentence. Here the sentence is given as a string over the
alphabet:
{, ⊥, (, ), ∧, ∨, ¬}.

(378)

X.3. VNC 1 and G0

415

The sentence is viewed as a tree whose leaves are labeled with constants
, ⊥ and whose inner nodes are labeled with connectives. Note that when
the tree representing a sentence A is a balanced binary tree then it is
straightforward to show that there is an ALogTime algorithm that computes the value of A. In fact, by using the axiom MFV (Deﬁnition IX.5.4)
we can easily formalize in VNC 1 such an algorithm. However designing
an ALogTime algorithm for a general tree structure is more diﬃcult. The
algorithm given in the proof of Theorem X.3.5 below is a slight modiﬁcation of Buss’s algorithm given in [25].
Theorem X.3.5 (Buss). The Boolean Sentence Value Problem is in
ALogTime.
Proof. We give an algorithm in terms of a game between two players:
one is called the Pebbler and the other is called the Challenger. The game
is deﬁned so that the Pebbler has a winning strategy if and only if the given
Boolean sentence is true. The actual algorithm works by ﬁrst playing the
game and then determining the winner.
By using De Morgan’s laws we can remove all occurrences of ¬ from
the sentence. This transformation requires counting the number of occurrences of the ¬ connective along each path in the tree and therefore can be
done in TC 0 . Thus we can assume that the underlying tree is a binary tree
whose inner nodes are labeled with ∨ or ∧ and whose leaves are labeled
with  and ⊥. By padding the sentence with ∧ we can assume that the
tree has exactly (2d +1 − 1) leaves, for some d ≥ 1. We number the leaves
of the tree from left to right with
1, 2, . . . , 2d +1 − 1.
(We do not number inner nodes of the tree.)
The pebbling game. The game will be played in at most d rounds; each
round consists of a move by the Pebbler followed by a move by the Challenger. In each round the Pebbler will assert the values of some nodes in
the tree (by pebbling them with Boolean values) and the Challenger must
deny the Pebbler’s assertion by challenging one of the pebbled nodes. The
Challenger is required not to challenge any node that has been pebbled
but unchallenged in a previous round. In eﬀect, the Challenger implicitly
agrees with the Pebbler on all pebbled descendants of the currently challenged node. (Following a play of the game, the challenged nodes lie on
a path from the root to some agreed node.) The idea is that at the end
of at most d rounds the value of the challenged node is easily computed
from an agreed node and some leaves, thus revealing the winner of the
game. Intuitively, a winning strategy for the Pebbler is to pebble the nodes
with their correct values, and if the Pebbler fails to do so, the Challenger
can win by challenging some incorrectly pebbled node. So by having the
Pebbler start with pebbling the root with , the sentence is true iﬀ the
Pebbler has a winning strategy.

416

X. Proof Systems and the Reﬂection Principle

The i-th round of the game involves the following nodes: ci (c for
challenged), ai (a for agreed), ui , vi , ui1 , ui2 , vi1 , vi2 (uij and vij are children
of ui and vi , respectively) and leaves i ( for left) and ri (r for right). In
general, i < ri , and i (resp. ri ) is never to the right (resp. left) of the
subtree rooted at ai . Moreover, ai is always a descendant of ci , ui as well
as vi . As i increases, the challenged nodes ci move down a path from the
root. Also, all leaf descendants of ci that are not descendants of ai are
numbered in the range
{i − 2d −i + 1, . . . , i , . . . , i + 2d −i − 1} ∪
{ri − 2d −i + 1, . . . , ri , . . . , ri + 2d −i − 1}.
Therefore after d rounds the Pebbler’s asserted value of the challenged
node cd can be compared with the appropriate combination of ad and the
leaves d , rd , allowing us to determine the winner of the game. A possible
conﬁguration of the nodes is given in Figure 14. Here we orient the tree
so that the leaves are at the bottom of the diagram.
Each move by a player will be speciﬁed by a constant number of bits
0, 1. Essentially, the moves by the Pebbler (resp. the Challenger) can be
interpreted as the existential (resp. universal) states, and playing the game
can therefore be seen as running an alternating Turing machine in logtime.

...
.

vi

vi1

vi2

ci

ui1

.

(

i
2

...

a i = ui
ui2

( )

.

)

ri
2d −i

d −i

Figure 14. One possible conﬁguration.
In the i-th round the Pebbler pebbles nodes
ui , vi , ui1 , ui2 , vi1 , vi2

X.3. VNC 1 and G0

417

with some Boolean values, and the Challenger must either challenge one
of these nodes or rechallenge a node it has challenged in the previous
round. The Pebbler needs six bits for this task, and the Challenger needs
three.
Later we will summarize the conditions for ending the game in less than
d rounds. For instance, the game will end if the Challenger challenges
either ui or vi . This is because, for example, the asserted value of ui can
be compared with the asserted values of ui1 and ui2 , or if ui is a leaf its true
value is readily available.
The nodes of the i-th round are determined as follows. First, ci is the
challenged node from the previous round (c1 is understood to be the root).
Also,
1 = 2d −1 ,
r1 = 2d + 2d −1 .
a1 = 2 d ,
For i ≥ 1:
vi = lca(ai , ri )
ui = lca(i , ai ),
where lca(n1 , n2 ) denotes the least common ancestor of nodes n1 and n2 .
The nodes ui1 and ui2 are the left and right children of ui , respectively. (If
ui is a leaf, then ui1 = ui2 = ui .) Similarly for vi1 and vi2 .
Next, for the (i + 1)-st round (where 1 ≤ i < d ) ai+1 , i+1 , ri+1 are
determined based on the relative positions of ci , ui and vi . For this
purpose we need the following notation. Let
n1  n2
denote the fact that node n1 is a proper ancestor of n2 , and
n1  n2
stand for n1  n2 or n1 = n2 . It will be true in general that
ci  a i ,

ui  ai ,

v i  ai .

As a result, the only possible relative positions for ci , ui , vi are listed in
Table 4 below. Will refer to the cases by their number later.
Case 1

Case 2

Case 3

Case 4

ui = vi

ci  ui  vi

c i  v i  ui

u i  ci  v i

Case 5

Case 6

Case 7

v i  c i  ui

u i  v i  ci

v i  ui  c i

Table 4. Possible relative positions of ci , ui , vi .
Note that exactly one of these cases will hold, and the Pebbler will use
three bits to specify which one holds. Also, ui = vi only if ui = vi = ai .
The game ends in round i if the Challenger challenges ui or vi . So
we can assume that these two nodes are not challenged. First, suppose

418

X. Proof Systems and the Reﬂection Principle

that in round i the Challenger challenges ui1 (i.e., ci+1 = ui1 ). The game
ends in round i if ui  ci (Cases 4, 6, 7) or ui = vi (Case 1), because in
this case the Challenger does not challenge a descendant of the currently
challenged node. For other cases,
ai+1 = i ,

i+1 = i − 2d −i−1 ,

See an illustration in Figure 15.

ui1

. .

.

(
i − 2d −i

i+1

i
ai+1

ri+1 = i + 2d −i−1 .

.
...
.

(

(379)

ci

ui
ui2
ai

)

ri+1

.
ri

)
ri + 2d −i

Figure 15. ci+1 = ui1 (vi , vi1 , vi2 are not shown).
Now suppose that the Challenger challenges ui2 in the i-th round. The
game ends if ui = vi (Case 1). If ui  vi (Cases 2, 4, 6) then (see Figure 16
for an illustration):
ai+1 = vi ,

i+1 = i + 2d −i−1 ,

ri+1 = ri + 2d −i−1 .

(380)

Otherwise, vi  ui (Cases 3, 5, 7), and
ai+1 = ai ,

i+1 = i + 2d −i−1 ,

ri+1 = ri − 2d −i−1 .

Note that if ci is a proper descendant of ui2 then the Challenger will lose
(see below).
The cases where the Challenger challenges vi1 or vi2 are similar. So
suppose now that in the i-th round the Challenger rechallenges ci . The
nodes ai+1 , i+1 and ri+1 are set as as speciﬁed in Table 5. Figure 17
illustrates Case 1.
In summary, in each round the Pebbler gives nine bits specifying the
truth values of ui , vi , ui1 , ui2 , vi1 , vi2 and the relative positions of ci , ui , vi
given in Table 4. (It is understood that the Pebbler also pebbles the root
with  in the ﬁrst round.) Each move by the Challenger consists of giving
three bits specifying the challenged node.
The following moves cause the Pebbler to lose the game:

X.3. VNC 1 and G0

.
...
.
.

419

ci

ui
ui1

ui2

vi = ai+1

ai

. .
i

. .

)

ri

i+1

)

ri+1

Figure 16. ci+1 = ui2 and ci  ui  vi .

.
.
. .. .
ci

ai

(

i+1

ui = vi

i

ri

)

ri+1

Figure 17. ci+1 = ci and ui = vi .

Case

ui = vi ci  ui  vi ci  vi  ui ui  ci  vi vi  ci  ui ui , vi  ci
(1)
(2)
(3)
(4)
(5)
(6,7)

ai +1
i +1
ri +1

ai
i − t
ri + t

ui
i − t
ri + t

vi
i − t
ri + t

vi
i + t
ri + t

ui
i − t
ri − t

ai
i + t
ri − t

Table 5. The Challenger rechallenges ci (i.e., ci+1 = ci ).
Here t = 2d −i−1 .
1) Pebble a leaf with the wrong value, or pebble incompatible values
for ui , ui1 , ui2 , vi , vi1 , vi2 . For example, u1 is an ∧ node and u1 is
pebbled with ⊥ while both ui1 and ui2 are pebbled with .
2) Pebble a node with both  and ⊥.

420

X. Proof Systems and the Reﬂection Principle

3) Make a wrong assertion about the relative positions of ci , ui and vi .
The Challenger loses if he
1) challenges a correctly pebbled leaf;
2) challenges ui or vi when they are pebbled compatibly with ui1 , ui2 ,
vi1 , vi2 ;
3) in round i does not challenge a descendant of the currently challenged node ci ;
4) in round i challenges a descendant of the currently agreed node ai .
The game is played in at most d rounds. It may end in less than d rounds
if a player obviously makes a mistake listed above and therefore loses the
game. Thus the game ends as soon as
1) The Challenger challenges either ui or vi ,
2) The Challenger challenges ui1 when the Pebbler says ui  ci (Cases
4, 6, 7),
3) The Challenger challenges vi2 when the Pebbler says vi  ci (Cases
5, 6, 7),
4) The Challenger challenges uij or vij when the Pebbler says ui = vi
(Case 1).
Claim. The Pebbler has a winning strategy iﬀ the given sentence is true.
The Claim is straightforward: If the sentence is true, the Pebbler can
always win by pebbling the nodes with their correct values and stating
the correct relative positions of ci , ui , vi . If the sentence is false then
the Challenger can win by always challenging the lowest node that is
incorrectly pebbled.
Determining the winner. We ﬁnish the proof of Theorem X.3.5 by
showing that the winner of the Pebbling game above can be determined
from the plays in ALogTime. The task is, given a sequence of moves of
the players (represented as a binary string), to determine which player is
the ﬁrst to violate the conditions above. We will indeed show that this can
be done in TC 0 .
We will ﬁrst compute all i , ri , then all ai . From these we can get ui ,
vi , ui1 , ui2 , vi1 , vi2 easily. Then it is straightforward to ﬁnd out the winner.
Below we brieﬂy show how to compute i , ri and ai , for 1 ≤ i ≤ d .
For simplicity, assume that the game lasts in exactly d rounds. Notice
that i and ri have the form
i = xdi 2d + xdi −1 2d −1 + · · · + xdi −i 2d −i ,
ri = ydi 2d + ydi −1 2d −1 + · · · + ydi −i 2d −i
where xji , yji ∈ {−1, 0, 1}. For example,
1 = 0 × 2d + 1 × 2d −1 ,

r1 = 1 × 2d + 1 × 2d −1 .

X.3. VNC 1 and G0

421

Also, if the Challenger challenges ui1 as in (379) then xdi+1
−i−1 = −1,
i+1
yd −i−1 = 1, and for d − i ≤ j ≤ d :
xji+1 = yji+1 = xji .
On the other hand, if the Challenger challenges ui2 as in (380) then
i+1
xdi+1
−i−1 = yd −i−1 = 1, and for d − i ≤ j ≤ d :
xji+1 = xji ,

yji+1 = yji .

Generally, xdi −i and ydi −i can be easily extracted from the moves in
round i; and for 0 ≤ j < i, xdi −j and xdi −j can be computed from xdj −j
j

and xd −j by counting the number of “jumps” as in (379) where both
j+1 and rj+1 are computed from only j (or only rj ). From this we can
conclude that i and ri can be computed in TC 0 from the moves of both
players.
Next, notice that we can compute simultaneously all i such that ai is
a leaf. For example a1 is a leaf; ai+1 as in (379) is also a leaf. For each
other value of i, let j < i be largest so that aj is a leaf and hence has been
determined. Then ai is the least common ancestor of aj and a certain
subset Si of
{j , rj , j+1 , rj+1 , . . . , i−1 , ri−1 }.
For example, for j ≤ k < i, rk ∈ Si if ak+1 = vk (e.g., as in (380)). The
set Si can be computed by an AC 0 function from the moves of the players.
2
Hence all ai can be computed in TC 0 .
X.3.3. Reﬂection Principle for PK. Recall that (Z |=0 X ) holds iﬀ the
truth assignment Z satisﬁes the quantiﬁer-free formula X , and (Z |=Σ0 X )
B
B
and (Z |=Π
0 X ) are Σ1 and Π1 formulas that represent (Z |=0 X ),
respectively. These formulas are expressed in terms of a ΣB0 formula
ϕ0 (y, X, E) described in the statement and proof of Lemma X.2.1. By
formalizing the algorithm given in the proof of Theorem X.3.5 we can
strengthen Lemma X.2.1 by proving the following.
Lemma X.3.6. VNC 1  ∃E ≤ t0 + 1ϕ0rec (t0 + 1, X, Z, E).
Corollary X.3.7. VNC 1  (Z |=Σ0 X ) ↔ (Z |=Π
0 X ).
Proof. The direction
(Z |=Σ0 X ) ⊃ (Z |=Π
0 X)
can in fact be proved in V 0 , and the other direction follows immediately
from the Lemma.
2
Proof of Lemma X.3.6. In essence we have to prove the existence of the
array E  where E  (i, j) is the truth value of the subformula encoded by
X [i, j], for all 1 ≤ i ≤ j ≤ n, where n is the length of X (as a string over the
alphabet (378) on page 414). We will evaluate the subformulas X [i, j] in
parallel. Using the function Fval (Deﬁnition IX.5.5), the idea is that each

422

X. Proof Systems and the Reﬂection Principle

subformula X [i, j] will be evaluated by constructing a suitable balanced
tree encoded by some (a, G, I ) (as in Sections IX.5.1 and IX.5.3) such
that Fval(a, G, I )(1) is the value of X [i, j]. The fact that all subformulas
X [i, j] can be evaluated simultaneously in VNC 1 will follow from the fact
that Fval is provably total in VNC 1 (Exercise IX.5.15).
We will construct a tuple (a, G, I ) so that Fval(a, G, I )(1) is the value
of the sentence X ; the constructions for other subformulas of X are
1
similar. Since VNC is a conservative extension of VNC 1 , we will actually
1
work in VNC . Recall that the ALogTime algorithm from the proof of
Theorem X.3.5 is obtained by ﬁrst playing the pebbling game and then
determining the winner of the game. The balanced tree (a, G) will encode
the game playing part of the algorithm: each path from the root of the tree
to a leaf corresponds to a possible play of the game. Each input bit I (x)
speciﬁes the winner of the play corresponding to the path ending with that
leaf. The value of I (x) is computed by the algorithm that determines the
winner of the play.
We will in fact specify a balanced bounded fan-in tree T . Conversion
from this tree to a balanced binary tree (a, G) as required for the arguments
of Fval is straightforward and will be omitted. Let n be the number of
constants in X (i.e., the number of leaves in the tree representing X ). Let d
be such that 2d ≤ n < 2d +1 . As in the ALogTime algorithm for BSVP, we
will pad the formula X with necessary ∧ in order to make X a sentence
with exactly 2d +1 − 1 constants , ⊥ (i.e., the underlying tree for X has
exactly 2d +1 − 1 leaves).
The tree T has 2d alternating layers of nodes corresponding to d rounds
of the game. We number the layers starting at the root with number 1. The
root is an ∨ node; generally, ∨ nodes are on layers 2j − 1 (for 1 ≤ j ≤ d )
and correspond to the Pebbler’s moves. They all have fan-in
7 × 26
that represents 7 × 26 possibilities for a move by the Pebbler (26 diﬀerent
choices of the values for ui , vi , ui1 , ui2 , vi1 , vi2 , and 7 possible relative
positions of ci , ui , vi as in Table 4). Each child of an ∨ node is a ∧ node
that corresponds to a move by the Challenger. Thus all ∧ nodes are on
layers 2j (for 1 ≤ j ≤ d ) and have branching factor of 7 which encodes
7 possible choices for the Challenger. The children of an ∧ node on layer
2j where j < d correspond to the Pebbler’s responses in round (j + 1),
and the children of the ∧ nodes on layer 2d are inputs that are speciﬁed
below.
Note that here we make T a balanced tree by having each play of the
game end in exactly d rounds. (If some play ends in less than d rounds,
simply add arbitrary moves to it.) Using the fact that the relation BIT(i, x)
(Section III.3.3) is Δ0 -deﬁnable, the (binary form of the) tree T can be
deﬁned in V 0 .

X.3. VNC 1 and G0

423

Now, the “determining the winner” part in the proof of Theorem X.3.5
has been shown to be computable in TC 0 ; it is straightforward to formalize
1
this part in VTC 0 (and hence in VNC 1 ). This implies that in VNC we
can deﬁne a string of inputs I to the tree T so that I (x) is true iﬀ the
path from the root of T to the leaf x corresponds to a play of the pebbling
game where the Pebbler wins.
We ﬁnish the proof by showing the correctness of our formalization.
Simply write Fval(T, I ) for Fval(a, G, I ), where (a, G) is a balanced binary
1
formula equivalent to T . Then to prove (in VNC ) that our formalization
is correct, we need to prove:
Claim. Suppose that (A ) B) is a subformula of X , where ) ∈ {∧, ∨},
and suppose that (TAB , IAB ), (TA , IA ) and (TB , IB ) are the result of
our constructions for the sentences A ) B, A and B, respectively. Then
1
VNC proves
Fval(TAB , IAB )(1) = Fval(TA , IA )(1) ) Fval(TB , IB )(1).

(381)

We prove the claim by structural induction on the subformula (A ) B).
The base case (where A, B are both constants) is obvious. For the
induction step consider the following cases:
Case I. (A ) B) = (A ∧ B).
Case Ia. First suppose that
Fval(TA , IA )(1) = Fval(TB , IB )(1) = .
We show that Fval(TA∧B , IA∧B )(1) =  (i.e., that the Pebbler has a winning strategy for the game played on (A ∧ B)).
Consider playing the game on (A ∧ B). Intuitively, the Pebbler wins
by always giving the correct values for the nodes ui , vi , ui1 , ui2 , vi1 and vi2 .
Formally, we will show that all nodes on the “winning paths” of the tree
TA∧B are true. Here winning paths are deﬁned in favor of the Pebbler:
they are the paths from the root of TA∧B that follow the Pebbler’s correct
move at every ∨ node (or any branch of the ∨ node if the game has ended
earlier with the Pebbler being the winner). To ﬁnd the winning paths we
use the induction hypothesis, i.e., the value of a subformula C of (A ∧ B)
is Fval(TC , IC )(1). Thus, a path from the root of TA∧B to a leaf x is a
winning path if at every ∨ node the path follows the edge that is speciﬁed
by (i) the correct relative positions of ci , ui and vi (as in Table 4) and (ii)
the values of ui , vi , ui1 , ui2 , vi1 and vi2 as given by
Fval(TUi , IUi )(1),

Fval(TVi , IVi )(1),

etc.

(here Ui denotes the subformula whose root is ui , etc.).
We will prove by reverse induction on j, 0 ≤ j ≤ d , that all nodes on
layer (2j + 1) of all winning paths are true. For j = 0 we will have that the

424

X. Proof Systems and the Reﬂection Principle

root of TA∧B is true, i.e., Fval(TA∧B , IA∧B )(1) =  and we will be done
with Case Ia.
For the base case, j = d , and all nodes on layer (2d + 1) are leaves of
TA∧B . Using the induction hypothesis (of the claim that (381) holds for
all subformulas of (A ∧ B)) and using the fact that both Fval(TA , IA )(1)
and Fval(TB , IB )(1) are true, by deﬁnition the inputs to TA∧B at the end
of all winning paths are true.
The induction step is straightforward: suppose that node w is on a
winning path and w is on layer (2j + 1). Let t be the child of w that
corresponds to a correct move by the Pebbler (or any child of w if the
Pebbler has won before round (j + 1)). Then by the induction hypothesis
all children of t are true. Hence both t and w are true, because w is an ∨
node and t is an ∧ node.
Case Ib. At least one of Fval(TA , IA )(1) and Fval(TB , IB )(1) is ⊥.
The proof in this case is similar to Case Ia. Deﬁne “losing paths” to be
paths from the root of TA∧B where the Challenger always challenges the
lowest node that is wrongly pebbled (recall that the trees are oriented with
the roots at the top). Then by similar arguments as in Case Ia, it can be
shown that all nodes on the losing paths are false. In particular, the root
of TA∧B is false.
Case II. (A ) B) = (A ∨ B). This case can be handled similarly to
Case I.
2
Π
Π
Recall the formulas Fla and Prf F from Corollary X.1.4 and Lemma
X.1.5.
Deﬁnition X.3.8. The Reﬂection Principle for PK , denoted by RFN PK ,
is the ∀ΣB1 sentence:


Σ
∀∀X ∀Z (FlaΠ (X ) ∧ Prf Π
PK (, X )) ⊃ (Z |=0 X ) .
Theorem X.3.9. VNC 1 proves RFN PK .
Proof. VNC 1 can extract a sequence X [0] , . . . , X [r] of strings reprei ) by
senting the successive sequents in the proof , and prove (Z |=Σ0 D
induction on i, using Lemma X.3.6, where Di is the formula expressing
the semantics of the sequent X [i] (as in (8) on page 10). Details are left
as an exercise.
2
Exercise X.3.10. Give details for the argument above.
Analogous to results in Section X.2.5 we prove that PK is the strongest
propositional proof system whose reﬂection principle is provable in VNC 1 .
Theorem X.3.11 (PK Simulation). Let F be a propositional proof system and let RFN F denote the reﬂection principle for F (deﬁned as Σq0 -RFN F
in Deﬁnition X.2.11). Suppose that VNC 1  RFN F . Then PK p-simulates F.

X.3. VNC 1 and G0

425

Proof. Let A0 (p) be a tautology and 0 be an F -proof of A0 (p). We
need to give a polytime algorithm that on input 0 (and hence also A0 (p))
computes a PK proof of A0 (p). We will show how to derive −→ A0 (p) in
PK, and it can be veriﬁed that the derivation can be constructed in time
polynomial in |0 |.
0 and "0 to denote the strings that encode A0 (p) and
As usual we use A
0 , respectively. The idea is to ﬁrst translate a VNC 1 proof of RFN F into a
0 and "0 for the corresponding
PK  proof and then substitute the bits of A
propositional variables. This is basically a PK  proof of the fact that
→
→
A0 (−
p ) is valid. From this we will be able to derive A0 (−
p ).
1
Note that the Translation Theorem for VNC X.3.1 already gives us a
G0 proof of the translation of RFN F . Also, RFN F is ΣB1 so it translates
into Σq1 formulas. Here we need a PK  proof (in particular, no quantiﬁer
is allowed). So we have to go further and instantiate the existentially
quantiﬁed Boolean variables in order to obtain a quantiﬁer-free tautology
expressing the same fact (that is, A0 (p) is valid) and a PK  proof of
it. Intuitively, this step can be done by bypassing the ∃-right and ∀left introduction rules in the G0 proof, and thus retaining all the target
formulas as witnesses for the existentially quantiﬁed variables in (the
translation of) RFN F . Formal arguments are as follows.
By hypothesis VNC 1 proves RFN F , so by deﬁnition of RFN F


Σ
VNC 1  ∀∀X ∀Z (FlaΠ (X ) ∧ Prf Π
F (, X )) ⊃ (Z |=0 X ) .
Therefore the following sequent is a theorem of VNC 1 :
Σ
FlaΠ (X ), Prf Π
F (, X ) −→ Z |=0 X.

0 |,  = |"0 | and let n be the number of free variables in A0 .
Let m = |A
By the Translation Theorem for VNC 1 X.3.1 there is, provably computable
0
in VTC , a polynomial size G0 proof of of the sequent
Σ
FlaΠ (X )[m], Prf Π
F (, X )[, m] −→ (Z |=0 X )[m, n + 1].
→
−
→
0 and "0 for the free variables −
pX and p
By substituting the bits of A

respectively we obtain a G0 proof P of the following sequent (recall the
notation from Deﬁnition X.1.6)

0 )[ ], Prf Π ("0 , A
0 )[ ] −→ (Z |=Σ0 A
0 )[n + 1].
FlaΠ (A
F

(382)

Because the cut formulas in this proof are quantiﬁer-free, it follows that
the rules ∀-right and ∃-left are not used. Therefore we can turn this into
a PK  proof of a quantiﬁer-free instantiation of (383) as follows.
First we remove the ∃ quantiﬁers in the succedents in P. This can be
done as in the proof of Morioka’s Theorem VII.4.5. For convenience
we reproduce the argument here. Note that all Σq1 formula in P are

426

X. Proof Systems and the Reﬂection Principle

0 )[n + 1] and appear in the succedents in P. Recall
ancestors of (Z |=Σ0 A
(Lemma X.2.1 and its proof)
(Z |=Σ0 X ) ≡ ∃E ≤ t0 + 1(ϕ0rec (t0 , X, Z, E) ∧ E(t0 )).
0 )[n + 1] is (the simpliﬁcation of) the Σq formula (here
Therefore (Z |=Σ0 A
1
r = t0 (m)):
E
∃p0E ∃p1E . . . ∃pr−1

r+1





0 , Z, E) ∧ E(t0 ))[n + 1, k] .
(ϕ0rec (t0 , A

k=0

Since E(t0 )[k] ≡ ⊥ for k ≤ r and E(t0 )[r + 1] ≡ , we have

−
→
0 , Z, E) ∧ E(t0 ))[n + 1, r + 1] .
0 )[n + 1] ≡ ∃p E (ϕ rec (t0 , A
(Z |=Σ0 A
0
E
Z
Let (p0E , p1E , . . . , pr−1
, p0Z , p1Z , . . . , pn−1
) be the quantiﬁer-free matrix of
Σ 
(Z |=0 A0 )[n + 1]:

−
→ −
→
0 , Z, E) ∧ E(t0 ))[n + 1, r + 1].
(pE , p Z ) ≡ (ϕ0rec (t0 , A
We modify the G0 proof P as follows. Let S be a sequent in P that
0 )[n + 1]. This Σq formula is of the
contains a Σq1 ancestor of (Z |=Σ0 A
1
form
−
→
E
E
(D0 , . . . , Di−1 , piE , . . . , pr−1
, pZ )
(383)
∃piE . . . ∃pr−1
for some 0 ≤ i < r and formulas D0 , D1 , . . . , Di−1 (when i = 0 the list
D is empty). Each maximal quantiﬁer-free ancestor of this Σq1 formula
(called a P-prototype) has the form
−
→

, pZ )
(D0 , . . . , Di−1 , Di , . . . , Dr−1

for some formulas Di , . . . , Dr−1
. We replace each occurrence of (383) in
S by the list of all its maximal quantiﬁer-free ancestors:

−
→
1
, p Z ), . . . ,
(D0 , . . . , Di−1 , Di1 , . . . , Dr−1

−
→
s
(D0 , . . . , Di−1 , Dis , . . . , Dr−1
, pZ )

(for some s ≥ 1).
We apply this procedure to every sequent in P. Then, by removing
possible duplicated sequents and inserting necessary weakenings, it can
be seen that the result is a G0 proof of a sequent of the form
−
→ −
−
→ −
→
→
→
→ −
0 )[ ], Prf Π ("0 , A
0 )[ ] −→ (D 1 , p Z ), (D 1 , p Z ), . . . , (−
FlaΠ (A
D s , pZ )
F
for some s ≥ 1.

X.3. VNC 1 and G0

427

Similarly we can eliminate all ∀ quantiﬁers in the antecedents in P. As
a result we arrive at a PK  proof of a sequent of the form
−
→1
−→1
−→
−→
s1
s2
1 (G ), . . . , 1 (G ), 2 (H ), . . . , 2 (H )
−
→ −
−
→ −
→
→
→
−
→ −
−→ (D 1 , p Z ), (D 1 , p Z ), . . . , (D s , p Z ) (384)
−
→ −→
−
→
for some s1 , s2 ≥ 1 and formulas G i , H i and D i that may contain the
−
→
free variables pZ . Here 1 and 2 are the quantiﬁer-free matrices of
0 )[ ] and Prf Π ("0 , A
0 )[ ], respectively, i.e., (for r1 = tFLA (m),
FlaΠ (A
F
r2 = tF (, m))
r1 +1
 rec

−→
Y
0 , Y ) ⊃ Y (tFLA ))[k] ,
(ϕFLA (tFLA , A
(
p
)
≡
1
k=0

−→
Y

2 (p

r2 +1

)≡


rec
0 , Y ) ⊃ Y (tF ))[k] .
(tF , "0 , A
(ϕF



k=0

(Recall Fla from (326) and Prf Π
F from (323), pages 368 and 367.)
Now we will show how to derive the following sequents:
−
→
−→ 1 (G i )
for 1 ≤ i ≤ s1 ,
(385)
−→i
−→ 2 (H )
for 1 ≤ i ≤ s2 ,
(386)
→
−
→
−
→i −
for 1 ≤ i ≤ s.
(387)
(D , p Z ) −→ A0 (pZ )
Π

Then it is straightforward to combine these with (384) to obtain
−
→
−→ A0 (pZ ).
Consider (385) for some 1 ≤ i ≤ s1 . Recall the proof of Lemma X.1.7,
in particular we have shown that there are (computable in polytime) a
PK  proof of the sequent (332) (here r1 plays the role of r):
r1 +1

−→


 rec
ϕFLA (tFLA + 1, X0 , Y ) ⊃ Y (tFLA ) [k].

k=0

By simultaneously replacing each pjY by the formula Gji we obtain a proof
of (385).
The argument for (386) is similar. Consider now (387) for some 1 ≤ i ≤
s. This sequent is obtained from the following sequent by simultaneously
substituting Dji for pjE (for 0 ≤ j < r):
−
→
0 , Z, E) ∧ E(t0 ))[n + 1, r + 1] −→ A0 (pZ ).
(ϕ0rec (t0 , A
Recall (Lemma X.2.6) that there is a polytime algorithm that computes a
PK  proof of the above sequent. A proof of (387) can then be obtained
by simultaneously substituting Dji for pjE .
2

428

X. Proof Systems and the Reﬂection Principle

The procedure for transforming the G0 proof of (382) to a PK  proof
can be used for showing that the witnessing problem Σq1 -WIT G0 can be
solved in NC 1 (see also [80]). (And if the correctness of such a algorithm
could be proved in VNC 1 , then we would have VNC 1  Σq1 -RFN G0 .
However we do not know whether this is true, even when the Reﬂection
Principle for G0 is restricted to prenex Σq1 formulas.) Furthermore, similar
to Theorem X.2.33 we can show that Σq1 -WIT G0 is TC 0 -complete for NC 1 .
Here we state a stronger result from [45] and [80, Section 6.2].
Theorem X.3.12. Both Σq1 -WIT G0 and Σq1 -WIT G0 are complete for NC 1
under AC 0 many-one reduction.

X.4. VTC 0 and Threshold Logic
In this section we introduce PTK, an extension of the sequent calculus
PK that has a new kind of connective called a threshold connective. This
plays the same role in proof systems as the counting function numones
plays in theories. We are interested in bounded depth PTK, the subsystems
of PTK obtained by limiting the depth of the cut formulas to constants
in N. We will associate the theory VTC 0 with these subsystems. (The full
version of PTK is p-equivalent to PK.)
The section is organized as follows. The sequent calculus PTK and its
subsystems are introduced in Section X.4.1. The reﬂection principle for
bounded depth PTK is introduced ins Section X.4.2. In Section X.4.3
we show that the families of tautologies translated from ΣB0 theorems of
VTC 0 have polynomial-size bounded-depth PTK proofs. In Section X.4.4
we show that the translation can be extended to quantiﬁed tautologies
that correspond to any bounded theorem of VTC 0 by using bGTC 0 , a
quantiﬁed version of PTK.
X.4.1. The Sequent Calculus PTK. The sequent calculus PTK is deﬁned similarly to PK, but instead of the binary connectives (∧ and ∨)
PTK contains threshold connectives Thk (for 1 ≤ k ∈ N ) that have unbounded arity. The semantics of Thk is that
Thk (A1 , A2 , . . . , An )
is true if and only if at least k of the formulas Ai are true. For example,
Th2 (p, q, r) ⇔ (p ∧ q) ∨ (q ∧ r) ∨ (r ∧ p).
Also,
Th1 (A1 , A2 , . . . , An ) ⇔

n

i=1

n

Ai ;

Thn (A1 , A2 , . . . , An ) ⇔

Ai . (388)
i=1

X.4. VTC 0 and Threshold Logic
429
#
$
For readability we will sometimes use and in PTK formulas in place
of Th1 and Thn .
Formally PTK formulas (or threshold formulas, or just formulas) are
built from
• propositional constants , ⊥,
• propositional variables p, q, r, . . . ,
• connectives ¬, Thk ,
• parenthesis (, )
using the rules:
(a) , ⊥, and p are atomic formulas, for any propositional variable p;
(b) if A is a formula, so is ¬A;
(c) for n ≥ 2, 1 ≤ k ≤ n, if A1 , A2 , . . . , An are formulas, so is Thk (A1 ,
A2 , . . . , An ).
Moreover,
Th0 (A1 , A2 , . . . , An ) =def ,

Thk (A1 , A2 , . . . , An ) =def ⊥ for k > n.

The sequent calculus PTK is deﬁned similarly to PK (Deﬁnition II.1.2).
Here the logical axioms are of the form
A −→ A,

⊥ −→,

−→ 

where A is any PTK formula. The weakening, exchange, contraction, cut
and ¬ introduction rules are the same as on page 11. The other rules of
PTK are listed below.
The left and right all-introduction rules (all-left and all-right) are as
follows:
Λ −→ A1 , Γ
A1 , . . . , An , Λ −→ Γ
...
Λ −→ An , Γ
Thn (A1 , . . . , An ), Λ −→ Γ

Λ −→ Thn (A1 , . . . , An ), Γ

Left and right one-introduction rules (one-left and one-right) are:
...
An , Λ −→ Γ
A1 , Λ −→ Γ
Λ −→ A1 , . . . , An , Γ
Th1 (A1 , . . . , An ), Λ −→ Γ

Λ −→ Th1 (A1 , . . . , An ), Γ

Thk -introduction rules (for 2 ≤ k ≤ n − 1):
Thk (A2 , . . . , An ), Λ −→ Γ A1 , Thk−1 (A2 , . . . , An ), Λ −→ Γ
Thk (A1 , . . . , An ), Λ −→ Γ
Λ −→ A1 , Thk (A2 , . . . , An ), Γ

Thk -left

Λ −→ Thk−1 (A2 , . . . , An ), Γ

Thk -right
Λ −→ Thk (A1 , . . . , An ), Γ
Like PK, PTK is sound and complete and does not require the cut rule
for completeness.
Exercise X.4.1. Show that for each of the above rules, the bottom
sequent is a logical consequence of the top sequent(s). Also show that if
the bottom sequent is valid, then each top sequent is valid.

430

X. Proof Systems and the Reﬂection Principle

Theorem X.4.2 (Soundness and Completeness of PTK ). Any sequent
provable in PTK is valid, and valid sequents have cut-free PTK proofs.
Proof. The proof is an extension of the proof of soundness and completeness of PK (Theorems II.1.7 and II.1.8). Soundness follows from
the ﬁrst sentence in the above exercise. To prove completeness, it follows
from the second sentence in that exercise that the Inversion Principle for
PK (Lemma II.1.9) applies more generally to PTK . Hence a proof of a
valid sequent S can be obtained by successively simplifying the formulas
in S by applying appropriate rules in reverse.
2
We will prove in Theorem X.4.6 that PTK and PK are p-equivalent.
So we are mainly interested in subsystems of PTK where the cut formulas
have bounded depths.
Deﬁnition X.4.3 (Depth of a PTK Formula). The depth of a PTK
formula A is the nesting depth of the connectives in A.
So, for example, the atomic PTK formulas have depth 0.
Deﬁnition X.4.4 (Bounded Depth PTK). For each constant d ∈ N, a
d -PTK proof is a PTK proof in which all cut formulas have depth at most
d . A bounded depth PTK system (or just bPTK) is any system d -PTK for
d ∈ N.
The treelike versions of PTK, d -PTK and bPTK are denoted by PTK  ,
d -PTK  and b-PTK  , respectively.
Recall (Deﬁnition VII.1.13) that the depth of a formula A of PK is the
maximal number of times the connective changes in any path in the tree
form of A. When we write a formula (A1 ∨A2 ∨· · ·∨An ) or (A1 ∧A2 ∧· · ·∧
An ) of the system PK we ignore the fact that oﬃcially ∨ and ∧ are binary
connectives and the formula must be fully parenthesized. The justiﬁcation
is that the parenthesization does not aﬀect the depth of a formula, and
also according to Lemma VII.1.15 there are simple PK proofs converting
from one parenthesization to any other.
Thus using the formulas (388) there is a natural way to translate formulas of the system PK to formulas of PTK which preserves depth. The
statement of the next result makes sense when we use this translation.
Theorem X.4.5. For any d ∈ N, d -PTK p-simulates d -PK for proving
formulas of depth d .
Proof. Let  be a d -PK derivation whose end sequent has depth at
most d . Note that all formulas in  have depth at most d . We translate
each PK formula into a PTK formula using (388). The result is a PTK
formula of the same depth. Thus each formula A in  is translated into a
PTK formula A of depth at most d . For each sequent S in , let S  be
the translation of S. We prove by induction on the length of  that there
is a d -PTK proof   of size polynomial in the size of  that contains all
translations S  of sequents S in .

X.4. VTC 0 and Threshold Logic

431

The base case is obvious because axioms of PK are translated into
axioms of PTK of the same depth. For the induction step, suppose that
 = (1 , S) where S is the end sequent of . Consider, for example, the
case where S is derived from two sequents S1 and S2 in 1 as follows:


Ai , Γ −→ Δ
Bj , Γ −→ Δ
S1
S2


=
Ai ∨
Bj , Γ −→ Δ
S
$
Here
Ai is any parenthesizing of A1 ∨ A2 ∨ · · · ∨ An , and similarly for
$
Bj . Note that
S1 = Th1 (A ), Γ −→ Δ ,

S2 = Th1 (B  ), Γ −→ Δ ,

S  = Th1 (A , B  ), Γ −→ Δ .
Using the one-left rule we can derive
Th1 (A , B  ) −→ Th1 (A ), Th1 (B  ).
From this and S1 , S2 , using the cut rule (with cut formulas Th1 (A ) and
Th1 (B  )) we derive S  . The derivation   is obtained from 1 and the
above derivation.
It is easy to see that   as described above has size bounded by a
polynomial in the size of .
2
The reverse direction of Theorem X.4.5 does not hold, since the pigeonhole tautologies have polysize bPTK proofs (Corollary X.4.20) but do not
have polysize bPK proofs (Theorem VII.1.16).
However the reverse simulation does hold when we compare the unbounded depth proof systems PTK and PK, and this is stated in the next
theorem. To make sense of this statement we use the fact that there are
standard polynomial time translations back and forth from formulas of
PK to formulas of of PTK such that formulas are translated to equivalent formulas. As mentioned before the translation from PK formulas to
PTK formulas uses the equivalences (388). The translation in the other
direction is described in the proof below.
Theorem X.4.6. PK is p-equivalent to PTK.
Proof Sketch. The fact that PTK p-simulates PK follows from the
proof of Theorem X.4.5 above. It remains to show that PK p-simulates PTK.
In Section IX.5.4 we show that the function numones is provably total in
VNC 1 . In essence we construct a uniform family of formulas that compute
numones. In other words, there are PK formulas Fn,k (p1 , p2 , . . . , pn ) so
that
Fn,k (p1 , p2 , . . . , pn ) ⇔ the number of  in p1 , p2 , . . . , pn is k.
Moreover in the same way that VNC 1  NUMONES (Theorem
IX.5.17) we can prove:

432

X. Proof Systems and the Reﬂection Principle

Proposition X.4.7. There are polynomial-size PK-proofs of the following sequents:
1) Fn,n (A1 , A2 , . . . , An ) −→ Ai ( for 1 ≤ i ≤ n);
2) A1 , A2 , . . . , An −→ Fn,n (A1 , A2 , . . . , An );
3) Ai −→ Fn,1 (A1 , A2 , . . . , An ) ( for 1 ≤ i ≤ n);
4) Fn,1 (A1 , A2 , . . . , An ) −→ A1 , A2 , . . . , An ;
5) Fn, (A1 , A2 , . . . , An ) −→ A1 , Fn−1, (A2 , . . . , An ) ( for 1 ≤  ≤ n−1);
6) A1 , Fn, (A1 , A2 , . . . , An ) −→ Fn−1,−1 (A2 , . . . , An ) ( for 2 ≤  ≤ n);
7) Fn−1, (A2 , . . . , An ) −→ A1 , Fn, (A1 , A2 , . . . , An ) ( for 1 ≤  ≤ n−1);
8) A1 , Fn−1,−1(A2 , . . . , An ) −→ Fn, (A1 , A2 , . . . , An ) ( for 2 ≤  ≤ n).
Now PTK formulas are translated into PK formulas (of unbounded
depth) inductively using the formulas Fn,k as follows. No translation is
required for atomic formulas, because they are the same in PK and PTK .
For the inductive step, suppose that Ai has been translated to Ai , for
1 ≤ i ≤ n. Then Thk (A1 , A2 , . . . , An ) is translated into
n


Fn, (A1 , A2 , . . . , An ).

=k

To show that PK p-simulates PTK it suﬃces to show that the translations of rules of PTK have polynomial-size PK proofs.
First, consider the rule all-left. We need to show that there is a
polynomial-size PK derivation of the form
A1 , A2 , . . . , An , Λ −→ Γ
======================
Fn,n (A1 , A2 , . . . , An ), Λ −→ Γ
For this we can use Proposition X.4.7 (1) with successive cuts on the
formulas Ai .
Similarly, the rule one-left can be simulated using Proposition X.4.7 (4).
Consider now the rule Thk -left. Suppose that 2 ≤ k ≤ n − 1, we need
to give polynomial-size PK-derivations of the form
n−1
∨n−1
=k Fn−1, (A2 , . . . , An ), Λ −→ Γ A1 , ∨=k−1 Fn−1, (A2 , . . . , An ), Λ −→ Γ
================n=======================================
∨=k Fn, (A1 , A2 , . . . , An ), Λ −→ Γ

It suﬃces to derive for each  (where k ≤  ≤ n) the sequent
Fn, (A1 , A2 , . . . , An ), Λ −→ Γ.

(389)

From Proposition X.4.7 (5) we derive (by weakening and ∨-right):
Fn, (A1 , A2 , . . . , An ) −→ A1 ,

n−1

=k

Fn−1, (A2 , . . . , An ).

X.4. VTC 0 and Threshold Logic

433

Using the cut rule for this sequent and
n−1


Fn−1, (A2 , . . . , An ), Λ −→ Γ

=k

we obtain
Fn, (A1 , A2 , . . . , An ), Λ −→ A1 , Γ.

(390)

From Proposition X.4.7 (6) for  = k we obtain (using weakening and
∨-right):
A1 , Fn,k (A1 , A2 , . . . , An ) −→

n−1


Fn−1, (A2 , . . . , An ).

=k−1

From this and
A1 ,

n−1


Fn−1, (A2 , . . . , An ), Λ −→ Γ

=k−1

we derive
A1 , Fn,k (A1 , A2 , . . . , An ), Λ −→ Γ.

(391)

Combined (390) with (391) we obtain the desired derivation.
It is easy to verify that the above derivations have size polynomial in
the size of the end sequents. Simulating the other rules of PTK is left as
an exercise.
2
Exercise X.4.8. Complete the proof of Theorem X.4.6 by showing that
the translations of the rules all-right, one-right and Th-right have polynomial-size PK-proofs.
X.4.2. Reﬂection Principles for Bounded Depth PTK. We will show that
for each depth d ∈ N, the soundness of d -PTK is provable in VTC 0 . Let
Z |=d -PTK X hold iﬀ the truth assignment Z satisﬁes the depth-d PTK
formula X . It can be shown by induction on d that this relation is a TC 0
relation. We leave the details as an exercise.
Exercise X.4.9. Show that for each d ∈ N there is a ΣB1 formula
(Z |=Σd -PTK X ) and a ΠB1 formula (Z |=Π
d -PTK X ) that both represent
the relation Z |=d -PTK X , and such that
VTC 0  (Z |=Σd -PTK X ) ↔ (Z |=Π
d -PTK X ).
For each d , the Reﬂection Principle for d -PTK, denoted by d -RFN PTK ,
is the sentence:


Π
Σ
∀∀X ∀Z (FlaΠ
d (X ) ∧ Prf d (, X )) ⊃ (Z |=d -PTK X ) .

434

X. Proof Systems and the Reﬂection Principle

B
Here FlaΠ
d (X ) is the Π1 formula that is true iﬀ X is a formula of depth
Π
at most d , and Prf d (, X ) is the ΠB1 formula that is true iﬀ  is a d -PTK
proof of X . (See Corollary X.1.4 and Lemma X.1.5.)
The following result is left as an exercise.

*Exercise X.4.10. Show that for each d ∈ N, d -RFN PTK is a theorem
of VTC 0 . (Hint: ﬁrst show that all formulas in a d -PTK proof of a
formula of depth d must have depth at most d (see also Exercise X.1.10).
Then prove by induction on i that the i-th sequent in the proof is valid.)
X.4.3. Propositional Translation for VTC 0 . Our goal in this section is
to translate VTC 0 -proofs of ΣB0 formulas into families of polynomial-size
bPTK-proofs. One way would be to translate directly all instances of the
axiom NUMONES (227) into PTK formulas (the bits of the “counting
sequence” Y in NUMONES are translated using the Thk connectives).
Here we take another approach, based on Lemma X.4.12 below.
Recall that numones (z, X ) has the same value as numones(z, X ) (which
is the number of elements in X that are less than z). For convenience,
we list below the deﬁning axioms of numones ((231), (232) and (233),
page 286):
numones (0, X ) = 0,

(392)









X (z) ⊃ numones (z + 1, X ) = numones (z, X ) + 1,

(393)

¬X (z) ⊃ numones (z + 1, X ) = numones (z, X ).
0



0

(394)


Deﬁnition X.4.11 (V (numones )). The theory V (numones ) has vocabulary L2A ∪ {numones } and is axiomatized by 2-BASIC, the axioms
(392), (393), (394) and the ΣB0 (numones )-COMP axiom scheme.
Lemma X.4.12. V 0 (numones ) is a conservative extension of VTC 0 .
Proof. First, NUMONES is provable in V 0 (numones ) because the
counting sequence Y in NUMONES can be deﬁned by ΣB0 (numones )COMP as follows:
(Y )z = y ↔ numones (z, X ) = y.
Hence V 0 (numones ) extends VTC 0 .
0
0
Also, VTC is an extension of V 0 (numones ), so the fact that VTC is
conservative over VTC 0 (Theorem IX.3.7) implies that V 0 (numones ) is
2
conservative over VTC 0 .
Suppose that ϕ is a ΣB0 theorem of VTC 0 . It follows from Lemma X.4.12
that ϕ has a V 0 (numones )-proof . All formulas in  are ΣB0 (numones ),
and we will show that  can be translated into a family of polynomial-size
bounded-depth PTK-proofs for the translation of ϕ.
We will describe the translation of atomic formulas. The translations
of other ΣB0 (numones ) formulas build up inductively as in Section VII.2.1
using appropriate connectives Thk for ∧ and ∨.

X.4. VTC 0 and Threshold Logic

435

Thus let ϕ(x, X ) be an atomic formula. If ϕ does not contain numones
then the translation ϕ[m, n] is deﬁned as in Section VII.2.1 (using Thk
instead of ∧, ∨). So suppose that ϕ contains numones . Now if ϕ is of the
form X (t), where t contains numones , then we can use the equivalence
X (t) ↔ ∃z < |X |(z = t ∧ X (z))
to translate ϕ using the translations of other atomic formulas z = t and
X (z) (the latter does not contain numones ). Thus we only need to focus
on atomic formulas ϕ of the form s = t or s ≤ t.
Let
numones (t1 , X1 ), numones (t2 , X2 ), . . . , numones (t , X )
be all occurrences of numones in ϕ(x, X ) (some ti may contain terms of
the form numones (tj , Xj )). Thus ϕ(x, X ) has the form
ϕ  (x, |X |, numones (t1 , X1 ), . . . , numones (t , X ))
where ϕ  is an atomic formula of the form s  = t  or s  ≤ t  . The truth
value of ϕ(x, X ) can be determined from the values m of x, the length n
of X , and the values of numones (ti , Xi ). So for a ﬁxed sequences m, n, let
S = Sϕ,m,n be the following set (recall val on page 166)
{(k1 , k2 , . . . , k ) : ki ≤ val(ti (m, n)), and
ϕ is true when numones (ti , Xi ) = ki , for 1 ≤ i ≤ }.
Recall that for each string variable Xi and a length ni ≥ 2 we introduce
the propositional variables
p Xi = p0Xi , p1Xi , . . . , pnXii−2 .
If the set S is empty, then deﬁne ϕ[m; n] = ⊥; otherwise ϕ[m; n] is
deﬁned to be the simpliﬁcation (explained below) of (395). Note that
for readability we here use (A1 ∧ A2 ∧ · · · ∧ Ak ) for Thk (A1 , A2 , . . . , Ak )
and (A1 ∨ A2 ∨ · · · ∨ Ak ) for Th1 (A1 , A2 , . . . , Ak ). The translation of ϕ is
obtained by simplifying the following formula:




(Thki (p0Xi , p1Xi , . . . , psXi i−1 ) ∧ ¬Thki +1 (p0Xi , p1Xi , . . . , psXi i−1 )) (395)

k∈S i=1

where si = val(ti (m, n)), pnXii−1 = , and pjXi = ⊥ for j ≥ ni .
The simpliﬁcation of (395) is performed inductively, starting with the
atomic formulas Thki (p0Xi , p1Xi , . . . , psXi i−1 ) and Thki +1 (p0Xi , p1Xi , . . . , psXi i−1 ).
Each formula is simpliﬁed by applying the following procedure repeatedly.

436

X. Proof Systems and the Reﬂection Principle

Recall that
Th0 (A1 , A2 , . . . , An ) =def 
and
Thk (A1 , A2 , . . . , An ) =def ⊥, k > n.
Simpliﬁcation Procedure. Whenever possible
• Th1 (A) is simpliﬁed to A,
• ¬⊥ is simpliﬁed to ,
• ¬ is simpliﬁed to ⊥,
• Th1 (A, A, A1 , A2 , . . . , An ) is simpliﬁed to Th1 (A, A1 , A2 , . . . , An ),
• Thn+1 (A, A, A1 , . . . , An−1 ) is simpliﬁed to Thn (A, A1 , . . . , An−1 ),
• Thk (⊥, A1 , A2 , . . . , An ) is simpliﬁed to Thk (A1 , A2 , . . . , An ),
• Thk (, A1 , A2 , . . . , An ) is simpliﬁed to Thk−1 (A1 , A2 , . . . , An ).
Example X.4.13. Recall the deﬁning axioms (392), (393) and (394) for
numones . They are translated as follows.
(a) (392) is translated into .
(b) To translate (393), ﬁrst we translate the atomic formula
ϕ(z, X ) ≡ numones (z + 1, X ) = numones (z, X ) + 1.
Here  = 2, t1 = z + 1, t2 = z, X1 = X2 = X . For m, n ∈ N, n ≥ 2,
we have
Sϕ,m,n = {(k + 1, k) : k ≤ m}.
We omit the superscript X for the variables piX , and let p denote
p0 , p1 , . . . , pm−1 . Then ϕ[m; n] is the simpliﬁcation of
m




(Thk+1 (p, pm ) ∧ ¬Thk+2 (p, pm )) ∧ (Thk (p) ∧ ¬Thk+1 (p)) .

k=0

As a result, (393) translates into
⎧
¬pm ∨ ϕ[m; n] (see (396) below)
⎪
⎪
⎨
ϕ[n − 1; n] (see (397) below)
⎪
⎪
⎩


if m ≤ n − 2,
if m = n − 1,
if m ≥ n.

Note that for m ≤ n − 2,
ϕ[m; n] ≡ (Th1 (p, pm ) ∧ ¬Th2 (p, pm ) ∧ ¬Th1 (p)) ∨
&
%m−1


Thk+1 (p, pm ) ∧ ¬Thk+2 (p, pm ) ∧ Thk (p) ∧ ¬Thk+1 (p) ∨
k=1




Thm+1 (p, pm ) ∧ Thm (p) (396)

X.4. VTC 0 and Threshold Logic

437

where p stands for p0 , p1 , . . . , pm−1 . Also,
ϕ[n − 1; n] ≡ ¬Th1 (p) ∨

%n−2


&
(Thk (p) ∧ ¬Thk+1 (p))

∨ Thn−1 (p)

k=1

(397)
where p = p0 , p1 , . . . , pn−2 .
(c) For (394), consider the atomic formula
(z, X ) ≡ numones (z + 1, X ) = numones (z, X ).
Here , t1 , t2 , X1 , X2 are as in (b) and
S ,m,n = {(k, k) : k ≤ m}.
Again drop mention of the superscript X , and let p = p0 , p1 , . . . ,
pm−1 . The formula [m; n] is (the simpliﬁcation of)
m



(Thk (p, pm ) ∧ ¬Thk+1 (p, pm )) ∧

k=0


(Thk (p) ∧ ¬Thk+1 (p)) . (398)

For m ≥ n, the simpliﬁcation of (398) is just ϕ[n − 1; n] in (397).
Hence, (394) translates into
⎧
pm ∨ [m; n] (see (396))
⎪
⎪
⎨

⎪
⎪
⎩
ϕ[n − 1; n] (see (397))

if m ≤ n − 2,
if m = n − 1,
if m ≥ n.

We will show that the translations of (392), (393) and (394) described
above have d -GTC 0 proofs of size polynomial in m, n, for some constant
d ∈ N. We need the following lemma.
Lemma X.4.14. (a) The sequents (397) have polynomial size (in n) cutfree PTK proofs.
(b) Let p denote p0 , . . . , pm−1 . The following sequents have polynomialsize (in m) cut-free PTK proofs:
pm −→ ¬Th2 (p, pm ) ∨

%m−1



Thk (p) ∧ ¬Thk+2 (p, pm )

&
∨ Thm (p).

k=1

(399)

438

X. Proof Systems and the Reﬂection Principle

Proof. (a) The cut-free PTK proof is as follows:
Thn−1 (p) −→ Thn−1 (p)

(7)
−→ ¬Thn−1 (p), Thn−1 (p)
==================================== (6)
Thn−2 (p) −→ Thn−2 (p)∧¬Thn−1 (p), Thn−1 (p)
·
·
·
·
−→ ¬Th3 (p),Th3 (p)∧¬Th4 (p), . . . ,Thn−2 (p)∧¬Thn−1 (p),Thn−1 (p)
==================================================== (5)
Th2 (p) −→ Th2 (p)∧¬Th3 (p), . . . ,Thn−2 (p)∧¬Thn−1 (p),Thn−1 (p)
(4)
−→ ¬Th2 (p),Th2 (p)∧¬Th3 (p), . . . ,Thn−2 (p)∧¬Thn−1 (p),Thn−1 (p)
==================================================== (3)
Th1 (p) −→ Th1 (p)∧¬Th2 (p), . . . ,Thn−2 (p)∧¬Thn−1 (p),Thn−1 (p)
(2)
−→ ¬Th1 (p),Th1 (p)∧¬Th2 (p), . . . ,Thn−2 (p)∧¬Thn−1 (p),Thn−1 (p)
(1)
%n−2
&

(Thk (p)∧¬Thk+1 (p)) ∨ Thn−1 (p)
−→ ¬Th1 (p) ∨
k=1

Here the top sequent is an axiom, (1) is by the rule one-right, (2, 4, 7)
are ¬-right, and the derivations (3, 5, 6) consist of the rule all-right and a
derivation from the axiom of the form
Thi (p) −→ Thi (p).
(b) The PTK proof is presented below. Because of the space limit, we
will give one fragment of the proof at a time. There are (m + 1) fragments.
The bottom fragment is:
pm , Th1 (p) −→ {Thk (p) ∧ ¬Thk+2 (p, pm )}m−1
k=1 , Thm (p)
S1

pm , pm , Th1 (p) −→ {Thk (p) ∧ ¬Thk+2 (p, pm )}m−1
k=1 , Thm (p)
pm , Th2 (p, pm ) −→ {Thk (p) ∧ ¬Thk+2 (p, pm )}m−1
k=1 , Thm (p)

(4)
(3)

(2)
pm −→ ¬Th2 (p, pm ), {Thk (p) ∧ ¬Thk+2 (p, pm )}m−1
k=1 , Thm (p)
(1)
&
%m−1


Thk (p) ∧ ¬Thk+2 (p, pm ) ∨ Thm (p)
pm −→ ¬Th2 (p, pm ) ∨
k=1

Here (1) is by the rule one-right, (2) is ¬-right, (3) is Th2 -left, and (4) is
contraction left. The sequent S1 is the top sequent in (8) below (so our
proof is a dag-like proof). The top sequent of (4) is derived in the next

X.4. VTC 0 and Threshold Logic

439

fragment:
pm , Th2 (p) −→ {Thk (p) ∧ ¬Thk+2 (p, pm )}m−1
k=2 , Thm (p)
S2

pm , pm , Th2 (p) −→ {Thk (p) ∧ ¬Thk+2 (p, pm )}m−1
k=2 , Thm (p)
pm , Th3 (p, pm ) −→ {Thk (p) ∧ ¬Thk+2 (p, pm )}m−1
k=2 , Thm (p)

(8)
(7)

(6)
pm −→ ¬Th3 (p, pm ), {Thk (p) ∧ ¬Thk+2 (p, pm )}m−1
k=2 , Thm (p)
====================================m−1
=========== (5)
pm , Th1 (p) −→ {Thk (p) ∧ ¬Thk+2 (p, pm )}k=1 , Thm (p)
The derivation (5) consists of an all-right and a derivation by weakenings
from the axiom
Th1 (p) −→ Th1 (p).
The steps (6, 7, 8) are similar to (2, 3, 4) above.
The next fragment derives the top sequent of (8) and is similar.
The top fragment is:
pm , Thm+1 (p, pm ) −→ Thm (p)

(10)
pm , −→ ¬Thm+1 (p, pm ), Thm (p)
========================================== (9)
pm , Thm−1 (p) −→ Thm−1 (p) ∧ ¬Thm+1 (p, pm ), Thm (p)
The top sequent of (10) is obtained from some axioms by the rules all-left
and all-right.
2
Lemma X.4.15. The translations of the deﬁning axioms (392), (393) and
(394) for numones (described in Example X.4.13) have polynomial size
d -PTK proofs, for some constant d .
Proof. The translation of (392) is , so the conclusion is obvious.
Consider the translations of the deﬁning axiom (393) in part (b) of Example X.4.13. Recall the formulas ϕ[m; n] and ϕ[n − 1; n] from (396)
and (397), respectively. We need to show that the following sequents have
polynomial size d -PTK proofs, for some d :
−→ ¬pm ∨ ϕ[m; n]

and

−→ ϕ[n − 1; n].

By Lemma X.4.14 (a) the latter has a polynomial size cut-free PTK proof.
To derive the former, by Lemma X.4.14 (b) it suﬃces to derive
&
%m−1


Thk (p) ∧ ¬Thk+2 (p, pm ) ∨
pm , ¬Th2 (p, pm ) ∨
k=1

Thm (p) −→ ϕ[m; n] (400)
(where p denotes p0 , p1 , . . . , pm−1 ). This is left as an exercise (see below).
Finally consider the translation of axiom (394) described in Example
X.4.13 (c). As mentioned above, the sequents (397) have polynomial size
cut-free PTK proofs. It remains to show that (recall [m; n] from (398)):
−→ pm ∨ [m; n]

(401)

440

X. Proof Systems and the Reﬂection Principle

has polynomial size d -PTK proof, for some constant d . This is left as an
exercise.
2
Exercise X.4.16. Complete the proof of Lemma X.4.15 above by showing that the sequents (400) and (401) have polynomial size d -PTK proofs,
for some constant d . Hint: ﬁrst deriving the following sequents, then use
Lemma X.4.14:
1) pm , Thk (p) −→ Thk+1 (p, pm ) (for 1 ≤ k ≤ m).
2) pm , ¬Thk+2 (p, pm ) −→ ¬Thk+1 (p) (for 0 ≤ k ≤ m − 1).
3) Thk (p) −→ pm , Thk (p, pm ) for 1 ≤ k ≤ m.
4) ¬Thk+1 (p) −→ pm , ¬Thk+1 (p, pm ) for 0 ≤ k ≤ m − 1.
As in Section X.1.1, it can be shown that formulas, sequents and proofs
of PTK are ΔB1 -deﬁnable in FTC 0 .
Lemma X.4.17. For every ΣB0 (numones ) formula ϕ(x, X ), there is a constant d and a polynomial p(m, n) so that for all sequences m, n, the propositional formula ϕ(x, X )[m; n] has depth d and size bounded by p(m, n).
0
Moreover, ϕ(x, X )[m; n] is provably in VTC computable by an FTC 0 function G(m, n).
Proof. By structural induction on ϕ.
2
B

Theorem X.4.18. Suppose that ϕ(x, X ) is a Σ0 (numones ) theorem of
V 0 (numones ). Then there are a constant d ∈ N and an FTC 0 func0
tion F (m, n) so that, provably in VTC , F (m, n) is a d -PTK proof of
ϕ(x, X )[m; n], for all m, n.
Proof. The theorem can be proved in the same way that Theorem
VII.2.3 is proved in Section VII.2.3, i.e., by showing that every
ΣB0 (numones ) theorem of V 0 (numones ) has an LK 2 proof where the inference rule ΣB0 (numones )-IND (Deﬁnition VI.4.11) is allowed.
2
Corollary X.4.19. For every ΣB0 theorem ϕ(x, X ) of VTC 0 , there are a
0

constant d ∈ N and an FTC 0 function F (m, n) so that, provably in VTC ,
F (m, n) is a d -PTK proof of ϕ(x, X )[m; n], for all m, n.
Proof. The Corollary follows from Theorem X.4.18 because
0
2
V (numones ) is a conservative extension of VTC 0 .
The next result is immediate from the above corollary and the fact that
VTC 0 proves PHP(a, X ) (Theorem IX.3.23).
Corollary X.4.20. The pigeonhole tautologies PHP (Deﬁnition
VII.1.12) have polynomial size bPTK proofs.
In the next section we introduce the quantiﬁed threshold formulas and
a sequent calculus GTC for them. Theorem X.4.18 will be generalized to
show that the propositional translations of bounded theorems of VTC 0
have proofs in GTC that are provably in VTC 0 computable by some FTC 0
functions (Theorem X.4.22).

X.4. VTC 0 and Threshold Logic

441

X.4.4. Bounded Depth GTC 0 . Now we consider an extension of PTK
which allows quantiﬁers over propositional variables. We do not allow the
quantiﬁers to be inside the scope of arbitrary threshold connectives. We
do want to allow conjunctions and disjunctions of quantiﬁed formulas, so
we require that the quantiﬁers cannot occur inside the scope of a threshold
connective Thk unless k = 1 (so the connective expresses a disjunction)
or k = n and occurs in the context Thn (A1 , A2 , . . . , An ) (so the connective
expresses a conjunction).
Formally, quantiﬁed threshold formulas (or QT formulas, or just formulas) are deﬁned as follows:
(a) Any PTK formula is a QT formula;
(b) If A(p) is a QT formula, then so are ∀xA(x) and ∃xA(x), for any
free variable p and bound variable x.
(c) If A1 , A2 , . . . , An are QT formulas, then so are Th1 (A1 , A2 , . . . , An ),
Thn (A1 , A2 , . . . , An ) and ¬A1 .
As before, we will often write
n

i=1

n

Ai

Ai

and
i=1

for Th1 (A1 , A2 , . . . , An ) and Thn (A1 , A2 , . . . , An ), respectively.
The system GTC is the extension of PTK where the axioms now consist
of
−→ ,
⊥−→ ,
A −→ A
for all QT formulas A. The introduction rules for the threshold connectives
are as given in Section X.4.1 but now the rules Thk -left and Thk -right are
applied only to PTK formulas. The introduction rules for the quantiﬁers
are as for QPC (Section VII.3).
Theorem X.4.6 can be extended to show that GTC and G are pqt
equivalent. In fact, for i ≥ 0 deﬁne Σqt
i and Πi of QT formulas in
q
q
the same way as Σi and Πi , and let GTC i be obtained from GTC by
qt
restricting the cut formulas to Σqt
i ∪ Πi . Then it can be shown that GTC i
and Gi are p-equivalent for i ≥ 0. Here we are interested in the following
subsystems of GTC 0 .
Deﬁnition X.4.21 (Bounded Depth GTC 0 ). For each d ∈ N, d -GTC 0
is the subsystem of GTC where all cut and target formulas are quantiﬁerfree and have depth at most d . A bounded depth GTC 0 (or just bGTC 0 )
system is any system d -GTC 0 for d ∈ N. Treelike d -GTC 0 (resp. treelike
bGTC 0 ) is denoted by d -GTC 0 (resp. bGTC 0 ).
As in Section X.1.1, it can be shown that formulas, sequents and proofs
in GTC are ΔB1 -deﬁnable in VTC 0 . It is also straightforward to extend the
translation given in Section X.4.3 so that ΣBi (numones ) and ΠBi (numones )

442

X. Proof Systems and the Reﬂection Principle

formulas (for i ≥ 1) are translated into quantiﬁed threshold formulas in
qt
Σqt
i and Πi , respectively.
Theorem X.4.22 (Propositional Translation for V 0 (numones )).
Let
ϕ(x, X ) be a bounded theorem of V 0 (numones ). There is a constant d ∈ N
0
and a function F in FTC 0 so that F (m, n) is provably in VTC a d -GTC 0
proof of ϕ(x, X )[m; n], for all m, n.
The proof of Theorem X.4.22 is similar to the proof of Theorem X.1.14.
Here we translate cut ΣB0 (numones)-COMP formulas in the same way that
cut ΣB0 -COMP formulas are translated in Theorem VII.5.6. Then it can be
shown that the translation of formulas in an LK 2 -V 0 (numones ) proof are,
0
provably in VTC , computable by some FTC 0 functions. Furthermore,
the PTK version of the sequent in Exercise VII.5.3 can be shown to have
0
d -PTK  proofs that are provably in VTC computable by some FTC 0
function, for some constant d . Details are left as an exercise.
*Exercise X.4.23. Prove Theorem X.4.22.
Corollary X.4.24 (Propositional Translation Theorem for VTC 0 ).
For every bounded theorem ϕ(x, X ) of VTC 0 , there is a constant d ∈ N and
0
an FTC 0 function F such that VTC proves that for all m and n, F (m, n)

is a d -GTC 0 proof of ϕ(x, X )[m; n].
Proof. Since ϕ is a theorem of VTC 0 , by Lemma X.4.12 it is also a
theorem of V 0 (numones ). Now apply Theorem X.4.22.
2

X.5. Notes
The results in Section X.1.3 are from [73].
The formulation 0-RFN(F ), the RFN for quantiﬁer-free formulas given
in [72], is essentially our Πq0 -RFN F (Deﬁnition X.2.11), and hence is different from our notation 0-RFN F . Lemma X.2.13 is from [72, Lemma
9.3.12 b] where it is stated more generally for any system F which is
closed under substitution and modus ponens. Lemma X.2.14 is new.
Deﬁnition X.2.16 is from [91]. Theorem X.2.17 and Corollary X.2.20
strengthen results from [72, Theorem 9.3.16]. Parts (a) and (b) of Theorem X.2.23 strengthen results from [73] (here we use VTC 0 instead of
S21 ). The axiomatizations of V i in part (c) of Theorem X.2.23 are new.
The diﬃcult part (that V i proves Σqi+1 -RFN Gi ) is based on [91, Theorem
5.1.2], see Theorem X.2.17 (c).
The idea of using the Reﬂection Principle for p-simulation is from [39]
where a variant of Exercises X.2.22 and X.2.30 is proved. Theorem X.2.27
is a strengthening of Lemma 5.2.1 from [91]. The deﬁnition of a Σqi
Witnessing Problem given in Section X.2.6 is more general than that of

X.5. Notes

443

[80]: in [80] the problem is to witness prenex formulas. Consequently
the membership directions of Theorem X.2.33 strengthen that of [80,
Theorems 6.2, 6.9]. For the hardness directions of Theorem X.2.33 note
that we are using TC 0 reductions while the reductions in [80, Theorems
6.2, 6.9] are polytime. Following the proofs given in [80], the fact that the
weaker problems as deﬁned in [80] are hard for the search classes under
polytime reduction (instead of TC 0 reduction) is due to the fact that we
need polytime procedures for producing Gi proofs of the equivalence
between prenex and non-prenex Σqi formulas, see Exercise X.2.9.
Clote [34] introduced an equational theory ALV for NC 1 and deﬁned
a polytime translation from theorems of ALV to families of Frege proofs.
Arai [8] introduced a ﬁrst order system AID for NC 1 , deﬁned a polytime
translation from Σb0 theorems to Frege proofs, and proved the reﬂection
principle for Frege systems. A version of VNC 1 was introduced in [45]
and translation of all bounded theorems to polynomial size families of G0
proofs presented. The translation given in Section X.3.1 is new. Several
ALogTime algorithms for the Boolean Sentence Value Problem have been
presented by Buss [22, 24, 25]. The algorithm presented in the proof of
Theorem X.3.5 is from [25]. The algorithm from [24] was formalized in
[8]. The algorithm from [25] was also formalized in [92] using the string
theory T 1 .
The sequent calculus PTK is from [29]. The propositional translation
for VTC 0 given in Section X.4.3 is new. The quantiﬁed system GTC 0 in
Section X.4.4 is similar to the system QTC in [45].

Appendix A

COMPUTATION MODELS

We give deﬁnitions for some basic concepts in computational complexity
and state some useful results. See [49, 64, 87, 100, 102, 110] for further
details.
In this Appendix f and g stand for functions from the natural numbers
to R≥0 = {x ∈ R : x ≥ 0}. We use the following notation.
• g = O(f) if there is a constant c > 0 so that g(n) ≤ cf(n) for all
but ﬁnitely many n.
• g = Ω(f) if there is a constant c > 0 so that g(n) ≥ cf(n) for all
but ﬁnitely many n.
• g = Θ(f) if g = O(f) and g = Ω(f).
• log n stands for log2 n. When log n is required to be an integer, it is
understood that it takes the value log2 n.
The variable n usually refers to the length of an input string to a machine
or circuit. When n appears in the deﬁnition of a resource class such as
ATime(k log n + k) it refers to the argument of the function bounding the
resource. For a class Resource(f) that is deﬁned by having a bound f on
some resource we will write Resource(O(f)) for the union
∞


Resource(kf + k).

k=1

For example (see Section A.4):
ATime(O(log n)) =

∞


ATime(k log n + k).

k=1

A.1. Deterministic Turing Machines
A k–tape deterministic Turing machine (DTM) consists of k two–way
inﬁnite tapes and a ﬁnite state control. Each tape is divided into squares,
each of which holds a symbol from a ﬁnite alphabet Γ. Each tape also
has a read/write head that is connected to the control and that scans
445

446

A. Computation Models

the squares on the tape. Depending on the state of the control and the
symbols scanned, the machine makes a move which consists of
1) printing a symbol on each tape;
2) moving each head left or right one square, or leaving it ﬁxed;
3) assuming a new state.
Deﬁnition A.1.1. For a natural number k ≥ 1, a k–tape DTM M is
speciﬁed by a tuple Q, Σ, Γ,  where
1) Q is the ﬁnite set of states. There are 3 distinct designated states qinitial
(the initial state), qaccept and qreject (the states in which M halts).
2) Σ is the ﬁnite, non-empty set of input symbols.
3) Γ is the ﬁnite set of working symbols, Σ ⊂ Γ. Γ contains a special
symbol b
/ (read “blank”), and b
/ ∈ Γ \ Σ.
4) is the transition function, i.e., a total function:
: ((Q \ {qaccept , qreject }) × Γk ) → (Q × (Γ × {L, R, O})k ).
If the current state is q, the current symbols being scanned are s1 , . . . , sk ,
and (q, s) = (q  , s1 , h1 , . . . , sk , hk ), then q  is the new state, s  are the
symbols printed, and for 1 ≤ i ≤ k, the head of the ith tape will move
one square to the left or right or not move, depending on whether hi is L
or R or O.
On an input x (a ﬁnite string of Σ symbols) the machine M works as
follows. Initially, the input is given on tape 1, called the input tape, which
is completely blank everywhere else. Other tapes (i.e., the work tapes) are
blank, and their heads point to some squares. Also the input tape head
is pointing to the leftmost symbol of the input (if the input is the empty
string, then the input tape will be completely blank, and its head will point
to some square). The control is initially in state qinitial . Then M moves
according to the transition function .
If M enters either qaccept or qreject then it halts. If M halts in qaccept we say
that it accepts the input x, if it halts in qreject then we say that it rejects x.
Note that it is possible that M never halts on some input. Let Σ∗ denote
the set of all ﬁnite strings of Σ symbols. We say that M accepts (or decides,
or computes) a language L ⊆ Σ∗ if M accepts input x ∈ Σ∗ iﬀ x ∈ L. We
let L(M) denote the language accepted by M.
Unless speciﬁed otherwise, Turing machines are multi-tape (i.e., k > 1).
In this case we require that the input tape head is read-only. Also, for a
Turing machine M to compute a (partial) function, tape 2 is called the
output tape and the content of the output tape when the machine halts in
qaccept is the output of the machine. For machines that compute a function
we require that the output tape is write-only.
A conﬁguration of M is a tuple q, u1 , v1 , . . . , uk , vk  ∈ Q × (Γ∗ × Γ∗ )k .
The intuition is that q is the current state of the control, the string ui vi is
the content of the tape i, and the head of tape i is on the left-most symbol

447

A.1. Deterministic Turing Machines

of vi . If both ui and vi are the empty string, then the head points to a
blank square. If only vi is the empty string then the head points to the
left-most blank symbol to the right of ui . We require that for each i, ui
does not start with the blank symbol b
/, and vi does not end with b
/.
The computation of M on an input x is the (possibly inﬁnite) sequence of conﬁgurations of M, starting with the initial conﬁguration
qinitial , , x, , , . . . , , , where  is the empty string, and each subsequent
conﬁguration is obtained from the previous one as speciﬁed by the transition function . Note that the sequence can contain at most one ﬁnal
conﬁguration, i.e., a conﬁguration of the form qaccept , . . . or qreject , . . ..
The sequence contains a ﬁnal conﬁguration iﬀ it is ﬁnite iﬀ M halts on x.
The length of the computation is the length of the sequence.
A.1.1. L, P, PSPACE, and EXP. Suppose that a Turing machine M =
Q, Σ, Γ,  halts on input x. Then the running time of M on x, denoted
by timeM (x), is the number of moves that M makes before halting (i.e.,
the number of conﬁgurations in the computation of M on x, not counting
the initial conﬁguration). Otherwise we let timeM (x) = ∞.
Recall that L(M) denotes the language accepted by M. We say that M
runs in time f(n) if for all but ﬁnitely many x ∈ Σ∗ , timeM (x) ≤ f(|x|),
where |x| denotes the length of x. In this case we also say that M accepts
the language L(M) in time f(n).
Deﬁnition A.1.2 (DTime). For a function f(n), deﬁne
DTime(f) = {L : there is a DTM accepting L in time f(n)}.
In general, if f is at least linear, then the class DTime(f) is robust in
the following sense.
Theorem A.1.3 (Speed-up). For any  > 0,
DTime(f) ⊆ DTime((1 + )n + f).
The classes of polynomial time and exponential time computable languages are deﬁned as follows.
Deﬁnition A.1.4 (P and EXP).
∞

P =
DTime(n k + k),
k=1

EXP =

∞


k

DTime(2n + k).

k=1

The working space of a (multi-tape) DTM M on input x, denoted
by spaceM (x), is the total number of squares on the work tapes (i.e.,
excluding the input and output tapes) that M visits at least once during
the computation. Note that it is possible that spaceM (x) = ∞, and also
that spaceM (x) can be ﬁnite even if M does not halt on x.
We say that M runs in space f(n) if for all but ﬁnitely many x ∈ Σ∗ ,
spaceM (x) ≤ f(|x|). In this case we also say that M accepts the language
L(M) in space f(n).

448

A. Computation Models

Deﬁnition A.1.5 (DSpace). For a function f(n), deﬁne
DSpace(f) = {L : there is a DTM accepting L in space f(n)}.
Theorem A.1.6 (Tape Compression). For any  > 0 and any function f,
DSpace(max{f, 1}) = DSpace(f).
The class of languages computable in logarithmic and polynomial space
are deﬁned as follows.
Deﬁnition A.1.7 (L and PSPACE).
∞
∞


DSpace(k log n + k),
PSPACE =
DSpace(n k + k).
L=
k=1

k=1

For a single-tape Turing machine, the working space is the total number
of squares visited by the tape head during the computation. The classes
P, PSPACE and EXP remain the same even if we restrict to single-tape
DTMs. This is due to the following theorem.
Theorem A.1.8 (Multi Tape). For each multi-tape Turing machine M
that runs in time t(n) and space s(n), there is a single–tape Turing machine
M that runs in time (t(n))2 and space max{n, s(n)} and accepts the same
language as M. There exists also a 2–tape Turing machine M that works
in space s(n) and accepts L(M).
For the Time Hierarchy Theorem below we need the notion of time
constructible function. A function f(n) is time constructible if there is
a Turing machine M such that on input x the running time of M is
Θ(f(|x|)). It turns out that common integer-valued functions such as
kn, nlog n, n k , n log n , 2n are time constructible. We will be concerned
only with time bounding functions that are constructible.
Theorem A.1.9 (Time Hierarchy). Suppose that f(n) is a function,
f(n) ≥ n, and g(n) is a time constructible function so that
lim inf

n→∞

f(n) log f(n)
= 0.
g(n)

Then
DTime(g) \ DTime(f) = ∅.
A function f(n) is space constructible if there is Turing machine M such
that on input x the working space of M is Θ(f(|x|)). The space bounds
that we are interested in are all constructible.
Theorem A.1.10 (Space Hierarchy). Suppose that f(n) is a function
and g(n) is a space constructible function so that
g(n) = Ω(log n)

and

lim inf

n→∞

f(n)
= 0.
g(n)

Then
DSpace(g) \ DSpace(f) = ∅.

A.2. Nondeterministic Turing Machines

449

It is easy to see that
L ⊆ P ⊆ PSPACE ⊆ EXP.

(402)

The Time Hierarchy Theorem shows that
DTime(n)  DTime(n 2 )  · · ·

and

P  DTime(2n )

for any  > 0. The Space Hierarchy Theorem shows that L  PSPACE.
However none of the immediate inclusions in (402) is known to be proper.
Sublinear time classes are deﬁned using Turing machines that are equipped with an index tape that operates like a work tape, except its content is
used for accessing the input in the following way: the machine queries an
input bit by writing its position in binary on the index tape and enter some
special state. (Dowd, see [22], shows that a deterministic logtime Turing
machine can compute the length of its input written in binary.) Deﬁne
DLogTime = DTime(O(log n))
and deﬁne NLogTime and ALogTime similarly using nondeterministic
and alternating Turing machines given in Sections A.2 and A.4.

A.2. Nondeterministic Turing Machines
Deﬁnition A.2.1. A k–tape nondeterministic Turing machine (NTM)
is speciﬁed by a tuple Q, Σ, Γ,  as in Deﬁnition A.1.1, but now the
transition function is of the form
: ((Q \ {qaccept , qreject }) × Γk ) → P(Q × (Γ × {L, R, O})k )
where P(S) denotes the power set of the set S.
Here (q, s1 , . . . , sk ) is the (possibly empty) set of possible moves of M,
given that the current state is q and the symbols currently being scanned
are s.
A computation of M on an input x is a (possibly inﬁnite) sequence of
conﬁgurations of M, starting with the initial conﬁguration
qinitial , , x, , , . . . , , 
and each subsequent conﬁguration is a conﬁguration that can be obtained
from the previous one by one of the possible moves speciﬁed by . By
deﬁnition, each computation of M may contain at most one conﬁguration
of the form qaccept , . . . or qreject , . . .. In the former case we say that it is
an accepting computation, and in the latter case we say that it is a rejecting
computation.
We say that the NTM M accepts x is there is an accepting computation
of M on x. We say that M accepts x in time f(n) if there is an accepting
computation of length ≤ f(|x|), and M accepts x in space f(n) if there

450

A. Computation Models

is an accepting computation such that the number of squares on the work
tapes used by M during this computation is ≤ f(|x|).
If for all but ﬁnitely many x ∈ L(M) the NTM M accepts x in time/space
f(n), we also say that M accepts the language L(M) in time/space f(n).
Deﬁnition A.2.2 (NTime and NSpace). For a function f(n), deﬁne
NTime(f) = {L : there is a NTM accepting L in time f(n)},
NSpace(f) = {L : there is a NTM accepting L in space f(n)}.
The Speed-up Theorem (A.1.3) and Tape Compression Theorem
(A.1.6) continue to hold for NTMs.
Deﬁnition A.2.3 (NP and NL).
NP =

∞


NTime(n k + k),

NL =

k≥1

∞


NSpace(k log n + k).

k=1

The list in (402) is extended as follows:
L ⊆ NL ⊆ P ⊆ NP ⊆ PSPACE.
However, it is not known whether any of the immediate inclusions is
proper.
For a class C of languages, co-C is deﬁned to be the class of the complements of the languages in C. For deterministic classes L, P, EXP we
have C = co-C. However it is an open problem whether NP = co-NP.
For NL and co-NL we have an aﬃrmative answer, due to Immerman and
Szelepcsényi:
Theorem A.2.4 (Immerman–Szelepcsényi). For any space constructible
function f(n) ≥ log(n), NSpace(f) = co-NSpace(f).
It is also easy to see that
P ⊆ co-NP ⊆ PSPACE.
But it is unknown whether either inclusion is proper.
The class of languages computable by NTMs in polynomial space is
deﬁned similarly, but by Savitch’s Theorem this is the same as PSPACE.
Theorem A.2.5 (Savitch’s Theorem). For any space constructible function f(n) ≥ log n,
NSpace(f) ⊆ DSpace(f 2 ).
(Here the superscript in f 2 refers to multiplication, rather than composition.)
It follows that nondeterministic polynomial space is the same as
PSPACE, and also that NL  PSPACE.

451

A.3. Oracle Turing Machines

A.3. Oracle Turing Machines
Let L be a language. An Oracle Turing machine (OTM) M with oracle
L is a Turing machine augmented with the ability to ask questions of
the form “is y ∈ L?”. Formally, M has a designated write-only tape for
the queries, called the query tape. It also has 3 additional states, namely
qquery , qYes and qNo . In order to ask the question “is y ∈ L?”, the machine
writes the string y on the query tape, and enters the state qquery . The next
state of M is then either qYes or qNo , depending on whether y ∈ L. Also
the query tape is blanked out before M makes the next move.
In case the queries are witnessed (e.g., Deﬁnition VIII.7.16) or we want
a function oracle, i.e., oracles that answer queries of the form
F (W )?
for some function F , then the OTM will have a read-only answer tape that
contains oracle replies. The head of the answer tape is positioned to the
left-most non-blank square whenever the machine enters the state qquery .
The running time of M on an input x is deﬁned as before. Note that
the time it takes to write down the queries (and to read the oracle answers/witnesses) are counted. In particular, an OTM running in polynomial time can ask only polynomially long queries.
A nondeterministic oracle Turing machine (NOTM) is a generalization
of OTM where the transition function is a many-valued function. For
a language L, we denote by PL the class of languages accepted by some
OTM running in polynomial time with L as the oracle, and similarly NPL
the class of languages accepted by some NOTM running in polynomial
time with L as the oracle. For a class C of languages, deﬁne


PL ,
and
NPC =
NPL .
PC =
L∈C

L∈C

C

Deﬁne NLinTime similarly, where (see Deﬁnition A.2.2)
NLinTime = NTime(O(n)).
(Relativizing logspace classes is more complicated, see [1] for details.)
The polynomial time hierarchy (PH) and linear time hierarchy (LTH)
are deﬁned in Section III.4.1 as follows.
Deﬁnition A.3.1 (PH). Δp0 = Σp0 = Πp0 = P. For i ≥ 0,
p

Σpi+1 = NPΣi ,

Πpi+1 = co-Σpi+1 ,

And
PH =

∞

i=0

Σpi .

p

Δpi+1 = PΣi .

452

A. Computation Models

Thus NP ⊆ PH, and it can be shown that PH ⊆ PSPACE. However
neither inclusion is known to be proper. It is also not known whether the
polynomial time hierarchy is proper.
Deﬁnition A.3.2 (LTH).
Σlin
1 = NLinTime,

lin

Σi
Σlin
i+1 = NLinTime

and
LTH =

∞


for i ≥ 1,

Σlin
i .

i=1

Thus LTH ⊆ PH, and as far as we know, P and LTH are incomparable. Both PH and LTH can be alternatively deﬁned using the notion of
alternating Turing machines, which we will deﬁne in the next section.

A.4. Alternating Turing Machines
An alternating Turing machine (ATM) M is deﬁned as in Deﬁnition
A.2.1 for a nondeterministic Turing machine, but now the ﬁnite set Q \
{qaccept , qreject } is partitioned into 2 disjoint sets of states, namely the set
of ∃ states and the set of ∀ states.
If a conﬁguration c2 of M can be obtained from c1 as speciﬁed by the
transition function , we say that it is a successor conﬁguration of c1 . An
existential (resp. universal) conﬁguration is a conﬁguration of the form
q, . . . where q is an ∃-state (resp. a ∀-state).
We deﬁne the set of accepting conﬁgurations to be the smallest set of
conﬁgurations that satisﬁes:
• a ﬁnal conﬁguration of the form qaccept , . . . is an accepting conﬁguration (a ﬁnal accepting conﬁguration);
• an existential conﬁguration is accepting iﬀ at least one of its successor
conﬁguration is accepting;
• a universal conﬁguration is accepting iﬀ all of its successor conﬁgurations are accepting.
We say that M accepts x iﬀ the initial conﬁguration qinitial , , x, , , . . . , , 
is an accepting conﬁguration of M.
A computation of M on an input x is viewed as a tree T with leaves
labeled with the conﬁgurations as follows:
• the root of T is labeled with the initial conﬁguration of M on x;
• if v is an inner node of T labeled with a universal conﬁguration c
which has k successor conﬁgurations, then v has k children each
labeled uniquely by a successor conﬁguration of c;
• if v is an inner node of T labeled with an existential conﬁguration
c which has k successor conﬁgurations, then v has k  children for

A.5. Uniform Circuit Families

453

some k  , 1 ≤ k  ≤ k, and each child of v is labeled uniquely by a
successor conﬁguration of c.
A ﬁnite computation of M is called an accepting computation if all its leaves
are labeled with a ﬁnal accepting conﬁguration.
We say that an ATM M accepts (or computes, or decides) x in time t if
there is an accepting computation of M on input x where the paths from
the root to any leaf has length ≤ t. We say that M accepts (or computes,
or decides) x in space s if there is an accepting computation of M on input
x in which every conﬁguration has size at most s. Also M accepts (or
computes, or decides) L = L(M ) in time f(n) (resp. space f(n)) if for
all x ∈ L, M accepts x in time f(|x|) (resp. space f(|x|)).
The alternation depth of a computation is the maximum over all paths
from root to leaf of one plus the number of changes of state type (i.e.
existential or universal) along the path. In particular, the alternation
depth of a computation of a nondeterministic Turing machine is one.
Deﬁnition A.4.1. For functions f(n), g(n), ATime(f) is the class of
languages that are accepted by an ATM in time f(n), ATime-Alt(f, g) is
the class of languages that are accepted by an ATM in time f(n) with at
most g(n) alternations, ASpace-Time(f, g) is the class of languages that
are accepted by an ATM in space f(n) and time g(n), ASpace-Alt(f, g)
is the class of languages that are accepted by an ATM in space f(n) with
at most g(n) alternations.
It can be seen that for i ≥ 1, Σpi is the class of languages accepted by a
polytime ATM with at most i alternations and an existential initial state,
and Πpi is deﬁned similarly with a universal initial state.
In the next section we deﬁne the circuit classes such as NC k , AC k . They
can be equivalently deﬁned using ATMs.

A.5. Uniform Circuit Families
A Boolean circuit (or just circuit) C with inputs x0 , x1 , . . . , xn−1 is a
directed acyclic graph in which each gate (i.e., node) that has indegree 0 is
either an input gate and is labeled with some variable xi or a constant gate
and is labeled with a Boolean constant (0 for False and 1 for True), and
each gate that has indegree k > 0 (called an inner gate) is labeled with a
Boolean function of k variables. Gates with outdegree 0 are called output
gates. For a gate g with indegree k > 0, the inputs to g are those gates
g  for which there is an edge from g  to g. Unless otherwise speciﬁed, the
circuits are assumed to contain inner gates of type ¬, ∧ and ∨ only.
When the input gates x0 , x1 , . . . , xn−1 are assigned values according to
an input string a in {0, 1}n then the value (or output) of each gate in
C is deﬁned inductively as follows. The value of a constant gate is the

454

A. Computation Models

label assigned to the gate and the value of an input gate labelled xi is ai .
The value of every other gate g is the value of the labeling function when
applied to the values of the inputs to g.
Suppose that C is a circuit with a single output gate. The value (or
output) of C on input a is the value of the output gate of C . We say that
C accepts a iﬀ it outputs 1 on input a.
Note that each circuit accepts strings of a ﬁxed length. So to decide a
language we need a family of circuits, one for each length. Thus we often
consider a family {Cn : n ≥ 1} of circuits where for each n ≥ 1, Cn is a
circuit with n inputs. We say that a language L ⊆ {0, 1}∗ is accepted (or
decided, or computed) by such a family if L is the set of all w such that w
is accepted by Cn , where n is the length of w.
In the same way we can deﬁne the function computed by a family of
circuits. Here the circuits are allowed to have a sequence of output gates
that make up the output string.
Our deﬁnition allows the existence of hardwired families of circuits that
accept non-computable languages. However for the complexity classes
of interest to us we need uniform families of circuits: i.e. circuit families
which can be described by languages in weak complexity classes such as
DLogTime or FO.
Following [100] the uniformity of a family of circuits is deﬁned in
terms of its direct connection language or extended connection language
given below. Informally, the former describes gate types and edges of the
circuits while the latter describes gate types and paths in the circuits.
Consider for example a family of circuits {Cn } where for n ≥ 1 Cn has
n inputs and all inner gates in Cn are either ¬ or binary ∧, ∨ gates. Thus
every inner gate g has either two inputs which we call the left and right
input of g and denote by g(L) and g(R), respectively, or one input which
we denote by g(L). Suppose that each gate g in a circuit Cn is numbered
with a unique natural number less than the size of Cn , so that inputs gates
of Cn are numbered 0, 1, . . . , (n − 1).
Deﬁnition A.5.1. The direct connection language LD of {Cn } is the set
of (the binary string encodings of)
n, g, p, y
where n, g ∈ N, p ∈ {, L, R}, y ∈ {∧, ∨, ¬, 0, 1, input} ∪ N, such that in
Cn either
• p = , y ∈ {∧, ∨, ¬, 0, 1, input} and gate g is an y-gate, or
• p ∈ {L, R}, y ∈ N and gate g(p) is numbered y.
The extended connection language LE of {Cn } is deﬁned in the same way,
except now p ∈ {L, R}∗ and g(p) is the gate that is reached from gate g
by following the path speciﬁed by p.

A.5. Uniform Circuit Families

455

The complexity of recognizing LD or LE determines uniformity of the
family {Cn }. For k ≥ 2 the deﬁnition of NC k does not depend on whether
LD or LE is used, however for NC 1 it is important that we take LE .
Deﬁnition A.5.2 (NC k ). For k ≥ 1, a language L is in uniform NC k
if it is accepted by a family of polynomial–size logarithmic–depth circuits
{Cn } whose extended connection language LE is in FO.
When k = 1 if we only require the direct connection language LD of
{Cn } be in FO, the result, denoted here by NC 1D , is apparently a bigger
class: we have NC 1 ⊆ NC 1D , but it is not known whether NC 1 = NC 1D .
Theorem A.5.3 (Ruzzo [100]). For k ≥ 1,
NC k = ASpace-Time(O(log n), O((log n)k )).
In particular we have:
NC 1 = ATime(O(log n)) = ALogTime.
The classes AC k , TC 0 and AC 0 (m) are deﬁned using circuits whose
gates have unbounded fanin. The direct (resp. extended) connection language LD (resp. LE ) for these circuits can be deﬁned as in Deﬁnition A.5.1
but now p ∈ {1, 2, 3, . . . } (resp. p ∈ {1, 2, 3, . . . }∗ ). It is easy to see that
for constant depth circuits (i.e., AC 0 , AC 0 (m), TC 0 ) it does not matter
whether we use LD or LE to deﬁne uniformity. It turns out that this is
also the case for AC k for k ≥ 1.
Deﬁnition A.5.4 (AC k ). For k ≥ 0, a language L is in AC k iﬀ it is
accepted by a family of circuits {Cn } of size polynomial in n and depth
O((log n)k ) whose direct connection language LE is in FO.
The class AC 0 has several equivalent deﬁnitions, see Sections IV.1
and IV.3.2. In particular, AC 0 = LH where
LH = ATime-Alt(O(log n), O(1)).
For k ≥ 1 we have (see also the fact that the problem Lmcvk is in
ASpace-Time(log n, (log n)k ), Theorem IX.5.28):
Theorem A.5.5 ([40, 110]). For k ≥ 1,
AC k = ASpace-Alt(O(log n), O((log n)k )).
Note that by Immerman–Szelepcsényi Theorem A.2.4
ASpace-Alt(O(log n), O(1)) = NL.
The classes uniform TC 0 and AC 0 (m) are deﬁned similarly using circuits that have (in addition to ¬ gates and unbounded fanin ∧, ∨ gates)
majority gates and modulo m gates, respectively. A majority gate outputs
one iﬀ at least half of its inputs are one, and a modulo m gate outputs one
iﬀ the number of one inputs is 1 modulo m.

456

A. Computation Models

Deﬁnition A.5.6 (TC 0 , AC 0 (m)). A language is in TC 0 iﬀ it is accepted by a family of polynomial–size constant–depth circuits with majority gates whose extended connection language LE is in FO. For m ≥ 2
the class AC 0 (m) is deﬁned similarly with modulo m gates replace majority
gates. Also,
∞

AC 0 (m).
ACC =
m=2
0

The class TC can be equivalently deﬁned using threshold gates, which
outputs one iﬀ the number of one inputs exceeds some given threshold k.
It can be shown that
ACC ⊆ TC 0 ⊆ NC 1
and that
AC 0 (m) ⊆ AC 0 (m  )

for m, m ∈ N such that m|m  . Ajtai [3] and independently Furst,
Saxe, and Sipser [52] show that the relation PARITY (see Sections IV.1
and V.5.1) is not in AC 0 , and since PARITY ∈ AC 0 (2), it follows that
AC 0  AC 0 (2).
Razborov and Smolensky (see [19]) show that MODULOm ∈ AC 0 (p) for
any prime p and any m ≥ 2 which is not a power of p. It follows that
AC 0 (m) ⊆ AC 0 (p).
Consequently we have
AC 0  AC 0 (p)  ACC.
However, it is not known whether AC 0 (6) = NP.

BIBLIOGRAPHY

[1] Klaus Aehlig, Stephen Cook, and Phuong Nguyen, Relativizing Small Complexity Classes and their Theories, 16th EACSL Annual
Conference on Computer Science and Logic, 2007, pp. 374–388.
[2] Manindra Agrawal, Neeraj Kayal, and Nitin Saxena, PRIMES
is in P, Annals of Mathematics, vol. 160 (2004), no. 2, pp. 781–793.
[3] Miklós Ajtai, Σ11 -formulae on ﬁnite structures, Annals of Pure and
Applied Logic, vol. 24 (1983), no. 1, pp. 1– 48.
[4]
, Parity and the Pigeonhole Principle, Feasible Mathematics
(S. R. Buss and P. J. Scott, editors), Birkhäuser, 1990, pp. 1–24.
[5]
, The complexity of the pigeonhole principle, Combinatorical,
vol. 14 (1994), no. 4, pp. 417– 433.
[6]
, The Independence of the Modulo Counting p Principles,
Proceedings of the 26th Annual ACM Symposium on Theory of Computing,
1994, pp. 402– 411.
[7] Eric Allender, Arithmetic Circuits and Counting Complexity
Classes, Complexity of Computations and Proofs (Jan Krajı́ček, editor),
Quaderni di Matematica, 2005, pp. 33–72.
[8] Toshiyasu Arai, A bounded arithmetic AID for Frege systems, Annals of Pure and Applied Logic, vol. 103 (2000), no. 1–3, pp. 155–199.
[9] David A. Barrington, Bounded-Width Polynomial-Size Branching
Programs Recognizes Exactly Those Languages in NC 1 , Journal of Computer and System Sciences, vol. 38 (1989), no. 1, pp. 150–164.
[10] David A. Mix Barrington, Neil Immerman, and Howard
Straubing, On Uniformity within NC1 , Journal of Computer and System
Sciences, vol. 41 (1990), no. 3, pp. 274–306.
[11] Paul Beame, Russell Impagliazzo, Jan Krajı́ček, Toniann
Pitassi, and Pavel Pudlák, Exponential lower bounds for the pigeonhole
principle, Proceedings of the 24th Annual ACM Symposium on Theory of
Computing, 1992, pp. 200–220.
[12] Paul Beame and Toniann Pitassi, An exponential separation between the parity principle and the pigeonhole principle, Annals of Pure and
Applied Logic, vol. 80 (1996), pp. 195–228.

457

458

Bibliography

, Propositional Proof Complexity: Past, Present and Future,
[13]
Current Trends in Computer Science Entering the 21st Century (G. Paun,
G. Rozenberg, and A. Salomaa, editors), World Scientiﬁc Publishing,
2001, pp. 42–70.
[14] Paul Beame and Søren Riis, More on the Relative Strength of
Counting Principles, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, vol. 39 (1998), pp. 13–35.
[15] James Bennett, On Spectra, Ph.D. thesis, Princeton University,
Department of Mathematics, 1962.
[16] J. A. Bondy, Induced subsets, Journal of Combinatorial Theory,
Series B, vol. 12 (1972), pp. 201–202.
[17] Maria Luisa Bonet, Samuel R. Buss, and Toniann Pitassi, Are
there Hard Examples for Frege Systems?, Feasible Mathematics II (P. Clote
and J. B. Remmel, editors), Birkhäuser, 1994, pp. 30–56.
[18] Maria Luisa Bonet, Toniann Pitassi, and Ran Raz, On Interpolation and Automatization for Frege Systems, SIAM Journal on Computing,
vol. 29 (2000), no. 6, pp. 1939–1967.
[19] Ravi B. Boppana and Michael Sipser, The Complexity of Finite
Functions, Handbook of Theoretical Computer Science, Volume A (J. van
Leeuwen, editor), Elsevier, 1990, pp. 757–804.
[20] Samuel Buss, Bounded Arithmetic, Bibliopolis, 1986.
[21]
, Polynomial size proofs of the propositional pigeonhole principle, The Journal of Symbolic Logic, vol. 52 (1987), pp. 916–927.
[22]
, The Boolean formula value problem is in ALOGTIME,
Proceedings of the 19th Annual ACM Symposium on Theory of Computing,
1987, pp. 123–131.
[23]
, Axiomatizations and Conservation Results for Fragments
of Bounded Arithmetic, Logic and Computation, Proceedings of a Workshop
held at Carnegie Mellon University, AMS Contemporary Mathematics
(106), 1990, pp. 57–84.
, Propositional Consistency Proofs, Annals of Pure and Ap[24]
plied Logic, vol. 52 (1991), pp. 3–29.
[25]
, Algorithms for Boolean formula evaluation and for treecontraction, Arithmetic, Proof Theory, and Computational Complexity (Peter Clote and Jan Krajı́ček, editors), Oxford, 1993, pp. 95–115.
[26]
, Relating the bounded arithmetic and polynomial time hierarchies, Annals of Pure and Applied Logic, vol. 75 (1995), pp. 67–77.
[27]
, An Introduction to Proof Theory, Handbook of Proof
Theory (S. Buss, editor), Elsevier, 1998, available on-line at www.math.
ucsd.edu/~sbuss/ResearchWeb/HandbookProofTheory/, pp. 1–78.
[28]
, First-Order Proof Theory of Arithmetic, Handbook
of Proof Theory (S. Buss, editor), Elsevier, 1998, available on-line at
www.math.ucsd.edu/~sbuss/ResearchWeb/HandbookProofTheory/,
pp. 79–147.

Bibliography

459

[29] Samuel Buss and Peter Clote, Cutting planes, connectivity and
threshold logic, Archive for Mathematical Logic, vol. 35 (1996), pp. 33–62.
[30] Samuel Buss and Jan Krajı́ček, An application of Boolean complexity to separation problems in bounded arithmetic, Proc. London Math.
Soc., vol. 69(3) (1994), pp. 1–21.
[31] Samuel Buss, Jan Krajı́ček, and Gaisi Takeuti, On Provably
Total Functions in Bounded Arithmetic Theories R3i , U2i , and V2i , Arithmetic, Proof Theory and Computational Complexity (Peter Clote and Jan
Krajı́ček, editors), Oxford, 1993, pp. 116–161.
[32] Ashok K. Chandra, Larry Stockmeyer, and Uzi Vishkin, Constant Depth Reducibility, SIAM Journal on Computing, vol. 13(2) (1984),
pp. 423– 439.
[33] Mario Chiari and Jan Krajı́ček, Witnessing functions in bounded
arithmetic and search problems, The Journal of Symbolic Logic, vol. 63
(1998), pp. 1095–1115.
[34] P. Clote, ALOGTIME and a conjecture of S. A. Cook, Ann. Math.
Art. Intell., vol. 6 (1990), pp. 57–106, extended abstract in Proc. 13th IEEE
Symposium on Logic in Computer Science, 1990.
[35] Pepter Clote and Gaisi Takeuti, Bounded arithmetic for NC,
ALogTIME, L and NL, Annals of Pure and Applied Logic, vol. 56 (1992),
pp. 73–117.
[36] Peter Clote, Sequential, Machine-Independent Characterizations
of the Parallel Complexity Classes AlogTIME, ACk , NC k and NC, Feasible
Mathematics (S. R. Buss and P. J. Scott, editors), Birkhäuser, 1990, pp. 49–
70.
, On Polynomial Size Frege Proofs of Certain Combinato[37]
rial Principles, Arithmetic, Proof Theory, and Computational Complexity
(Peter Clote and Jan Krajı́ček, editors), Oxford, 1993, pp. 162–184.
[38] Peter Clote and Gaisi Takeuti, First Order Bounded Arithmetic
and Small Boolean Circuit Complexity Classes, Feasible Mathematics II
(P. Clote and J. B. Remmel, editors), Birkhäuser, 1995.
[39] Stephen Cook, Feasibly constructive proofs and the propositional
calculus, Proceedings of the 7th Annual ACM Symposium on Theory of
Computing, (1975), pp. 83–97.
[40]
, A Taxonomy of Problems with Fast Parallel Algorithms,
Information and Control, vol. 64 (1985), pp. 2–22.
[41]
, Proof Complexity and Bounded Arithmetic, Course Notes
for CSC 2429S. http://www.cs.toronto.edu/~sacook/, 2002.
, Theories for Complexity Classes and Their Propositional
[42]
Translations, Complexity of computations and proofs (Jan Krajı́ček, editor), Quaderni di Matematica, 2005, pp. 175–227.
[43] Stephen Cook and Antonina Kolokolova, A Second-Order System for Polytime Reasoning Based on Grädel’s theorem, Annals of Pure and
Applied Logic, vol. 124 (2003), pp. 193–231.

460

Bibliography

, A Second-order Theory for NL, Logic in Computer Science
[44]
(LICS), 2004.
[45] Stephen Cook and Tsuyoshi Morioka, Quantiﬁed Propositional
Calculus and a Second-Order Theory for NC1 , Archive for Mathematical
Logic, vol. 44 (2005), no. 6, pp. 711–749.
[46] Stephen Cook and Robert Reckhow, The Relative Eﬃciency
of Propositional Proof Systems, The Journal of Symbolic Logic, vol. 44
(1979), no. 1, pp. 36–50.
[47] Stephen Cook and Neil Thapen, The Strength of Replacement
in Weak Arithmetic, ACM Transactions on Computational Logic, vol. 7
(2006), no. 4, pp. 749–764.
[48] Martin Dowd, Propositional Representation of Arithmetic Proofs,
Ph.D. thesis, Department of Computer Science, University of Toronto,
1979.
[49] Ding-Zhu Du and Ker-I Ko, Theory of Computational Complexity, Wiley-Interscience, 2000.
[50] Ronald Fagin, Contributions to the Model Theory of Finite Structures, Ph.D. thesis, U. C. Berkeley, Department of Mathematics, 1973.
[51] Peter Frankl, On the Trace of Finite Sets, Journal of Combinatorial Theory, Series A, vol. 34 (1983), pp. 41– 45.
[52] Merrick Furst, James B. Saxe, and Michael Sipser, Parity, circuits and the polynomial-time hierarchy, Mathematical Systems Theory,
vol. 17 (1984), pp. 13–27.
[53] Erich Grädel, Capturing Complexity Classes by Fragments of
Second Order Logic, Theoretical Computer Science, vol. 101 (1992), pp.
35–57.
[54] Petr Hájek and Pavel Pudlák, Metamathematics of First-Order
Arithmetic, Springer-Verlag, 1993.
[55] William Hess, Eric Allender, and David A. Mix Barrington, Uniform Constant-Depth Threshold Circuits for Division and Iterated
Multiplication, Journal of Computer and System Sciences, vol. 65 (2002),
pp. 695–716.
[56] Aleksandar Ignjatovic, Delineating Classes of Computational
Complexity via Second Order Theories with Weak Set Existence Principles,
The Journal of Symbolic Logic, vol. 60 (1995), pp. 103–121.
[57] Aleksandar Ignjatovic and Phuong Nguyen, Characterizing
Polynomial Time Computable Functions Using Theories with Weak Set
Existence Principles, Computing: The Australasian Theory Symposium,
Electronic Notes in Theoretical Computer Science, Volume 78, 2003.
[58] Neil Immerman, Nondeterministic Space is Closed Under Complementation, SIAM J. Comput., vol. 17 (1988), no. 5, pp. 935–938.
, Descriptive Complexity, Springer, 1999.
[59]

Bibliography

461

[60] Emil Jeřábek, Weak Pigeonhole Principle, and Randomized Computation, Ph.D. thesis, Charles University in Prague, Faculty of Mathematics and Physics, 2004.
, Approximate counting by hashing in bounded arithmetic,
[61]
preprint, 2007.
[62] Jan Johannsen, Satisﬁability problems complete for deterministic
logarithmic space, STACS 2004, 21st Annual Symposium on Theoretical
Aspects of Computer Science, Proceedings (Volker Diekert and Michel
Habib, editor), 2004, pp. 317–325.
[63] Jan Johannsen and Chris Pollett, On Proofs about Threshold
Circuits and Counting Hierarchies, Proceedings of the 13th IEEE Symposium on Logic in Computer Science, 1998, pp. 444– 452.
[64] David S. Johnson, A Catalog of Complexity Classes, Handbook
of Theoretical Computer Science, Volume A (J. van Leeuwen, editor),
Elsevier, 1990, pp. 67–161.
[65] David S. Johnson, Christos H. Papadimitriou, and Mihalis
Yannakakis, How easy is local search?, Journal of Computer and System Sciences, vol. 37 (1988), no. 1, pp. 79–100.
[66] Richard M. Karp and Richard J. Lipton, Turing machines that
take advice, L’Enseignement Mathematique, vol. 30 (1982), pp. 255–273.
[67] Antonina Kolokolova, Systems of Bounded Arithmetic from Descriptive Complexity, Ph.D. thesis, University of Toronto, 2004.
[68] Jan Krajı́ček, On the number of steps in proofs, Annals of Pure and
Applied Logic, vol. 41 (1989), pp. 153–178.
[69]
, Exponentiation and second-order bounded arithmetic, Annals of Pure and Applied Logic, vol. 48 (1990), pp. 261–276.
[70]
, Fragments of bounded arithmetic and bounded query
classes, Trans. AMS, vol. 338 (1993), no. 2, pp. 587–98.
, Lower bounds to the size of constant-depth propositional
[71]
proofs, The Journal of Symbolic Logic, vol. 59 (1994), pp. 73–86.
[72]
, Bounded Arithmetic, Propositional Logic and Computational Complexity, Cambridge University Press, 1995.
[73] Jan Krajı́ček and Pudlák, Quantiﬁed Propositional Calculi and
Fragments of Bounded Arithmetic, Zeitschrift f. mathematische Logik u.
Grundlagen d. Mathematik, vol. 36 (1990), pp. 29– 46.
[74] Jan Krajı́ček, Pavel Pudlák, and Jiri Sgall, Interactive computations of optimal solutions, Mathematical Foundations of Computer
Science (B. Rovan, editor), Lecture Notes in Computer Science, no. 452,
Springer-Verlag, 1990, pp. 48–60.
[75] Jan Krajı́ček, Pavel Pudlák, and Gaisi Takeuti, Bounded Arithmetic and the Polynommial Hierarchy, Annals of Pure and Applied Logic,
vol. 52 (1991), pp. 143–153.
[76] Jan Krajı́ček, Alan Skelley, and Neil Thapen, NP Search Problems in Low Fragments of Bounded Arithmetic, The Journal of Symbolic
Logic, vol. 72(2) (2007), pp. 649–672.

462

Bibliography

[77] John C. Lind, Computing in logarithmic space, Technical Report 52, MAC Technical Memorandum, 1974.
[78] Alexis Maciel, Phuong Nguyen, and Toniann Pitassi, Lifting
Lower Bounds for Tree-like Proofs, work in progress, 2009.
[79] Meena Mahajan and V. Vinay, Determinant: Combinatorics, algorithms, and complexity, Chicago Journal of Theoretical Computer Science,
vol. 5 (1997).
[80] Tsuyoshi Morioka, Logical Approaches to the Complexity of
Search Problems: Proof Complexity, Quantiﬁed Propositional Calculus,
and Bounded Arithmetic, Ph.D. thesis, University of Toronto, Department
of Computer Science, 2005.
[81] V. A. Nepomnjaščij, Rudimentary predicates and Turing calculations, Soviet Math. Dokl., vol. 11 (1970), no. 6, pp. 1462–1465.
[82] Phuong Nguyen, Bounded Reverse Mathematics, Ph.D. thesis,
University of Toronto, 2008, http://www.cs.toronto.edu/~pnguyen/.
[83] Phuong Nguyen and Stephen Cook, Theories for TC 0 and Other
Small Complexity Classes, Logical Methods in Computer Science, (2005).
[84]
, The Complexity of Proving Discrete Jordan Curve Theorem, Proceedings of the 22nd IEEE Symposium on Logic in Computer
Science, 2007, pp. 245–254.
[85] Noam Nisan and Amnon Ta-Shma, Symmetric logspace is closed
under complement, Proceedings of the 27th Annual ACM Symposium on
Theory of Computing, 1995, pp. 140–146.
[86] Akihiro Nozaki, Toshiyasu Arai, and Noriko H. Arai,
Polynomal-size Frege proofs of Bollobás’ theorem on the trace of sets, Proceedings of the Japan Academy, Series A, Mathematical Sciences, vol. 84
(2008), no. 8, pp. 159–161.
[87] Christos H. Papadimitriou, Computational Complexity, Addison
Wesley, 1993.
[88] Rohit Parikh, Existence and feasibility in arithmetic, The Journal
of Symbolic Logic, vol. 36 (1971), pp. 494–508.
[89] Jeﬀ B. Paris, W.G. Handley, and Alex J. Wilkie, Characterizing some low arithmetic classes, Theory of Algorithms (L. Lovász and E.
Smerédi, editor), Colloquia Mathematica Societatis Janos Bolyai, no. 44,
North-Holland, 1985, pp. 353–365.
[90] Jeﬀ B. Paris and Alex J. Wilkie, Counting problems in bounded
arithmetic, Methods in Mathematical Logic, Lecture Notes in Mathematics, no. 1130, Springer, 1985, pp. 317–340.
[91] Steven Perron, Power of Non-Uniformity in Proof Complexity,
Ph.D. thesis, University of Toronto, 2008.
[92] Francois Pitt, A Quantiﬁer-Free String Theory Alogtime Reasoning, Ph.D. thesis, University of Toronto, 2000.
[93] Chris Pollett, Structure and Deﬁnability in General Bounded
Arithmetic Theories, Annals of Pure and Applied Logic, vol. 100 (1999),
pp. 189–245.

Bibliography

463

[94] Michael Rabin, Digitalized Signatures and Public-Key Functions
as Intractable as Factorization, Technical Report MIT/LCS/TR-212,
MIT Laboratory for Computer Science, 1979.
[95] Alexander A. Razborov, An Equivalence between Second Order
Bounded Domain Bounded Arithmetic and First Order Bounded Arithmetic,
Arithmetic, Proof Theory and Computational Complexity (Peter Clote and
Jan Krajı́ček, editors), Oxford, 1993, pp. 247–277.
, Bounded Arithmetic and Lower Bounds in Boolean Com[96]
plexity, Feasible Mathematics II (P. Clote and J. Remmel, editors),
Birkhäuser, 1995, pp. 344–386.
[97] Omer Reingold, Undirected ST-Connectivity in Log-Space, Proceedings of the 37th Annual ACM Symposium on Theory of Computing,
2005, pp. 376–385.
[98] Søren Riis, Count(q) does not imply count(p), Annals of Pure and
Applied Logic, vol. 90 (1997), pp. 1–56.
, Count(q) versus the pigeon-hole principle, Archive for
[99]
Mathematical Logic, vol. 36 (1997), no. 3, pp. 157–188.
[100] Walter L. Ruzzo, On Uniform Circuit Complexity, Journal of
Computer and System Sciences, vol. 22 (1981), pp. 365–383.
[101] Stephen Simpson, Subsystems of Second Order Arithmetic,
Springer, 1999.
[102] Michael Sipser, Introduction to the Theory of Computation, second ed., Course Technology, 2005.
[103] Raymond Smullyan, Theory of Formal Systems, Princeton University Press, 1961.
[104] Michael Soltys and Stephen Cook, The Proof Complexity of
Linear Algebra, Annals of Pure and Applied Logic, vol. 130 (2004), pp. 277–
323.
[105] L. J. Stockmeyer, The polynomial-time hierarchy, Theoretical
Computer Science, vol. 3 (1976), pp. 1–21.
[106] R. Szelepcsényi, The method of forced enumeration for nondeterministic automata, Acta Informatica, vol. 26 (1988), no. 3, pp. 279–284.
[107] Gaisi Takeuti, S3i and V2i (BD), Archive for Mathematical Logic,
vol. 29 (1990), pp. 149–169.
[108]
, RSUV Isomorphism, Arithmetic, Proof Theory and Computational Complexity (Peter Clote and Jan Krajı́ček, editors), Oxford,
1993, pp. 364–386.
[109] G. S. Tseitin, On the complexity of derivation in propositional
calculus, Studies in Constructive Mathematics and Mathematical Logic,
Part 2 (A. O. Slisenko (Translated from Russian), editor), Consultants
Bureau, New York, London, 1970, pp. 115–125.
[110] Heribert Vollmer, Introduction to Circuit Complexity: A Uniform Approach, Springer-Verlag, 1999.

464

Bibliography

[111] Celia Wrathall, Rudimentary predicates and relative computation, SIAM J. Computing, vol. 7 (1978), pp. 194–209.
[112] Domenico Zambella, Notes on Polynomially Bounded Arithmetic,
The Journal of Symbolic Logic, vol. 61 (1996), no. 3, pp. 942–966.
, End Extensions of Models of Linearly Bounded Arith[113]
metic, Annals of Pure and Applied Logic, vol. 88 (1997), pp. 263–277.

INDEX

(Z |=0 X ), 383
(Z)x , see also sequence, coding
(Z |=i X ), 401
(Z |=Σq X ), (Z |=Πq X ), 385
i

i

0

0

(Z |=Σq X ), (Z |=Πq X ), 394
(Z |=Σ0 X ), (Z |=Σ0 X ), 384
(Z |= X ), 382
(∀2i ), (∃2i ), 61
=, =M , 19
A ⇐⇒ B, 10, 20
A ↔ B, 9
A ⊃ B, 9
A , 9
B |= A, 21
BF (i, x, Y ), 101
Gf (z, x, Y ), 101
QR1 ≤AC 0 QR2 , 229
R+ (X, Y, Z), see also addition, 85
R× (X, Y, Z), see also multiplication, 85
S(X ), see also successor function, 112
S(X, Y ), 378
Sk (X, Y ), 379
Tϕ (m, n), 374
U ∗t V , 231
X (t), 76
X + Y , see also addition, 102
X [i, j], see also substring function, 366
X ÷ Y , X/Y , see also division, 137
X ≤ Y , X < Y , 219
X × Y , see also multiplication, 136
X <x , Cut(x, X ), 139
Z −· Y , 220
Z [x] , Row(x, Z), 114
Δ0 (L), 51
FLAF , 367
FlaΣ (X ), FlaΠ (X ), 368
LA , 18
LFO , 74
Φ |= A, 20

Φ A, 33
Σ
FlaΠ
Φ (X ), FlaΦ (X ), 396
Φ |= A, |= A, 10
B
ΠB
i (L), Σi (L), 82
Σ
Prf F (, X ), Prf Π
F (, X ), 367
i
ΣB
j (V ), 403
Σ1 (L), 51
Σ11 , 82
ΣB
0 (Φ), 109
Σp0 , 130
Thk , 428
bin(X ), 85
M |= A, 19
M |= A[ ], 20
M |= Φ[ ], 20
T1 ⊂cons T2 , 201
=syn , 10
∃X ≤ T , ∀X ≤ T , 219
∃x, 42
∃x ≤ t, ∀x ≤ t, 42
∃!, 50
x/y , 60
−→ (empty sequent), 10
|= A, 20
parity(X ), 118
seq(x, Z), (Z)x , 115
N2 , 79
, ⊥, 9
val(t), 166
∅, see also empty set, 112
ϕ(X0 )[ ], 369
ϕF (y, , X, Y ), tF (, X ), 367
ϕFLA (y, X, Y ), tFLA , 368
ϕ  , 260
ϕ rec , see also BIT-REC
b 382
A,
{x}, see also POW2
{x}, POW2(x), 220
fϕ(z),t (x), 55

465

466

Index

p-simulation, 161
q
q
Gi+1 p-simulates Gi w.r.t. Σi ∪ Πi , 179
Gi p-simulates Gi+1 , 182
G0 p-simulates G0 w.r.t. prenex Σq1 , 180
t(s/x), A(s/x), 21
t < u, 40
t M [ ], 20
x −· y, 60
|X |, length function for string, 76
|T |, 81
|x| in IΔ0 , 64
#, 70, 256
ΔB
i formula, 212
Δ0 , 42
ΔN
0 , 67
Fϕ(z),t , fϕ(z),t , 125
L2A , 76
M , 258
N  , 259
PRF F , 367
Πpi , 451, 453
RFN ePK , 402
Φ-RFN F , 396
Σlog
i , 84
Σlin
i , 66, 452
Σbi , 70
Σpi , 65, 451, 453
Σqi , Πqi , 174
Σ1 , 42
p
Σ1 , 156
f  , F  , see also aggregate function
gΣB
i , 142
n, 40
pd, 125
Σqi -RFN F (0 , X0 , Z)[k], 407
ϕ(x, X )[m; n], 166
ϕ(x, X ), 166
 , 261
qdepth, 373
single-ΣB
1 , 115
N, 20
AC hierarchy, see also NC hierarchy
AC 0 , 73, 75, 83, 84, 95
AC 0 /poly, 75
FAC 0 closed under AC 0 -reduction, 270
characteristic functions of, 117
closure, see also closure
reduction, see also reduction
theories for, see also V 0
AC 0 (2), 308
characterized by 2-BNR, 308

theories for, see also V 0 (2), VAC 0 (2)V
AC 0 (6), 318
characterized by 4-BNR and 3-BNR, 318
theories for, see also VAC 0 (6)V, V 0 (m)
AC 0 function, see also FAC 0
AC 0 -Frege, 164
AC 0 -ITERATION , 230
AC 0 (m), 303, 313
deﬁnition of, 456
theories for, see also V 0 (m)
AC 0 -PLS, 230
AC 1 , 339
ACC, 303, 313
deﬁnition of, 456
theories for, see also VACC
AC k , 319, 320
deﬁnition of, 455
active sequent, 27
in LK 2 +IND, 152
adding n strings in TC 0 , 294
addition
R+ (X, Y, Z), 85
by divide-and-conquer, 330
carry-lookahead adder, 85
string function X + Y , 102, 112
Adequacy Theorem for LK-ID0 , 46
aggregate function, 201, 205, 273, 281
in Elimination Theorem, 276, 291
Aggregate Function Theorem, 208
algorithms
for HornSat, 224
ALogTime, see also NC 1 , 321, 455
DLogTime, 449
alternating Turing machine, see also ATM
Anchored Completeness Theorem
for LK, 30
for LK with =, 33
for LK 2 +IND, 151
for PK, 14
anchored proof, 14
LK, 30, 33
LK 2 , 89
LK subformula property, 33
with Φ-IND rule, 151
antecedent, 10
arithmetical functions, 107
ASpace-Alt, 320, 453, 455
ASpace-Time, 320, 453, 455
ATime, 453
ATime-Alt, 453, 455
ATM, 320, 452
atom, 9

Index
atomic formula, 9
auxiliary formula, 11, 22
auxiliary formulas, 175
axiom, 39
nonlogical, 13
axiom scheme
number vs. string, 97
bit recursion, see also BIT-REC
comprehension, see also COMP
induction, see also IND, PIND
maximization, see also MAX
minimization, see also MIN
replacement, see also REPL
string induction, see also SIND
string maximization, see also SMAX
string minimization, see also SMIN
0

B12 , B12 : axioms of V , 125
Barrington’s Theorem, 333
BASIC, 71
deﬁnition of, 257
1-BASIC, 40
2-BASIC, 95
2-BASIC + , 129
basic semantic deﬁnition, 20
Bennett’s Trick, 65, 68
bG 0 , see also bounded depth G0
bibliography, 457– 465
bin(X ), 85, 102, 293
binary notation, 85
binary search in VPV, 221
bit deﬁnition, see also bit-deﬁning axiom,
108
bit graph, 101
bit recursion axioms, see also BIT-REC
bit-deﬁnable function, 108
0
ΣB
0 bit deﬁnitions for FAC , 108
extension by, 109
BIT-REC, 222, 367
0
ΣB
0 -BIT-REC in TV , 222
blank symbol b
/, 446
BNR, 287, 339
pBNR, 288
pBNR characterizes L, 356
2-BNR characterizes AC 0 (2), 308
4-BNR, 3-BNR characterizes FAC 0 (6),
318
5-BNR characterizes NC 1 , 333
Bondy’s Theorem, 299
Boolean sentence
balanced, encoding of, 321
value problem, see also BSVP

467

Boolean Sentence Value Problem, see also
BSVP
bound variable, 19, 21
Bounded Deﬁnability Theorem, 52
bounded depth Frege, see also bounded
depth PK
bounded depth G, 195
bounded depth GTC 0 , 441
bounded depth PK, 161
deﬁnition of, 164
bounded depth PTK, 430
Bounded Depth Lower Bound Theorem,165
bounded formula, 42
of LS2 , 256
bounded induction scheme, 44
bounded length induction, 265
bounded number recursion, see also BNR
bounded quantiﬁer, 41
Bounded Reverse Mathematics, 268
open problems, 358
bounded theory, 45
bounding term, 45
bPK, see also bounded depth PK
branching program, 334
BSVP, see also MFV, 321, 334, 410, 414
candidate solution, 229
Cayley–Hamilton Theorem, 358
CC(S), 232
cedent, 10
extension cedent, 187
characteristic function, 116
circuit, 453
encoding of, 335
Monotone Circuit Value Problem, see also
MCV
Circuit Value Problem, 203, 335
reduced to HornSat, 224
class C
deﬁnable in VC, 274
deﬁnable in VC, 280
c 275, 278
deﬁnable in VC,
represented in LFC , 279
represented in LVC
c , 357
closed formula, 19
closed term, 19
closure
AC 0 -closure, 269
ΣB
0 -closure, 109
co-C, 450
co-NL, 450
co-NP, 450

468

Index

Cobham’s characterization, 137, 139, 140,
201, 210
collapse
of ACC (conditional), 316
of PH (conditional), 253
COMP
Σp0 -comp, 130
ΔB
i -COMP, 222
ΣB
0 (Φ)-COMP, 134
deﬁnition of, 96
multiple, see also MULTICOMP
proves IND, MIN, 98
Compactness Theorem
predicate calculus, 34
propositional, 16
two-sorted logic, 89
completeness, 73
Completeness Lemma for LK, 25
Completeness Theorem
LK 2 , 89
PTK, 430
Anchored LK, 30
Anchored PK, 14
Anchored, for LK with =, 33
for G, 176
for LK, derivational, 25
for LK, Revised, 33
for PK, 13
for PK, derivational, 13
major corollaries, 34
complexity class, 65
composition, 270
of Σ1 -deﬁnable functions, 51
comprehension
multiple, see also MULTICOMP
comprehension axioms, see also COMP
comprehension variable, 196
computation, 447
of ATM, 452
of NTM, 449
concatenation function U ∗t V , 231
Concatenation Recursion on Notation, 360
concurrent random access machine
(CRAM), 75
conﬁguration, 446
functions encoding, 138
connective, 9
general, restricted, 177
threshold Thk , 428
connectivity, see also st-CONN
RCONN , 340
RUCONN , 359

for undirected graphs, 359
consequent, 10
conservative extension, 51
T1 ⊂cons T2 , 201
assuming COMP, 110
assuming REPL, 147
w.r.t. Φ, 169
Conservative Extension Lemma, 52
Conservative Extension Theorem, 53
conservativity
i +1 over TV i , 402
ΣB
i +1 -conservativity of V
constant symbol, 17
contents, vii–x, xii
contraction rule derived from cut, 12
Count2 , 306
counting circuits, 326
counting gate, 282
counting quantiﬁer, 282
counting sequence, 283, 434
Countm , 316
CRN, 360
curve, 310
cut
anchored cut, 14
cut formula, 11
cut rule, 11
cut-free proof, 11
daglike proof system, 162
deﬁnability
1
ΣB
1 vs. Σ1 , 108
ΣB
-deﬁnability,
110, 269
0
bit-deﬁnable vs. deﬁnable, 109
two-sorted, 107
deﬁnability in V ∞ , 245
Deﬁnability Theorem
i
ΣB
i +1 -deﬁnable functions of TV , 248
B
i
+1
Σi +1 -deﬁnable functions of V , 248
i
ΣB
1 (LFPi+1 )-deﬁnable functions of VPV ,
248
0
ΣB
0 -deﬁnable functions of V , 110
Bounded Deﬁnability Theorem, 52
for IΔ0 , 69
for V 1 , 135, 156
for VPV, 214
for V 0 , 117
deﬁnable function, see also bit-deﬁnable
function, 50
and deﬁnable predicate, 116
bit-deﬁnable function, 108
from, 269
two-sorted, 107

Index
deﬁnable predicate, 50
Δ11 -, ΔB
1 -deﬁnable in T , 115
deﬁnable relation, 66
deﬁnable search problem, 232
deﬁning axiom
bit-deﬁning axiom, see also bit-deﬁning
axiom
deﬁning pair, 196
deﬁning triple, 412
dependence degree, 196, 412
depth of a formula, 164
descriptive complexity theory, 73, 74
characterization of P, 223
determined variable and sequent, 177
d -G0 , see also bounded depth G0
direct connection language, 454
Distance Problem, UDP, 359
divisibility relation, 61
division
X/Y deﬁnable in VTC 0 ?, 360
number function x/y , 60
string function X ÷ Y , X/Y , 137
DLogTime, 449
double-rail logic, 203
DSpace, 448
DTime, 447
DTM, see also Turing machine
E, see also empty set, axiom
eigenvariable, 22, 175
Elimination Lemma
ΣB
1 (LFC ), 280
ΣB
c ), 278
1 (LVC
FAC 0 , 127
Row, 114
Elimination Theorem
First, 276
Second, 291
empty set, 112
axiom for ∅, 91
encoding
formalization vs propositional translation, 387
of balanced monotone Boolean sentences,
321
of circuits, 335
of graphs, 339
of proofs, 365
endsequent, 10
ePK, see also extended PK, 382, 408
TV 0 RFN ePK , 402
equality axioms, 31

469

for LK, 32
for LK 2 , 88
Equality Theorem, 32
equivalence, 10, 20
EXP, 447
expansion
Σqi -expansion of a formula, 399
expansion of a model, 50
extended Frege, see also extended PK
extended PK, 161, 187
p-equivalence to G1 , 187
extended connection language, 320, 454
Extension by Deﬁnition
Lemma for bit deﬁnition, 109
Theorem for two-sorted, 107
Extension by Deﬁnition Theorem, 51
extension cedent, 187
extension variable, 187
FAC 0
LFAC 0 , 125
ΣB
0 -bit-deﬁnable, 108
characterization, 102
closed under ΣB
0 -deﬁnability, 112
closure under composition, deﬁnition by
cases, 103
deﬁnable in V 0 , 110
factoring, 242
Fanin2, 335
ﬁnite axiomatizability
i
of TV i , ΣB
0 (V ), 405
0
of TV , 220
of VACC (conditional), 316
of V i and TV i , 243
of V ∞ (conditional), 245, 253
of VP, 202
of V 0 , 129
ﬁnite sets as integers bin(X ), 85
ﬁnite sets as strings, 81
ﬁnitely satisﬁable, 17
ﬁrst-order logic, 17
ﬁrst-order vocabulary, 17
FO, 74
FO(COUNT), 282
FO(M), 282
formula, 9, 18
FLAF relation, 367
bounded, 42
bounded LS2 formulas, 256
bounded, two-sorted, 81
closed formula, 19
linearly bounded, 86

470

Index

prenex form, 38
provably computable, 373
pseudo formula, 366
QPC formula, 173
QT, quantiﬁed threshold, 441
quantiﬁer-free, 35
recognition in TC 0 , 366
threshold, PTK, 429
universal closure of, 24
universal formula, 54
formula classes
Δ0 (L), Σ1 (L), 51
B
ΣB
i (L), Πi (L), 82
ΣB
(Φ),
109
0
ΔB
i in a theory, 212
Δ0 , 42
ΣB
1 -Horn, 224
Σbi , 70
Σqi , Πqi , 174
Σ11 -Krom, 343
Σ1 , 42
Σ11 , 82, 107
B
gΣB
i , gΠi , 142
B
single-Σ1 , 115
Horn, 223
Krom, 339, 343
Formula Replacement Theorem, 21
FO(THRESHOLD), 282
P
FPΣi , 245
P
FPΣi [wit, O(1)], 253
P
FPΣi [wit, O(g(n))], 250
free variable, 19, 21
free variable normal form, 23, 90
computable in polytime, 373
for G, 175
for proofs with IND rule, 154, 170
free-cut-free proof, 14
freely substitutable, 21
Frege systems, 161
function
arithmetical, 107
bit graph, 101
bounding term for function, 104
deﬁnition by case, 103
elimination from formulas, see also Transformation Lemma, Elimination Lemma
graph, 101
provably total function, 108
two-sorted function, 101
function class, 101, 270
FC and C, 116

and complexity class, FC and C, 270
deﬁning FC from C, 101
function graph, 69
function problem, 229
Fval, 323
G, 175
G  , 175
KPG, 176
cut-free G  , 405
Gi+1 p-simulates Gi w.r.t. Σqi ∪ Πqi , 179
Gi p-simulates Gi+1 , 182
Gi : only cut prenex Σqi formulas, 181
Ĝi , 181
Gi ,Gi , 179, 363
q
Gi ,Gi : only cut Σi formulas, 180
upper bound, 177
Witnessing Problem, see also Witnessing
Problem
G0
p-simulates G0 w.r.t. prenex Σq1 , 180
Replacement Lemma, 185
G1
p-equivalence to ePK, 187
Witnessing Theorem, 186
GapL, 358
general connective, 177
Gentzen’s PK, 10
Gentzen’s Midsequent Theorem, 180
Gödel’s Incompleteness Theorem, 43
Grädel, 343
Grädel’s Theorem, 225
graph
st-CONN Problem, 339
deﬁnition of, 101
Distance Problem, UDP, 359
encoding of, 339
PATH problem, 351
transitive closure, 343
undirected, connectivity of, 359
ground instance, 35
GTC, 441
heap, 321
Herbrand  disjunction, 180
Herbrand Theorem, 35, 36, 267
proving Witnessing Theorem for V 0 , 127
Second Form, 54
two-sorted logic, 90
Horn formula, 223
HornSat algorithm, 224
ID0 , 46

Index
IΔ0 , 42, 49
IΔ0 , 54, 56
alternative axioms, 44
and V 0 , 99
Deﬁnability Theorem, 69
deﬁning BIT(i, x), 64
deﬁning BIT(i, x), y = 2x , 59
deﬁning y = 2x , 59, 62
provably total function, 51
Immerman–Szelepcsényi Theorem, 343, 450
IND, see also PIND, SIND, LIND, 41
ΣB
ΠB
i -REPL, 144
i +1 -IND
ΔB
i -IND, 222
Φ-IND rule, 150
B
B
i
ΣB
0 (Σi ∪ Πi )-IND in V , 134
bounded induction, 44
deﬁnition of, 97
implied by COMP, 98
induction in V i , 133
strong induction, 44
Independence of PHP from V 0 , 168
index, 465– 479
induction
X -IND, in V 0 , 98
induction axioms, see also IND, PIND,
SIND, LIND
bounded length induction, 265
inference rule for LK, 22
initial sequents, 10
interpreting IOPEN in V 1 , 137
introducing new symbols, 50
inversion principle, 13
IOPEN , 42
interpreted in V 1 , 137
IΣ1,b
0 , 130
IΣ1 , 42
provably total function, 51
ITERATION, 230
combining, 234
Jeřábek, 157
Jordan Curve Theorem, 268, 303, 309
König’s Lemma, 16
KPG, 176
KPT Witnessing Theorem, 238, 253
Krom formula, 339, 343
Σ11 -Krom formula, 343
Representation Theorem, 345
Krom-SAT, 339, 343
L, 339, 351, 447
characterized by BNR, 287, 356

471

deﬁnition of, 448
theories for, see also VL, VLV
#L, 358
language, 17
languages of theories, see also vocabularies
layered circuit, 335
least number principle, see also MIN
left, see also projection function
length function for number, |x|, 64
length function for string, |X |, 76
length induction axioms, see also LIND
length of a G proof (upper bound), 177
length of a sequent, 177
LH, 75, 83, 455
limited recursion, 139, 210, 268, 287
limited subtraction, 60, 220
LIND, 257
two-sorted, 338
Lind’s Characterization of FL, 356
linear formulas, 87
linear time hierarchy, see also LTH
linearly bounded formula, 86
LinTime, 66
LK, 21
LK-Φ proof, 24
anchored proof, 30, 33
derivational soundness, completeness, 25
equality axioms, 32
revised soundness, completeness, 33
Soundness Theorem, 22
LK with =
Anchored Completeness Theorem, 33
revised deﬁnition, 33
LK 2 , 87, 88
LK 2 +IND, 150
LK 2 -TV 1 , 233, 378
LK 2 -VNC 1 , 411
LK 2 -V 0 , 411
e 1 , 150
LK 2 -V
e 0 , 170
LK 2 -V
soundness and completeness, 89
local search, 229
log time hierarchy, see also LH
logical axiom, 11
logical consequence, 10, 21, 80
i
ΣB
j (V ), 403
of a set of sequents, 13
logspace, see also L
Löwenheim, 34
LTH, 65, 66, 86
FLTH, 69
deﬁning number function x · y, 87

472

Index

deﬁnition of, 452
LTH Theorem, 67
majority gate, 282
majority gates, 455
majority quantiﬁer, 282
many-one reducible, 229
mappings  and , 258
MAX, see also SMAX
i
ΣB
i -MAX in V , 133
B
e
Σ1 -MAX in V 1 , 150
B
B
i
ΣB
0 (Σi ∪ Πi )-MAX in V , 134
deﬁnition of, 97
maximization axioms, see also MAX,
SMAX
MCV, 202, 203, 272
MFV, 321
MFV variable, 412

MFV , MFV
(a, G, I, Y ), 411
propositional translation, 382
Midsequent Theorem, 180
MIN, see also SMIN
X -MIN provable in V 0 , 97
i
ΣB
i -MIN in V , 133
B ∪ ΠB )-MIN in V i , 134
ΣB
(Σ
i
i
0
deﬁnition, 44
deﬁnition of, 97
implied by COMP, 98
minimal theory, 268
VP, 210
for polytime, 201
minimization axioms, see also MIN, SMIN
mod m
Mod m , 314
MODm , 314
mod m , 314
model
expansion of a model, 50
term model, 29
model, M |= A, 19
MODULO, 303, 456
Modulo m Counting Principle, 316
V 0 (m) ∀a∀X Countp (a, X )?, 360
modulo m gates, 455
Modulo 2 Counting Principle, 306
modulo gate, 303
Monotone Circuit Value Problem, see also
MCV
Monotone Formula Value Problem, see also
MFV
Multi Tape Theorem, 448
MULTICOMP

deﬁnition of, 114
revisited, 134
Multiple Comprehension Lemma, 114
multiplication, 73
R× (X, Y, Z), 85
R× (X, Y, Z) not in AC 0 , 102
X × Y , 361
X × Y in V 1 , 136
X × Y in VTC 0 , 293
0
X × Y not ΣB
1 -deﬁnable in V , 109
multivalued function, 229
NC 1 , 319, 456
algorithm for BSVP, 415
characterized by 5-BNR, 333
theories for, see also VNC 1 , VNC 1 V
Witnessing Problem for G0 , G0 , 428
NC hierarchy, 319, 335
NC k , 319, 320
deﬁnition of, 455
Nepomnjaščij’s Theorem, 68
NL, 339
NL ⊆ LTH, 68
closed under complement, 339
deﬁnition of, 450
theories for, see also VNL, V 1 -KROM
NLinTime, 66, 451
DLogTime, 449
NLogTime, 83
Nondeterministic logspace, see also NL
nondeterministic Turing machine, see also
NTM
nonlogical axiom, 13
NOTM, 451
NP, 456
deﬁnition of, 450
NPC , 451
p
NPΣi , 65
NSpace, 450
NTime, 450
NTimeSpace, 68
NTM
deﬁnition of, 449
number quantiﬁer, 77
number recursion, see also BNR
number summation, see also summation
number term, 77
number variable, 76, 87
numeral, n, 40
NUMONES, 326
propositional translation, 434
relation, in IΔ0 , 65
numones, 282

Index
Numones , 285
numones , 286
Numones, 284
NUM , 283
deﬁning TC 0 , 283
e 1 , 149
for showing V 1 = V
in VNC 1 , 326
quantiﬁer-free deﬁnition, 286
object assignment, 19, 79
OPEN , 42
oracle Turing machine, see also OTM
ordering for string, see also string ≤
OTM, 451
P, FP, see also polytime
p-bounded function, 45, 101
in T , 105
p-bounded theory, 45
two-sorted, 105
p-equivalence, 161
q
Gi+1 and Gi w.r.t. Σi , 408
q

Gi +1 and Gi w.r.t. Σi , 182
PK and PTK, 431
ePK and G1 , 187
p-simulation
follow from RFN, 407
pairing function, 113
x, Y  and X, Y , 243
palindrome, 75, 83
parameter variable, 23
Parikh’s Theorem, 44, 45, 116, 141
alternative proof for IΔ0 , 58
two-sorted, 104, 105
parity, 303
PARITY (X ), 240
Parity(x, Y ), 304
parity(X ), 118
parity(X ) deﬁnable in V 1 , 136
ϕparity , 118, 270, 304
PARITY , 118, 456
PARITY not in AC 0 /poly, 75
ΣB
1 -Horn-formula ParityHorn (X ), 225
not in AC 0 , 118
separates V 0 and VTC 0 , 287
Parity Principle, 306
partial order, 298
PATH problem, 339, 351
PC , 451
pd, see also predecessor function
Peano Arithmetic, 39
Peano Arithmetic PA, 41
pebbling game, 415

473

PH, 65, 174
V ∞ vs PH, 253
deﬁnition of, 451
PHP, 163, 164, 268, 440
V 0 (m) PHP?, 360
in VTC 0 ,PTK, 291
in two-sorted logic, 167
independence from V 0 , 168
onto PHP, OPHP, 306, 317
separates V 0 and VTC 0 , 287
Pigeonhole Principle, see also PHP
PIND, 71, 257
PK, 10, 160
derivational soundness completeness, 13
p-simulates PTK, 431
proof, 10, 12
from assumptions, 13
Replacement Lemma, 163
short PK  -proofs of true sentences, 370
soundness and completeness, 12
treelike p-simulates daglike, 162
PK Simulation Theorem, 424
PLS, 186, 228, 229
P
PLS Σi−1 and TV i , 249
NP
P , 186
polynomial equivalence, see also pequivalence
Polynomial Local Search, see also PLS
polynomial simulation, see also p-simulation
polynomial time, see also polytime
polynomial time hierarchy, see also PH
polynomial-bounded theory, see also pbounded theory
polynomially bounded function, see also pbounded function
polynomially bounded proof system, 159,
160
polynomially induction axioms, see also
PIND
polytime, 65, 133, 447
P/poly, 254
characterized by ΣB
1 -Horn, 225
characterized by V 1 , 135
Cobham’s characterization, 139
deﬁnition of, 447
descriptive characterization of, 223
function, relation, 135
theories for, see also TV 0 , V 1 , VP, see also
V 1 -HORN, VPV, VC
theories for subclass, 267, 272, 280
predecessor function
axiom in IΔ0 , 44

474

Index

for number, pd, 125
predicate calculus, 17
semantics, 19
syntax, 17
preface, xiii–xv
prenex form, 38
Prenex Form Theorem, 38
prenex formula
prenexiﬁcation in TC 0 , 386
prime factorization, 148
prime recognition, 148
principal formula, 11, 22
principal formulas, 175
principle
least number, see also MIN
probabilistic polytime, 242
projection function, 113
proof
LK 2 , 88
PK, 10, 12
PRF F relation, 367
anchored proof, see also anchored proof,
14
encodings of, 365
extended PK, 187
from assumptions, 13
provably computable, 373
veriﬁcation in TC 0 , 364
proof system, 159, 160
existence of polynomially bounded proof
system ⇔ NP = co-NP, 161
QPC, 175
treelike vs daglike, 162
propositional calculus, 9
Propositional Compactness Theorem, 16
propositional formula, 9
propositional proof system, see also proof
system
propositional translation
V 0 to bPK, 165
computable in TC 0 , 373
for V i , 191
for bounded L2A formulas, 191
for MFV, 382
formalization of, 364

of ΣB
0 (numones ) formulas, 434
of NUMONES, 434
translating ΣB
0 formulas, 166
vs formalization, 387
propositional variable, 9
propositionally unsatisﬁable, 35
prototype, 180

provable collapse, 253
provably computable (formulas or proofs),
373
provably total function, 51
closed under composition, 108
two-sorted, 108
pseudo formula, 366
PSPACE, 174, 447, 448
deﬁnition of, 448
PSPACE/poly, 174
PTK, 291, 428
PK p-simulates PTK, 431
bounded depth, bPTK, d -PTK, 430
soundness, completeness, 430
QPC, 173
QPC proof system, 175
QPC sentence, 174
quantiﬁed propositional calculus, see also
QPC
quantiﬁed threshold formulas, 441
quantiﬁer, 18
∃X ≤ T, ∀X ≤ T , 219
bounded, 41
in two-sorted logic, 77
sharply bounded, 70
sharply bounded quantiﬁers, 256
quantiﬁer-free formula, 35
Razborov, 304
REACH, 341
reachability, ϕ¬Reach , 343
ΣB
0 -Rec, 353
recursion, 268
limited, see also limited recursion
recursively enumerable, 35
reduction, 73
≤AC 0 for search problems, 229
≤TC 0 for search problems, 409
AC 0 -reduction, 267, 269
AC 0 -reduction, 270
Reﬂection Principle, see also RFN, 159
relation
representable or deﬁnable, 66, 83
remainder function, 60
remainder string function, 137
REPL, 142, 204
ΠB
ΣB
i -REPL, 144
i +1 -IND
B
Πi -REPL ΣB
i +1 -REPL, 144
V 0  ΣB
0 -REPL, 240
ΣB
0 -REPL and VPV, 242
i
gΣB
i -REPL in V , 145

Index
and conservative extensions, 147
deﬁnition of, 143
replacement axioms, see also REPL
Replacement Lemma
for G0 , 185
for PK, 163
represent sets as binary strings, 81
representable relation, 66, 83
Representation Theorem
ΣB
1 , 86
Σ11 , 86
ΣB
0 , 84
for ΣB
1 -Horn formulas, 225
Representation Theorems, 81
restricted connective, 177
RFN, 363, 382
Σqi+1 -RFN cut-free G  , 405
TV i Σqi+1 -RFN G  , Πqi+1 -RFN Gi , 402
Vi

q

i+1

q

Πi -RFN Gi−1 , Σi -RFN G  , 400

i
axiomatize ΣB
j (V ), 403
axiomatize TV i , 404

i

deﬁnition of, 396
for d -PTK, 433
for ePK, 402
for PK, 421
for subsystems of G, 396
prove p-simulations, 407
treelike vs daglike, 398
right, see also projection function
ring, 43
Row, 114
RSUV isomorphism, 256, 258
between S2i and V i , 263
deﬁnition of, 259
rudimentary function, 131
rule
of PK, 11
rule of inference, 11
Ruzzo, 320, 336
S21 , 156, 256
S21 (BIT), 258
provably total function, 51
S2i , 256, 258
S2i hierarchy, 70
SAT
Krom-SAT, see also Krom-SAT
satisfaction, 10
M |= A, 19
M |= A[ ], 20
M |= Φ[ ], M |= Φ, 20
for a sequent, 10

satisﬁability problems
HornSat, 224
satisﬁability relation
(Z |=0 X ), 410
(Z |= X ), 382
0
ΔB
1 -deﬁnable in TV , 384
1
-deﬁnable
in
VNC
, 421
ΔB
1
for Σqi , Πqi formulas, 385
satisﬁable set of formulas, 10
Savitch’s Theorem, 450
search problem, 229
CC(S), 232
i
ΣB
i -deﬁnable in TV , 249
i , 250
ΣB
-deﬁnable
in
V
i +1
i , 253
ΣB
-deﬁnable
in
VPV
i +1
B
i
Σj -deﬁnable in V ,TV i , 250
deﬁnable in a theory, 232
second-order logic, 73
semantics of ﬁrst-order sequents, 22
semantics of predicate calculus, 19
semantics of two-sorted logic, 78
sentence, 19
∀ sentence, 35
SEQ, 283
seq(x, Z), see also sequence, coding
sequence
encode a sequence of numbers, 115
encode a sequence of string, 115
sequent, 10
active sequent, 27
determined sequent, 177
endsequent, 10
initial sequents, 10
logical consequence of, 13
semantics of, 10
valid sequent, 10
sequent length, 177
set
empty, see also empty set
set variable, 76
sharply bounded quantiﬁer, 70
sharply bounded quantiﬁers, 256
SIND
ΔB
i -SIND, 222
Φ-SIND rule, 233
SIND rule, 378
deﬁnition of, 218
single string quantiﬁer, 115
singleton set, see also POW2
Skolem, 34
Skolem functions, 35, 55
smash function #, 70

475

476

Index

SMAX
deﬁnition of, 219
prove BIT-REC, 222
SMIN
deﬁnition of, 219
Smolensky, 304
sorting, 287
soundness principle, see also RFN
Soundness Theorem
LK 2 , 89
PTK, 430
for G, 176
for LK, 22
for LK, derivational, 25
for LK, Revised, 33
for LK 2 +IND, 151
for PK, 13
for PK, derivational, 13
space constructible function, 448
Space Hierarchy Theorem, 448
Speed-up Theorem, 447
square root function, 60
standard model N2 , 79
standard model, N, 20, 40
st-CONN, 339
strict Σb1 , 156
string comprehension, 270
string function
addition, see also addition
deﬁnability, see also deﬁnability
division, see also division
empty set, see also empty set
encoding Turing machine conﬁgurations,
see also conﬁguration, functions encoding
multiplication, see also multiplication
successor, see also successor function
string induction axioms, see also SIND
string maximization axioms, see also SMAX
string minimization axioms, see also SMIN
string ordering X ≤ Y , 219
string quantiﬁer, 77
∃X ≤ T, ∀X ≤ T , 219
string term, 77
string variable, 76, 87
strong induction, 44
structure, 19
weak structure, 31
L2A -structure, 78
student-teacher, 238
subformula property, 14, 15
of LK 2 +IND, 153

of anchored LK, 33
of anchored LK 2 , 89
provable in VTC 0 , 373
sublinear time classes, 449
substitution, 21
Substitution Lemma, 185
Substitution Theorem, 21
substring function
X [i, j], 366
subtraction Z −· Y , 220
succedent, 10
successor function S(X ), 112, 218
successor relation S(X, Y ), 378
Sum, 294
summation, 288, 289
syntax of predicate calculus, 17
Szpilrajn’s Theorem, 298
T2i , 71, 256, 258
TA, 40
tagged formula, 183
Tape Compression Theorem, 448
target formula, 175
TAUT, 160
tautology, 10
TC 0 , 70, 282
TC 0 /poly, 282
closed under summation, 288
computing propositional translation, 373
contains X × Y , 293
contains ACC, 304
deﬁnition of, 456
ﬁnite iterations, 269
functions for verifying proofs, 364
sorting in TC 0 , 287
theories for, see also VTC 0 , VTC 0 V
verifying proofs in TC 0 , 364
term, 18
bounding term for function, 104
closed term, 19
in two-sorted logic, 77
term model, 29
Theorem
Grädel, 225
theorem, 40
theory, 39, 90
p-bounded theory, 45
universal theory, 54
threshold gate, 282
threshold gates, 456
threshold logic, 428
time constructible function, 448
Time Hierarchy Theorem, 448

477

Index
total order, 298
Transformation Lemma
ΣB
1 , using REPL, 145
ΣB
0 , using (bit) deﬁnitions, 111
transitive closure, 343
ContainTC, 343
translation
 translation, 262
 translation, 260
propositional, see also propositional
translation
Translation Theorem, 363
for TV i , 377
for TV 0 , 382
for V i , 192
0
for V i , formalization in VTC , 377
1
for VNC , 411
for VTC 0 , 442
for V 0 , 168
all bounded theorems, 195
proof of, 170
0
for V 0 , formalization in VTC , 375
for V 0 (numones ), 442
tree recursion, see also TreeRec
treelike proof system, 162
ΣB
0 -TreeRec, 325
True Arithmetic, 40
truth assignment, 9
L-truth assignment, 35
truth deﬁnitions, 383
truth value, 9
tupling function, 113
Turing machine
alternating TM, see also ATM
deﬁnition of, 445
nondeterministic oracle TM, see also
NOTM
nondeterministic TM, see also NTM
oracle TM, see also OTM
TV 0 , 217, 367
TV 0 = VP, 220
ΣB
0 -BIT-REC, 222
RFN ePK , 402
ΔB
1 -SIND, 223
0
1
V is ΣB
1 -conservative over TV , 220
ﬁnite axiomatizable, 220
TV 1 , 228
TV 1 (VPV), 220
Witnessing Theorem, 233
TV i , 217, 218, 363
TV i (VPV), 220
TV i (VPV) conservative over TV i , 220

V i ⊆ TV i , 219
V i ⊆ TV i , 244
ΣB
i -IND, 218
Σqi+1 -RFN G  , Πqi+1 -RFN Gi , 402
i+1

ΣB
i -SMIN, SMAX, 219
B
Σi -deﬁnable search problems of, 249
ΣB
j -deﬁnable search problems of, 250
i
V i +1 ΣB
i +1 -conservative over TV , 249
axiomatized by RFN, 404
ﬁnite axiomatizable, 405
ﬁnitely axiomatizable, 243
Translation Theorem, 377
two-sorted classes, 73, 80
LTH, 86
two-sorted function, 101
two-sorted logic, 73, 76
interpreted as single-sorted, 91
semantics, 78
syntax, 76
two-sorted theory, 90
deﬁnability, 107
Tychonoﬀ’s Theorem, 17
U 1 , 338
uniformity, 453
universal closure, 24
universal conservative extension, 124
universal formula, 54
universal function, 243
universal theory, 54
Witnessing Theorem, 211
universe, 19
unsatisﬁable set of formulas, 10
upper bound for G proofs, 177
V 0 , 73, 95, 267
V 0 (Row), 114
V 0 (TrueΣB
0 ), 128
V 0 (∅, S, +), 112
V 0  Count2 , 307
V 0  OPHP, 306
V 0  ΣB
0 -REPL, 240
ΣB
0 -deﬁnable functions, 110
0
V 0 (2) not ΣB
0 -conservative over V , 308,
318
0
V , 124
e
V 0 , 169
conservative over IΔ0 , 99
deﬁnability in V 0 , 106
Deﬁnability Theorem, 117
ﬁnite axiomatizability, 129
independence of PHP, 168

478
properly contained in V 1 , 136
properly in V 0 (m), 318
properly in VTC 0 , 287
properly in V 0 (2), 308
proves X -IND, 98
proves X -MIN, 97
Translation Theorem, 168
all bounded theorems, 195
0
formalization in VTC , 375
proof of, 170
Witnessing Theorem, 117
V 0 (2), 303, 304
V 0 (2), 305

0 (2), 305
V
Deﬁnability Theorem, 305
0
not ΣB
0 -conservative over V , 308, 318
0
properly contains V , 308
proves Count2 , 307
proves Jordan Curve Theorem, 311
proves OPHP, 306
V 0 (m), 314
V 0 (m) PHP?, 360
V 0 (m) ∀a∀X Countp (a, X )?, 360
Countm , 317
Countm  for gcd(m, m  ) > 1, 317
0
V (m), 315

0 (m), 314
V
Deﬁnability Theorem, 315
properly contains V 0 , 318
V 0 (numones ), 434
Translation Theorem, 442
V 1 , 133
ΣB
1 -REPL, 144
ΔB
1 -SIND, 223
0
ΣB
1 -conservative over TV , 220
ΣB
-conservative
over
VP,
217
1
V 1 (VPV), 213
e 1 , 149
V
and VPV, 213
characterizes P, 135
Deﬁnability Theorem, 135
extended by polytime functions, 145
interprets IOPEN , 137
prime factorization, 148
prime recognition, 148
properly contains V 0 , 136
Witnessing Theorem, 147
proof of, 154
V11 , 156
V 1 -KROM, 339, 343
= VNL, 347

Index
deﬁnition, 346
V i , 96, 363
V i ⊆ TV i , 219
V i ⊆ TV i , 244
B
B
ΣB
0 (Σi ∪ Πi )-COMP, 134
-IND,
MIN,
MAX, 99, 133
ΣB
i
gΣB
i -REPL, 145
Πqi -RFN Gi−1 , Σqi -RFN G  , 400
i

ΣB
i +1 -deﬁnable search problems of, 250
ΣB
j -deﬁnable search problems of, 250
V i (VPV), 213
i
V i +1 ΣB
i +1 -conservative over TV , 249
ﬁnitely axiomatizable, 243
Translation Theorem, 192
0
formalization in VTC , 377
∞
V , 245
vs PH, 253
VAC 0 (2)V, 303, 308
VAC 0 (6)V, 303, 318
VACC, 315
Deﬁnability Theorem, 315
VAC k and VNC k , 337
valid, 10
valid formula, 10, 20
valid QPC formula, 174
valid sequent, 10, 22
variable, 18
bound variable, 21
extension variable, 187
free and bound in two-sorted, 87
free and bound variable, 19, 21
in two-sorted logic, 76
parameter variable, 23
propositional, 9
VC, 267
COMP, IND, MIN, 274
VC, 278
c 274
VC,
deﬁnition, 273
proves COMP, IND, MIN, 279
V 1 -HORN, 223
= VP, 226
deﬁnition of, 226
VL, 339, 351
= ΣB
0 -Rec, 354
?

= VSL, 358
contains VNC 1 , 354
Deﬁnability Theorem, 353
VLV, 339, 356
VNC 1 , 323
= ΣB
0 -TreeRec, 325

Index
ΔB
1 -deﬁnes (Z |= X ), 421
contains VTC 0 , 326
Deﬁnability Theorem, 324
in VL, 354
proves RFN PK , 424
Translation Theorem, 411
VNC 1 V, 333
VNL, 339, 341
= V 1 -KROM, 347
VNL, 342
Deﬁnability Theorem, 342
vocabularies
LA , 18, 40
LFAC 0 , 125
LFO , 74
LΔ0 , 56
LFP , 210
LFPi , 246
LS2 , 70, 256
L+
S , 262
2

L2A , 76
L+ , 260
vocabulary, 17
VP, 201, 267, 273
= V 1 -HORN, 226
TV 0 = VP, 220
VP ⊆ V 0 + ΣB
0 -BIT-REC, 223
V 1 is ΣB
1 -conservative over VP, 217
VPV conservative over VP, 214
c 207
VP,
ﬁnite axiomatizable, 202
minimal theory for P, 210
VPV, 210
ΣB
0 (LFP )-COMP, IND, MIN, MAX,
212
ΔB
1 -SIND, 222
ΣB
0 (LFP )-SIND, 221
ΣB
0 -REPL and VPV, 242
and V 1 (VPV), 214
and V 1 , 213
binary search, 221
conservative over VP, 214
Deﬁnability Theorem, 214
deﬁnition of, 211
Witnessing Theorem, 212

479

VPV i , 245
ΣB
0 (LFPi )-COMP, IND, MIN, MAX,
247
ΣB
i +1 -deﬁnable search problems of, 253
deﬁnition of, 246
VSL, 358
VTC 0 , 281, 403
ΔB
1 -deﬁnes PRF F , 368
VTC 0 V, 287
0
VTC , 286
deﬁnes propositional translations, 375
V 0 (numones ), 434
can deﬁne X/Y ?, 360
Deﬁnability Theorem, 286
deﬁning X × Y , 293
deﬁnition, 283
in VNC 1 , 326
properly extends V 0 , 287
proves PHP, 291
sorting in VTC 0 , 287
Translation Theorem, 442
VTC 0 V, 289
weak structure, 31
witness query, 250
witnessing functions, 117
Witnessing Problem
deﬁnition of, 409
for G, 408
for G1 , 363
for G0 , G0 , 428
Witnessing Theorem
for G1 , 186
for TV 1 , 233
for V 1 , 147
proof of, 154
for VPV, 212
for V 0 , 95, 117, 118
alternative proof of, 127
proof of, 119
for universal theories, 211
KPT, see also KPT Witnessing Theorem
Zambella, 130
Zorn’s Lemma, 17

